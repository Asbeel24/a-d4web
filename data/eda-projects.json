[
    {
        "åºå·": 1,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <style>\n    /* ç§»é™¤é¡µé¢çš„è¾¹è·å’Œæ»šåŠ¨æ¡ï¼Œç¡®ä¿åœ¨Wixæ¡†å†…å…¨å±æ˜¾ç¤º */\n    body { margin: 0; padding: 0; overflow: hidden; background: #000; }\n    canvas { display: block; }\n  </style>\n  <!-- å¼•å…¥ p5.js åº“ -->\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js\"></script>\n</head>\n<body>\n  <div id=\"canvas-container\"></div>\n\n  <script>\n    // ä½¿ç”¨å®ä¾‹æ¨¡å¼ (Instance Mode) ä»¥é€‚é… Wix ç¯å¢ƒ\n    const s = (p) => {\n      let particles = [];\n      const numParticles = 150; // ç²’å­æ•°é‡\n      let mode = 0; // å½“å‰ç®—æ³•æ¨¡å¼\n      let lastSwitchTime = 0;\n      let switchInterval = 4000; // æ¯4ç§’åˆ‡æ¢ä¸€æ¬¡ç®—æ³•\n\n      p.setup = function() {\n        // åˆ›å»ºç”»å¸ƒï¼Œè‡ªé€‚åº”çª—å£å¤§å°\n        p.createCanvas(p.windowWidth, p.windowHeight).parent('canvas-container');\n        p.colorMode(p.HSB, 360, 100, 100, 100);\n        p.background(0);\n\n        // åˆå§‹åŒ–ç²’å­\n        for (let i = 0; i < numParticles; i++) {\n          particles.push(new Particle(p));\n        }\n      };\n\n      p.draw = function() {\n        // --- 1. åˆ¶é€ å»¶è¿Ÿ/æ®‹å½±æ•ˆæœ (Delay) ---\n        // ä¸å®Œå…¨æ¸…ç©ºèƒŒæ™¯ï¼Œè€Œæ˜¯è¦†ç›–ä¸€å±‚åŠé€æ˜é»‘è‰²\n        // é€æ˜åº¦è¶Šä½(10)ï¼Œæ‹–å°¾è¶Šé•¿ï¼›é€æ˜åº¦è¶Šé«˜(50)ï¼Œæ‹–å°¾è¶ŠçŸ­\n        p.noStroke();\n        p.fill(0, 0, 0, 5); \n        p.rect(0, 0, p.width, p.height);\n\n        // --- 2. è‡ªåŠ¨åˆ‡æ¢ç®—æ³• ---\n        if (p.millis() - lastSwitchTime > switchInterval) {\n          mode = (mode + 1) % 3; // åœ¨ 0, 1, 2 ä¹‹é—´å¾ªç¯\n          lastSwitchTime = p.millis();\n          // åˆ‡æ¢æ—¶äº§ç”Ÿä¸€æ¬¡å¼ºçƒˆçš„æ•…éšœé—ªçƒ\n          glitchEffect(true); \n        }\n\n        // --- 3. è¿è¡Œç²’å­ç³»ç»Ÿ ---\n        for (let particle of particles) {\n          particle.update(mode);\n          particle.show(mode);\n        }\n\n        // --- 4. éšæœºæ•…éšœæ•ˆæœ (Glitch) ---\n        // 1% çš„æ¦‚ç‡è§¦å‘éšæœºæ•…éšœ\n        if (p.random(1) < 0.02) {\n          glitchEffect(false);\n        }\n      };\n\n      // çª—å£å¤§å°æ”¹å˜æ—¶é‡ç½®ç”»å¸ƒ\n      p.windowResized = function() {\n        p.resizeCanvas(p.windowWidth, p.windowHeight);\n        p.background(0);\n      };\n\n      // --- æ•…éšœæ•ˆæœå‡½æ•° ---\n      function glitchEffect(isMajor) {\n        if (isMajor) {\n          // å‰§çƒˆæ•…éšœï¼šåè‰²æˆ–æ•´ä½“åç§»\n          p.filter(p.INVERT);\n        } else {\n          // è½»å¾®æ•…éšœï¼šåˆ‡ç‰‡é”™ä½\n          let y = p.random(p.height);\n          let h = p.random(10, 50);\n          let xOffset = p.random(-20, 20);\n          // æŠ“å–ä¸€éƒ¨åˆ†ç”»é¢å¹¶é”™ä½ç²˜è´´\n          let strip = p.get(0, y, p.width, h);\n          p.image(strip, xOffset, y);\n          \n          // éšæœºè‰²å—\n          p.fill(p.random(360), 80, 100, 80);\n          p.rect(p.random(p.width), p.random(p.height), p.random(50), 5);\n        }\n      }\n\n      // --- ç²’å­ç±» ---\n      class Particle {\n        constructor(p) {\n          this.p = p;\n          this.pos = p.createVector(p.random(p.width), p.random(p.height));\n          this.vel = p.createVector(0, 0);\n          this.acc = p.createVector(0, 0);\n          this.maxSpeed = 2;\n          this.h = p.random(0); // è‰²ç›¸\n        }\n\n        update(currentMode) {\n          this.acc.mult(0); // é‡ç½®åŠ é€Ÿåº¦\n\n          // æ ¹æ®æ¨¡å¼åº”ç”¨ä¸åŒçš„åŠ›\n          if (currentMode === 0) {\n            // æ¨¡å¼0: å™ªå£°æµåœº (Flow Field) - è‡ªç„¶ã€æŸ”é¡º\n            let angle = this.p.noise(this.pos.x * 0.01, this.pos.y * 0.01, this.p.frameCount * 0.005) * this.p.TWO_PI * 2;\n            let force = p5.Vector.fromAngle(angle);\n            force.mult(0.5);\n            this.acc.add(force);\n            this.maxSpeed = 3;\n          } \n          else if (currentMode === 1) {\n            // æ¨¡å¼1: èºæ—‹å¼•åŠ› (Spiral) - èšé›†ã€æ—‹è½¬\n            let center = this.p.createVector(this.p.width / 2, this.p.height / 2);\n            let dir = p5.Vector.sub(center, this.pos);\n            dir.normalize();\n            dir.mult(0.1); // å‘å¿ƒåŠ›\n            this.acc.add(dir);\n            \n            // æ·»åŠ åˆ‡çº¿åŠ›äº§ç”Ÿæ—‹è½¬\n            let tangent = this.p.createVector(-dir.y, dir.x);\n            tangent.mult(0.5); \n            this.acc.add(tangent);\n            this.maxSpeed = 5;\n          } \n          else if (currentMode === 2) {\n            // æ¨¡å¼2: æœºæ¢°ç½‘æ ¼ (Grid Glitch) - åƒµç¡¬ã€ç›´çº¿\n            if (this.p.frameCount % 10 === 0) { // æ¯10å¸§æ‰æ”¹å˜ä¸€æ¬¡æ–¹å‘\n              let r = this.p.floor(this.p.random(4));\n              if (r === 0) this.vel = this.p.createVector(2, 0);\n              else if (r === 1) this.vel = this.p.createVector(-2, 0);\n              else if (r === 2) this.vel = this.p.createVector(0, 2);\n              else this.vel = this.p.createVector(0, -2);\n            }\n            this.maxSpeed = 8;\n          }\n\n          // ç‰©ç†æ›´æ–°\n          if (currentMode !== 2) {\n            this.vel.add(this.acc);\n            this.vel.limit(this.maxSpeed);\n          }\n          \n          this.pos.add(this.vel);\n          this.edges();\n        }\n\n        show(currentMode) {\n          // æ ¹æ®æ¨¡å¼æ”¹å˜å¤–è§‚\n          if (currentMode === 2) {\n            this.p.stroke(this.h, 0, 100); // ç™½è‰²\n            this.p.strokeWeight(2);\n            this.p.point(this.pos.x, this.pos.y);\n          } else {\n            this.p.stroke(this.h, 80, 100);\n            this.p.strokeWeight(currentMode === 0 ? 2 : 4);\n            this.p.point(this.pos.x, this.pos.y);\n          }\n          // é¢œè‰²æ¸å˜\n          this.h = (this.h + 0.5) % 360;\n        }\n\n        edges() {\n          if (this.pos.x > this.p.width) this.pos.x = 0;\n          if (this.pos.x < 0) this.pos.x = this.p.width;\n          if (this.pos.y > this.p.height) this.pos.y = 0;\n          if (this.pos.y < 0) this.pos.y = this.p.height;\n        }\n      }\n    };\n\n    new p5(s);\n  </script>\n</body>\n</html>"
    },
    {
        "åºå·": 2,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <style>\n    /* èƒŒæ™¯è®¾ä¸ºæ·±ç°/é»‘è‰²ï¼Œçªæ˜¾é“¶è‰²è´¨æ„Ÿ */\n    body { margin: 0; padding: 0; overflow: hidden; background: #1a1a1a; }\n    canvas { display: block; }\n  </style>\n  <!-- å¼•å…¥ p5.js -->\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js\"></script>\n</head>\n<body>\n  <div id=\"canvas-container\"></div>\n\n  <script>\n    const s = (p) => {\n      let particles = [];\n      const numParticles = 400; // ç²’å­æ•°é‡ï¼ˆ3Dæ¨¡å¼ä¸‹ä¸å®œè¿‡å¤šï¼Œä»¥å…å¡é¡¿ï¼‰\n      let mode = 0;\n      let lastSwitchTime = 0;\n      let switchInterval = 5000; // 5ç§’åˆ‡æ¢ä¸€æ¬¡\n      \n      // æ‘„åƒæœºæ—‹è½¬è§’åº¦\n      let camAngle = 0;\n\n      p.setup = function() {\n        // å¼€å¯ WEBGL 3D æ¨¡å¼\n        p.createCanvas(p.windowWidth, p.windowHeight, p.WEBGL).parent('canvas-container');\n        p.noStroke(); // å»æ‰æè¾¹ï¼Œè®©å…‰å½±æ›´çº¯ç²¹\n\n        // åˆå§‹åŒ–ç²’å­\n        for (let i = 0; i < numParticles; i++) {\n          particles.push(new Particle(p));\n        }\n      };\n\n      p.draw = function() {\n        p.background(20); // æ·±è‰²èƒŒæ™¯\n\n        // --- 1. ç¯å…‰è®¾ç½® (åˆ¶é€ é“¶è‰²è´¨æ„Ÿçš„æ ¸å¿ƒ) ---\n        p.ambientLight(60); // åŸºç¡€ç¯å¢ƒå…‰ï¼ˆæš—ç°ï¼‰\n        p.pointLight(255, 255, 255, 0, -200, 200); // é¡¶éƒ¨ç™½å…‰\n        p.directionalLight(200, 200, 255, 1, 0, -1); // ä¾§é¢å†·å…‰\n\n        // --- 2. æ‘„åƒæœºè‡ªåŠ¨è¿é•œ ---\n        // è®©æ•´ä¸ªåœºæ™¯ç¼“æ…¢æ—‹è½¬ï¼Œå¢åŠ 3Dç©ºé—´æ„Ÿ\n        p.rotateY(camAngle);\n        camAngle += 0.002;\n\n        // --- 3. é€»è¾‘æ§åˆ¶ ---\n        // è‡ªåŠ¨åˆ‡æ¢ç®—æ³•\n        if (p.millis() - lastSwitchTime > switchInterval && !p.mouseIsPressed) {\n          mode = (mode + 1) % 3;\n          lastSwitchTime = p.millis();\n        }\n\n        // --- 4. ç²’å­æ›´æ–°ä¸æ¸²æŸ“ ---\n        for (let particle of particles) {\n          particle.update(mode);\n          particle.display();\n        }\n      };\n\n      p.windowResized = function() {\n        p.resizeCanvas(p.windowWidth, p.windowHeight);\n      };\n\n      // --- ç²’å­ç±» ---\n      class Particle {\n        constructor(p) {\n          this.p = p;\n          // ä½ç½®\n          this.pos = p.createVector(p.random(-200, 200), p.random(-200, 200), p.random(-200, 200));\n          // ç›®æ ‡ä½ç½®ï¼ˆç”¨äºç¼“åŠ¨åŠ¨ç”»ï¼‰\n          this.target = this.pos.copy();\n          // è‡ªèº«æ—‹è½¬\n          this.rot = p.createVector(p.random(p.TWO_PI), p.random(p.TWO_PI));\n          this.size = p.random(5, 12);\n        }\n\n        update(currentMode) {\n          // === äº¤äº’æ¨¡å¼ï¼šé¼ æ ‡ç‚¹å‡» ===\n          if (this.p.mouseIsPressed) {\n            // å°†é¼ æ ‡çš„2Dåæ ‡æ˜ å°„åˆ°3Dç©ºé—´çš„å¤§è‡´ä½ç½®\n            // æ³¨æ„ï¼šWEBGLæ¨¡å¼ä¸‹ä¸­å¿ƒæ˜¯(0,0)ï¼Œè€Œé¼ æ ‡æ˜¯å·¦ä¸Šè§’(0,0)\n            let mx = this.p.mouseX - this.p.width / 2;\n            let my = this.p.mouseY - this.p.height / 2;\n            \n            // åŠ ä¸Šåå‘æ—‹è½¬æŠµæ¶ˆæ‘„åƒæœºæ—‹è½¬ï¼Œè®©äº¤äº’æ›´ç›´è§‚\n            let mouseTarget = this.p.createVector(mx, my, 0);\n            \n            // å¼ºåŠ›å¸é™„ç®—æ³• (Lerp)\n            this.pos.lerp(mouseTarget, 0.05);\n            \n            // æ¿€åŠ¨çš„æŠ–åŠ¨æ•ˆæœ\n            this.pos.x += this.p.random(-5, 5);\n            this.pos.y += this.p.random(-5, 5);\n            return; // äº¤äº’æ—¶è·³è¿‡å¸¸è§„ç®—æ³•\n          }\n\n          // === è‡ªåŠ¨ç®—æ³•æ¨¡å¼ ===\n          let t = this.p.frameCount;\n          \n          if (currentMode === 0) {\n            // Mode 0: æ¼‚æµ®æ˜Ÿäº‘ (Noise Flow)\n            let n = this.p.noise(this.pos.x * 0.01, this.pos.y * 0.01, t * 0.01);\n            this.pos.x += this.p.map(n, 0, 1, -1, 1);\n            this.pos.y += this.p.sin(t * 0.02 + this.pos.x * 0.01);\n            \n            // è¾¹ç•Œé™åˆ¶ï¼Œé˜²æ­¢é£å¤ªè¿œ\n            if(this.pos.mag() > 400) this.pos.mult(0.95);\n          } \n          else if (currentMode === 1) {\n            // Mode 1: DNA èºæ—‹ (Helix)\n            let angle = t * 0.02 + this.pos.y * 0.01;\n            let radius = 150 + this.p.sin(t * 0.05) * 50;\n            let tx = this.p.cos(angle) * radius;\n            let tz = this.p.sin(angle) * radius;\n            // ç¼“åŠ¨æ¥è¿‘ç›®æ ‡ä½ç½®\n            this.pos.x = this.p.lerp(this.pos.x, tx, 0.05);\n            this.pos.z = this.p.lerp(this.pos.z, tz, 0.05);\n          } \n          else if (currentMode === 2) {\n            // Mode 2: è„‰å†²çƒä½“ (Pulsing Sphere)\n            // è®©ç²’å­å½’ä½åˆ°ä¸€ä¸ªçƒä½“è¡¨é¢\n            let r = 200 + this.p.sin(t * 0.1) * 50; // å‘¼å¸æ•ˆæœ\n            this.target.normalize(); // å½’ä¸€åŒ–å‘é‡\n            this.target.mult(r);     // æ‰©å±•åˆ°åŠå¾„r\n            this.pos.lerp(this.target, 0.05);\n          }\n\n          // è‡ªèº«æ—‹è½¬å¢åŠ é—ªçƒæ„Ÿ\n          this.rot.x += 0.02;\n          this.rot.y += 0.03;\n        }\n\n        display() {\n          this.p.push();\n          this.p.translate(this.pos.x, this.pos.y, this.pos.z);\n          this.p.rotateX(this.rot.x);\n          this.p.rotateY(this.rot.y);\n          \n          // --- æè´¨è®¾ç½® ---\n          // specularMaterial åå°„å…‰çº¿ï¼Œäº§ç”Ÿé‡‘å±æ„Ÿ\n          // shininess è®¾ç½®åå…‰åº¦\n          this.p.specularMaterial(220); \n          this.p.shininess(50);\n          \n          // å¶å°”æœ‰äº›ç²’å­å˜æˆé«˜äº®ï¼ˆæ•…éšœæ„Ÿï¼‰\n          if (this.p.random(1) < 0.01) {\n            this.p.emissiveMaterial(255); // è‡ªå‘å…‰\n          }\n\n          // ç»˜åˆ¶ç«‹æ–¹ä½“ (æ¯”çƒä½“æ›´æœ‰æ•°å­—æ„Ÿï¼Œä¸”æ¸²æŸ“æ›´å¿«)\n          this.p.box(this.size);\n          this.p.pop();\n        }\n      }\n    };\n\n    new p5(s);\n  </script>\n</body>\n</html>"
    },
    {
        "åºå·": 3,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Ryoji Ikeda Data Soundscape</title>\n  <style>\n    /* çº¯é»‘èƒŒæ™¯ï¼Œéšè—å…‰æ ‡ï¼Œå…¨å±æ²‰æµ¸ */\n    body { margin: 0; padding: 0; overflow: hidden; background: #000; cursor: none; }\n    canvas { display: block; }\n    \n    /* æç®€æç¤ºæ–‡å­— */\n    #overlay {\n      position: absolute;\n      top: 50%; left: 50%;\n      transform: translate(-50%, -50%);\n      color: #fff;\n      font-family: 'Courier New', Courier, monospace;\n      font-size: 10px;\n      letter-spacing: 8px;\n      pointer-events: none;\n      text-align: center;\n      opacity: 0.7;\n      z-index: 10;\n    }\n  </style>\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js\"></script>\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js\"></script>\n</head>\n<body>\n  <div id=\"overlay\">INITIALIZING DATA STREAM<br>[ CLICK TO CONNECT ]</div>\n  <div id=\"canvas-container\"></div>\n\n  <script>\n    const s = (p) => {\n      let keys = [];\n      let synth, crusher, filter;\n      let isAudioStarted = false;\n      let loop;\n      \n      // å³ä½¿æ˜¯æ•°æ®å£°ï¼Œæˆ‘ä»¬ä¾ç„¶æ˜ å°„åœ¨éŸ³é˜¶ä¸Šï¼Œä½†å¬èµ·æ¥ä¼šåƒä¸åŒé¢‘ç‡çš„ç”µæµ\n      const whiteNotes = [\"C6\", \"D6\", \"E6\", \"F6\", \"G6\", \"A6\", \"B6\", \"C7\", \"D7\", \"E7\", \"F7\", \"G7\"];\n      const blackNotes = [\"C#6\", \"D#6\", null, \"F#6\", \"G#6\", \"A#6\", null, \"C#7\", \"D#7\", null, \"F#7\", \"G#7\"];\n\n      p.setup = function() {\n        p.createCanvas(p.windowWidth, p.windowHeight).parent('canvas-container');\n        p.frameRate(60);\n\n        // --- 1. å£°éŸ³è®¾è®¡ï¼šçº¯ç²¹çš„æ•°æ®æµ (Pure Data Stream) ---\n        \n        // ä½¿ç”¨ MetalSynth å’Œ FMSynth çš„æ··åˆç‰¹æ€§\n        // è¿™é‡Œæˆ‘ä»¬ç”¨ FM æ¨¡æ‹Ÿâ€œè°ƒåˆ¶è§£è°ƒå™¨â€çš„å°–å«å£°\n        synth = new Tone.PolySynth(Tone.FMSynth, {\n          maxPolyphony: 10,\n          voice: {\n            modulationIndex: 50,  // æé«˜çš„è°ƒåˆ¶æ·±åº¦ -> äº§ç”Ÿé‡‘å±å™ªéŸ³\n            harmonicity: 3.05,    // éæ•´æ•°å€æ³›éŸ³ -> äº§ç”Ÿä¸å’Œè°çš„æœºæ¢°æ„Ÿ\n            envelope: { \n              attack: 0.001,      // ç¬é—´èµ·éŸ³\n              decay: 0.005,        // æçŸ­è¡°å‡ (Click)\n              sustain: 0,         // æ— å»¶éŸ³\n              release: 0.01 \n            },\n            modulation: { type: \"square\" }, // æ–¹æ³¢è°ƒåˆ¶ -> ç²—ç³™æ„Ÿ\n            oscillator: { type: \"pulse\" }   // è„‰å†²æ³¢åŸºåº• -> å°–é”æ„Ÿ\n          }\n        });\n\n        // æ•ˆæœé“¾ï¼š\n        // 1. BitCrusher: é™ä½é‡‡æ ·ç‡ï¼Œåˆ¶é€ â€œåæ‰çš„æ•°å­—ä¿¡å·â€å£°éŸ³\n        // 2. Highpass Filter: åˆ‡æ‰æ‰€æœ‰ä½é¢‘ï¼Œåªç•™é«˜é¢‘æ»‹æ»‹å£°\n        crusher = new Tone.BitCrusher(2); // 4-bit æ·±åº¦ (éå¸¸ Lo-fi)\n        filter = new Tone.Filter(7000, \"highpass\"); // åªä¿ç•™ 1500Hz ä»¥ä¸Šçš„å£°éŸ³\n        \n        synth.chain(crusher, filter, Tone.Destination);\n\n        // --- 2. é«˜é€Ÿéšæœºæ•°æ®åŒ… (Data Packets) ---\n        // é€Ÿåº¦è®¾ä¸º 64åˆ†éŸ³ç¬¦ï¼Œæå¿«ï¼Œåƒæ•°æ®ä¼ è¾“\n        loop = new Tone.Loop((time) => {\n          let activeKeys = keys.filter(k => k.active);\n          \n          // åªæœ‰å½“æœ‰é”®è¢«æŒ‰ä¸‹æ—¶æ‰è§¦å‘\n          if (activeKeys.length > 0) {\n            // æ›´åŠ éšæœºçš„è§¦å‘æ¦‚ç‡ï¼Œæ¨¡æ‹Ÿä¸ç¨³å®šçš„ä¿¡å·\n            if (p.random(1) < 0.4) {\n              let k = p.random(activeKeys);\n              // éšæœºæ”¹å˜éŸ³ç¬¦æ—¶å€¼ï¼Œæœ‰çš„æçŸ­ï¼Œæœ‰çš„ç¨é•¿\n              let duration = p.random() < 0.8 ? \"64n\" : \"32n\";\n              synth.triggerAttackRelease(k.note, duration, time);\n              k.triggerFlash(); // è§¦å‘è§†è§‰åŒæ­¥\n            }\n          }\n        }, \"32n\");\n\n        // --- 3. ç•Œé¢å¸ƒå±€ (Spectra é£æ ¼) ---\n        let keyW = p.width * 0.06; \n        let keyH = 250; \n        let startX = (p.width - (whiteNotes.length * keyW)) / 2;\n        let startY = (p.height - keyH) / 2 + 80;\n\n        for (let i = 0; i < whiteNotes.length; i++) {\n          keys.push(new Key(p, startX + i * keyW, startY, keyW, keyH, whiteNotes[i], \"white\"));\n        }\n        for (let i = 0; i < blackNotes.length; i++) {\n          if (blackNotes[i]) {\n            let bx = startX + i * keyW + (keyW * 0.65);\n            keys.push(new Key(p, bx, startY, keyW * 0.7, keyH * 0.6, blackNotes[i], \"black\"));\n          }\n        }\n      };\n\n      p.draw = function() {\n        p.background(0); \n\n        // --- èƒŒæ™¯ï¼šæ•°æ®ç½‘æ ¼ ---\n        p.stroke(20);\n        p.strokeWeight(1);\n        // ç»˜åˆ¶ç²¾ç»†çš„èƒŒæ™¯ç½‘æ ¼\n        for (let x = 0; x < p.width; x += 20) p.line(x, 0, x, p.height);\n        \n        // --- æ¸²æŸ“å±‚ ---\n        // 1. å…‰æŸ± (æœ€åº•å±‚)\n        for (let k of keys) k.displayBeam(); \n        // 2. æŒ‰é”®çº¿æ¡†\n        for (let k of keys) { if (k.type === \"white\") k.displayKey(); }\n        for (let k of keys) { if (k.type === \"black\") k.displayKey(); }\n\n        // --- é¼ æ ‡ï¼šåå­—æ ‡å°º ---\n        p.stroke(255);\n        p.line(0, p.mouseY, p.width, p.mouseY); // æ¨ªè´¯å…¨å±çš„æ‰«æçº¿\n        p.line(p.mouseX, 0, p.mouseX, p.height); // çºµè´¯å…¨å±çš„æ‰«æçº¿\n        \n        // é¼ æ ‡æ—è¾¹çš„å®æ—¶æ•°æ®\n        p.noStroke();\n        p.fill(255);\n        p.textSize(10);\n        p.text(`FREQ: ${p.floor(p.map(p.mouseX, 0, p.width, 2000, 10000))}HZ`, p.mouseX + 5, p.mouseY - 15);\n        p.text(`DATA: ${p.nf(p.random(1), 1, 4)}`, p.mouseX + 5, p.mouseY - 5);\n      };\n\n      p.mousePressed = async function() {\n        if (!isAudioStarted) {\n          await Tone.start();\n          Tone.Transport.start();\n          loop.start(0);\n          isAudioStarted = true;\n          document.getElementById('overlay').style.display = 'none';\n        }\n        \n        for (let i = keys.length - 1; i >= 0; i--) {\n          if (keys[i].contains(p.mouseX, p.mouseY)) {\n            keys[i].toggle();\n            break;\n          }\n        }\n      };\n\n      p.windowResized = function() {\n        p.resizeCanvas(p.windowWidth, p.windowHeight);\n        p.setup();\n      };\n\n      // --- ç±»ï¼šæ•°æ®ç»ˆç«¯é”® ---\n      class Key {\n        constructor(p, x, y, w, h, note, type) {\n          this.p = p;\n          this.x = x;\n          this.y = y;\n          this.w = w;\n          this.h = h;\n          this.note = note;\n          this.type = type;\n          this.active = false;\n          this.flashVal = 0;\n        }\n\n        toggle() {\n          this.active = !this.active;\n          if(this.active) this.flashVal = 1.0;\n        }\n\n        triggerFlash() {\n          this.flashVal = 1.0;\n        }\n\n        contains(mx, my) {\n          return mx > this.x && mx < this.x + this.w && my > this.y && my < this.y + this.h;\n        }\n\n        // ç»˜åˆ¶å…‰æŸ±ï¼šçº¯ç²¹çš„ç™½è‰²ä¿¡å·\n        displayBeam() {\n          if (this.active || this.flashVal > 0.01) {\n            let alpha = this.active ? 50 : this.flashVal * 150;\n            \n            this.p.noStroke();\n            this.p.fill(255, alpha);\n            // å…‰æŸ±ç›´å†²äº‘éœ„\n            this.p.rect(this.x, 0, this.w, this.y);\n            \n            // å¢åŠ  Ikeda é£æ ¼çš„â€œåç‚¹â€ (Dead Pixels)\n            if (this.active) {\n               this.p.fill(255);\n               let rY = this.p.random(0, this.y);\n               this.p.rect(this.x, rY, this.w, 2); // éšæœºé—ªçƒçš„æ¨ªçº¿\n            }\n          }\n        }\n\n        // ç»˜åˆ¶æŒ‰é”®ï¼šçº¿æ¡† + æ¡å½¢ç \n        displayKey() {\n          // è¾¹æ¡†\n          this.p.noFill();\n          this.p.stroke(this.active ? 255 : 60); // æœªæ¿€æ´»æ—¶éå¸¸æš—ï¼Œæ¿€æ´»æ—¶å…¨ç™½\n          this.p.strokeWeight(1);\n          this.p.rect(this.x, this.y, this.w, this.h);\n\n          // å†…éƒ¨æ•°æ®æµ (Barcode)\n          if (this.active) {\n            this.p.noStroke();\n            this.p.fill(255);\n            \n            // ç”Ÿæˆéšæœºæ¡å½¢ç \n            let bars = 10;\n            for(let i=0; i<bars; i++) {\n              if (this.p.random(1) > 0.5) {\n                let by = this.p.map(i, 0, bars, this.y + 10, this.y + this.h - 10);\n                let bh = (this.h - 20) / bars;\n                this.p.rect(this.x + 5, by, this.w - 10, bh * 0.6);\n              }\n            }\n            \n            // åº•éƒ¨æ˜¾ç¤ºéŸ³ç¬¦é¢‘ç‡ä»£ç \n            this.p.textSize(8);\n            this.p.textAlign(this.p.CENTER);\n            this.p.text(this.note + \"_DAT\", this.x + this.w/2, this.y + this.h + 15);\n          }\n          \n          if (this.flashVal > 0) this.flashVal -= 0.2; // æå¿«è¡°å‡ï¼Œåƒé¢‘é—ªç¯\n        }\n      }\n    };\n\n    new p5(s);\n  </script>\n</body>\n</html>"
    },
    {
        "åºå·": 4,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Interactive Piano</title>\n  <style>\n    /* é¡µé¢æ ·å¼ï¼šç¦æ­¢æ»šåŠ¨ï¼Œçº¯é»‘èƒŒæ™¯ */\n    body { margin: 0; overflow: hidden; background-color: #050505; }\n    canvas { display: block; cursor: crosshair; /* åå­—å‡†æ˜Ÿé¼ æ ‡ï¼Œå¢åŠ ç§‘æŠ€æ„Ÿ */ }\n    \n    /* UI æç¤ºå±‚ */\n    #ui-layer {\n      position: absolute;\n      top: 50%; left: 50%;\n      transform: translate(-50%, -50%);\n      text-align: center;\n      pointer-events: none; /* è®©é¼ æ ‡ç‚¹å‡»èƒ½ç©¿é€æ–‡å­—ä¼ ç»™ 3D åœºæ™¯ */\n      z-index: 10;\n    }\n    \n    .loading-text {\n      color: #00ff00;\n      font-family: 'Courier New', Courier, monospace;\n      font-size: 14px;\n      letter-spacing: 2px;\n      text-shadow: 0 0 5px #00ff00;\n    }\n\n    .hint-text {\n      display: none; /* åŠ è½½å®Œå†æ˜¾ç¤º */\n      color: rgba(255, 255, 255, 0.7);\n      font-family: 'Helvetica', sans-serif;\n      font-size: 10px;\n      letter-spacing: 4px;\n      margin-top: 20px;\n      text-transform: uppercase;\n    }\n  </style>\n  \n  <script type=\"importmap\">\n    {\n      \"imports\": {\n        \"three\": \"https://unpkg.com/three@0.160.0/build/three.module.js\",\n        \"three/addons/\": \"https://unpkg.com/three@0.160.0/examples/jsm/\"\n      }\n    }\n  </script>\n</head>\n<body>\n  <div id=\"ui-layer\">\n    <div id=\"loading\" class=\"loading-text\">LOADING DATA...</div>\n    <div id=\"hint\" class=\"hint-text\">[ CLICK TO TOGGLE WIREFRAME MODE ]</div>\n  </div>\n  \n  <script type=\"module\">\n    import * as THREE from 'three';\n    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\n    import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';\n    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n    // ä»“åº“é…ç½®\n    const baseUrl = 'https://raw.githubusercontent.com/Asbeel24/WebModel/main/';\n    const mtlFile = 'piano.mtl';\n    const objFile = 'piano.obj';\n\n    let pianoGroup; // å­˜å‚¨é’¢ç´å¯¹è±¡ï¼Œç”¨äºäº¤äº’\n    let isWireframe = false; // çŠ¶æ€æ ‡è®°\n\n    // 1. åœºæ™¯åˆå§‹åŒ–\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x050505);\n\n    // 2. ç›¸æœº (ä½ç½®æ‹‰è¿œä¸€ç‚¹ï¼Œå› ä¸ºæ¨¡å‹å˜å¤§äº†)\n    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 3000);\n    camera.position.set(0, 200, 500);\n\n    // 3. æ¸²æŸ“å™¨\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\n    document.body.appendChild(renderer.domElement);\n\n    // 4. ç¯å…‰ç³»ç»Ÿ\n    const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);\n    scene.add(ambientLight);\n    const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);\n    dirLight.position.set(100, 200, 100);\n    scene.add(dirLight);\n    const backLight = new THREE.DirectionalLight(0x44aaff, 1.5); // è“è‰²è½®å»“å…‰\n    backLight.position.set(-100, 50, -200);\n    scene.add(backLight);\n\n    // 5. æ§åˆ¶å™¨ (å…è®¸ 360 åº¦æ—‹è½¬)\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true; // æœ‰é˜»å°¼æ„Ÿï¼Œæ›´é«˜çº§\n    controls.dampingFactor = 0.05;\n    controls.autoRotate = true; // å¼€å¯è‡ªåŠ¨æ—‹è½¬\n    controls.autoRotateSpeed = 0.5; // è½¬æ…¢ç‚¹\n\n    // --- 6. æ ¸å¿ƒåŠ è½½é€»è¾‘ ---\n    const mtlLoader = new MTLLoader();\n    mtlLoader.setPath(baseUrl);\n    mtlLoader.setResourcePath(baseUrl); // ç¡®ä¿èƒ½æ‰¾åˆ°è´´å›¾\n\n    mtlLoader.load(mtlFile, (materials) => {\n      materials.preload();\n\n      const objLoader = new OBJLoader();\n      objLoader.setMaterials(materials);\n      objLoader.setPath(baseUrl);\n      \n      objLoader.load(objFile, (object) => {\n        \n        pianoGroup = object; // ä¿å­˜åˆ°å…¨å±€å˜é‡\n\n        // ğŸ“ å°ºå¯¸è°ƒæ•´\n        const box = new THREE.Box3().setFromObject(object);\n        const center = box.getCenter(new THREE.Vector3());\n        const size = box.getSize(new THREE.Vector3());\n        \n        // å±…ä¸­\n        object.position.x += (object.position.x - center.x);\n        object.position.y += (object.position.y - center.y);\n        object.position.z += (object.position.z - center.z);\n        \n        // æ”¾å¤§ (Target Size = 500)\n        const maxDim = Math.max(size.x, size.y, size.z);\n        const scale = 500 / maxDim; \n        object.scale.set(scale, scale, scale);\n        object.position.y -= 50; // ç¨å¾®ä¸‹æ²‰ä¸€ç‚¹\n\n        // ğŸ’¾ é¢„å¤„ç†ï¼šä¿å­˜åŸå§‹æè´¨\n        // æˆ‘ä»¬éœ€è¦æŠŠåŠ è½½è¿›æ¥çš„æè´¨å­˜èµ·æ¥ï¼Œä»¥ä¾¿åˆ‡æ¢å›çº¿æ¡†åè¿˜èƒ½æ¢å¤\n        object.traverse((child) => {\n          if (child.isMesh) {\n            child.userData.originalMaterial = child.material; // å­˜å…¥ userData\n          }\n        });\n\n        scene.add(object);\n        \n        // UI æ›´æ–°\n        document.getElementById('loading').style.display = 'none';\n        document.getElementById('hint').style.display = 'block';\n\n      }, undefined, (err) => {\n        console.error(err);\n        document.getElementById('loading').innerText = \"ERROR LOADING\";\n        document.getElementById('loading').style.color = \"red\";\n      });\n    });\n\n    // --- 7. äº¤äº’é€»è¾‘ï¼šç‚¹å‡»åˆ‡æ¢æ¨¡å¼ ---\n    window.addEventListener('mousedown', onDocumentMouseDown, false);\n\n    function onDocumentMouseDown() {\n      if (!pianoGroup) return; // å¦‚æœæ¨¡å‹è¿˜æ²¡åŠ è½½å®Œï¼Œä¸æ‰§è¡Œ\n\n      isWireframe = !isWireframe; // åˆ‡æ¢çŠ¶æ€\n\n      pianoGroup.traverse((child) => {\n        if (child.isMesh) {\n          if (isWireframe) {\n            // ğŸ”² åˆ‡æ¢åˆ°çº¿æ¡†æ¨¡å¼\n            // ä½¿ç”¨ BasicMaterial æ€§èƒ½æœ€å¥½ï¼Œç™½è‰²çº¿æ¡\n            child.material = new THREE.MeshBasicMaterial({ \n              color: 0xffffff, \n              wireframe: true,\n              transparent: true,\n              opacity: 0.3 // çº¿æ¡ç¨å¾®é€æ˜ä¸€ç‚¹ï¼Œæ›´æœ‰é‡å çš„å¤æ‚æ„Ÿ\n            });\n          } else {\n            // ğŸ¹ æ¢å¤å®ä½“æ¨¡å¼\n            // ä» userData é‡Œè¯»å–ä¹‹å‰ä¿å­˜çš„æè´¨\n            if (child.userData.originalMaterial) {\n              child.material = child.userData.originalMaterial;\n            }\n          }\n        }\n      });\n    }\n\n    // 8. åŠ¨ç”»å¾ªç¯\n    function animate() {\n      requestAnimationFrame(animate);\n      controls.update();\n      renderer.render(scene, camera);\n    }\n    animate();\n\n    // 9. çª—å£è‡ªé€‚åº”\n    window.addEventListener('resize', () => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    });\n  </script>\n</body>\n</html>"
    },
    {
        "åºå·": 5,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>3D Boids Canvas Text - Rotating Camera</title>\n    <style>\n        body { margin: 0; overflow: hidden; background-color: #111; font-family: \"Microsoft YaHei\", sans-serif; }\n        canvas { display: block; width: 100vw; height: 100vh; }\n        \n        #ui-container {\n            position: absolute;\n            bottom: 30px;\n            left: 50%;\n            transform: translateX(-50%);\n            display: flex;\n            gap: 10px;\n            z-index: 10;\n            width: 90%;\n            max-width: 500px;\n        }\n        \n        input {\n            flex-grow: 1;\n            padding: 12px 20px;\n            border-radius: 30px;\n            border: none;\n            background: rgba(255, 255, 255, 0.9);\n            font-size: 16px;\n            outline: none;\n            box-shadow: 0 4px 15px rgba(0,0,0,0.3);\n        }\n        \n        button {\n            padding: 12px 24px;\n            border-radius: 30px;\n            border: none;\n            background: #0984e3;\n            color: white;\n            font-weight: bold;\n            cursor: pointer;\n            transition: transform 0.2s;\n            box-shadow: 0 4px 15px rgba(9, 132, 227, 0.4);\n        }\n        \n        button:hover { transform: scale(1.05); background: #74b9ff; }\n    </style>\n</head>\n<body>\n\n    <div id=\"ui-container\">\n        <input type=\"text\" id=\"textInput\" placeholder=\"è¾“å…¥æ–‡å­—...\" maxlength=\"8\">\n        <button id=\"sendBtn\">å‘é€</button>\n    </div>\n\n    <script type=\"module\">\n        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';\n\n        // --- 1. åˆå§‹åŒ–åœºæ™¯ ---\n        const scene = new THREE.Scene();\n        scene.background = new THREE.Color(0x111111);\n        scene.fog = new THREE.FogExp2(0x111111, 0.002);\n\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        \n        // åˆå§‹ç›¸æœºä½ç½®ï¼ˆç¨åä¼šåœ¨åŠ¨ç”»å¾ªç¯ä¸­è¦†ç›–ï¼‰\n        camera.position.set(0, 0, 90);\n\n        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.body.appendChild(renderer.domElement);\n\n        // --- 2. æ ¸å¿ƒå·¥å…·ï¼šå°†æ–‡å­—è½¬ä¸ºçº¹ç† ---\n        function createTextTexture(text, colorStr) {\n            const canvas = document.createElement('canvas');\n            const ctx = canvas.getContext('2d');\n            canvas.width = 512;\n            canvas.height = 256;\n\n            ctx.fillStyle = 'rgba(0,0,0,0)';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            ctx.font = \"bold 120px 'Microsoft YaHei', Arial, sans-serif\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillStyle = colorStr;\n            ctx.fillText(text, canvas.width / 2, canvas.height / 2);\n\n            const texture = new THREE.CanvasTexture(canvas);\n            texture.needsUpdate = true;\n            return { texture, aspect: canvas.width / canvas.height };\n        }\n\n        // --- 3. Boid ç±» (è¿åŠ¨ç®—æ³•) ---\n        class Boid {\n            constructor(mesh) {\n                this.mesh = mesh;\n                // åˆå§‹ä½ç½®åˆ†æ•£å¾—æ›´å¼€ä¸€äº›\n                this.position = new THREE.Vector3((Math.random()-0.5)*100, (Math.random()-0.5)*60, (Math.random()-0.5)*60);\n                this.velocity = new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5);\n                this.acceleration = new THREE.Vector3();\n                this.maxForce = 0.1; // å¢åŠ è½¬å‘åŠ›ï¼Œè®©å®ƒä»¬ååº”æ›´çµæ•\n                this.maxSpeed = 0.7;\n                \n                this.rotSpeed = { \n                    x: (Math.random()-0.5)*0.015, \n                    y: (Math.random()-0.5)*0.015 \n                };\n            }\n\n            flock(boids) {\n                let sep = this.separate(boids);\n                let ali = this.align(boids);\n                let coh = this.cohesion(boids);\n                \n                // --- å…³é”®ä¿®æ”¹ï¼šè°ƒæ•´æƒé‡ ---\n                sep.multiplyScalar(5.0); // åˆ†ç¦»æƒé‡æå¤§ï¼Œå¼ºè¿«å®ƒä»¬åˆ†å¼€\n                ali.multiplyScalar(1.0); // å¯¹é½æƒé‡æ­£å¸¸\n                coh.multiplyScalar(0.5); // å‡èšæƒé‡é™ä½ï¼Œå‡å°‘å®ƒä»¬æŠ±å›¢çš„æ¬²æœ›\n                \n                this.applyForce(sep);\n                this.applyForce(ali);\n                this.applyForce(coh);\n            }\n\n            applyForce(force) { this.acceleration.add(force); }\n\n            update() {\n                this.velocity.add(this.acceleration);\n                this.velocity.clampLength(0, this.maxSpeed);\n                this.position.add(this.velocity);\n                this.acceleration.multiplyScalar(0);\n                \n                this.mesh.position.copy(this.position);\n                \n                // ç®€å•çš„è‡ªè½¬\n                this.mesh.rotation.x += this.rotSpeed.x;\n                this.mesh.rotation.y += this.rotSpeed.y;\n                \n                // è®©æ–‡å­—ç¨å¾®é¢å‘ä¸­å¿ƒï¼Œé˜²æ­¢åœ¨æ—‹è½¬ç›¸æœºæ—¶å®Œå…¨çœ‹ä¸æ¸…\n                // è¿™é‡Œåšä¸€ä¸ªç¨å¾®å¤æ‚çš„æ··åˆæ—‹è½¬ï¼Œæ—¢æœ‰è‡ªè½¬ï¼Œåˆå¤§è‡´é¢å‘åŸç‚¹\n                // (ä¸ºäº†ä¿æŒé£˜æµ®æ„Ÿï¼Œæˆ‘ä»¬åªåšè½»å¾®çš„LookAtä¿®æ­£ï¼Œæˆ–è€…ä¸åš)\n                \n                this.edges();\n            }\n\n            edges() {\n                // æ‰©å¤§æ´»åŠ¨èŒƒå›´ï¼Œç»™å®ƒä»¬æ›´å¤šç©ºé—´åˆ†æ•£\n                const r = 90; \n                if (this.position.x > r) this.position.x = -r;\n                if (this.position.x < -r) this.position.x = r;\n                if (this.position.y > r/1.5) this.position.y = -r/1.5;\n                if (this.position.y < -r/1.5) this.position.y = r/1.5;\n                if (this.position.z > r) this.position.z = -r;\n                if (this.position.z < -r) this.position.z = r;\n            }\n\n            // --- å…³é”®ä¿®æ”¹ï¼šåˆ†ç¦»é€»è¾‘ ---\n            separate(boids) {\n                let desiredSeparation = 25.0; // å¢åŠ â€œå®‰å…¨è·ç¦»â€ï¼Œå°äºè¿™ä¸ªè·ç¦»å°±ä¼šäº§ç”Ÿæ’æ–¥\n                let steer = new THREE.Vector3();\n                let count = 0;\n                for (let other of boids) {\n                    let d = this.position.distanceTo(other.position);\n                    if ((d > 0) && (d < desiredSeparation)) {\n                        let diff = new THREE.Vector3().subVectors(this.position, other.position);\n                        diff.normalize();\n                        diff.divideScalar(d); // è·ç¦»è¶Šè¿‘ï¼Œæ’æ–¥åŠ›è¶Šå¤§\n                        steer.add(diff);\n                        count++;\n                    }\n                }\n                if (count > 0) {\n                    steer.divideScalar(count);\n                    steer.setLength(this.maxSpeed);\n                    steer.sub(this.velocity);\n                    steer.clampLength(0, this.maxForce);\n                }\n                return steer;\n            }\n\n            align(boids) {\n                let neighborDist = 30;\n                let sum = new THREE.Vector3();\n                let count = 0;\n                for (let other of boids) {\n                    let d = this.position.distanceTo(other.position);\n                    if ((d > 0) && (d < neighborDist)) {\n                        sum.add(other.velocity);\n                        count++;\n                    }\n                }\n                if (count > 0) {\n                    sum.divideScalar(count);\n                    sum.setLength(this.maxSpeed);\n                    let steer = new THREE.Vector3().subVectors(sum, this.velocity);\n                    steer.clampLength(0, this.maxForce);\n                    return steer;\n                }\n                return new THREE.Vector3();\n            }\n\n            cohesion(boids) {\n                let neighborDist = 30;\n                let sum = new THREE.Vector3();\n                let count = 0;\n                for (let other of boids) {\n                    let d = this.position.distanceTo(other.position);\n                    if ((d > 0) && (d < neighborDist)) {\n                        sum.add(other.position);\n                        count++;\n                    }\n                }\n                if (count > 0) {\n                    sum.divideScalar(count);\n                    return this.seek(sum);\n                }\n                return new THREE.Vector3();\n            }\n\n            seek(target) {\n                let desired = new THREE.Vector3().subVectors(target, this.position);\n                desired.setLength(this.maxSpeed);\n                let steer = new THREE.Vector3().subVectors(desired, this.velocity);\n                steer.clampLength(0, this.maxForce);\n                return steer;\n            }\n        }\n\n        // --- 4. é€»è¾‘æ§åˆ¶ ---\n        const boids = [];\n        \n        function getRandomColor() {\n            const hue = Math.floor(Math.random() * 360);\n            return `hsl(${hue}, 100%, 70%)`;\n        }\n\n        function createTextBoid(text) {\n            const colorStr = getRandomColor();\n            const { texture, aspect } = createTextTexture(text, colorStr);\n\n            const geometry = new THREE.PlaneGeometry(8 * aspect, 8);\n            const material = new THREE.MeshBasicMaterial({ \n                map: texture, \n                transparent: true, \n                opacity: 0.9,\n                side: THREE.DoubleSide, // å…³é”®ï¼šåŒé¢æ¸²æŸ“ï¼Œé˜²æ­¢ç›¸æœºè½¬åˆ°èƒŒé¢æ—¶çœ‹ä¸è§\n                depthWrite: false \n            });\n\n            const mesh = new THREE.Mesh(geometry, material);\n            scene.add(mesh);\n            \n            const boid = new Boid(mesh);\n            boids.push(boid);\n\n            if (boids.length > 40) {\n                const oldBoid = boids.shift();\n                scene.remove(oldBoid.mesh);\n                oldBoid.mesh.geometry.dispose();\n                oldBoid.mesh.material.dispose();\n                oldBoid.mesh.material.map.dispose();\n            }\n        }\n\n        setTimeout(() => {\n            createTextBoid(\"ä½ å¥½\");\n            createTextBoid(\"Wix\");\n            createTextBoid(\"äº’åŠ¨\");\n        }, 500);\n\n        const input = document.getElementById('textInput');\n        const btn = document.getElementById('sendBtn');\n\n        function handleSend() {\n            const text = input.value.trim();\n            if (text) {\n                const cleanText = text.substring(0, 8);\n                createTextBoid(cleanText);\n                input.value = '';\n            }\n        }\n\n        btn.addEventListener('click', handleSend);\n        input.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleSend(); });\n\n        // --- 5. åŠ¨ç”»å¾ªç¯ (åŒ…å«ç›¸æœºæ—‹è½¬) ---\n        let cameraAngle = 0;\n        const cameraRadius = 100; // ç›¸æœºè·ç¦»ä¸­å¿ƒçš„è·ç¦»\n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            // 1. æ›´æ–°æ‰€æœ‰æ–‡å­—ä½ç½®\n            for (let boid of boids) {\n                boid.flock(boids);\n                boid.update();\n            }\n\n            // 2. ç›¸æœºè‡ªåŠ¨æ—‹è½¬é€»è¾‘\n            cameraAngle += 0.0015; // æ—‹è½¬é€Ÿåº¦ï¼Œæ•°å€¼è¶Šå°è¶Šæ…¢\n            camera.position.x = Math.sin(cameraAngle) * cameraRadius;\n            camera.position.z = Math.cos(cameraAngle) * cameraRadius;\n            camera.lookAt(0, 0, 0); // å§‹ç»ˆç›¯ç€åœºæ™¯ä¸­å¿ƒ\n\n            renderer.render(scene, camera);\n        }\n\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n\n        animate();\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 6,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <style>\n        /* 1. æ²‰æµ¸å¼å¸ƒå±€è®¾ç½® */\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden; /* é˜²æ­¢æ»šåŠ¨æ¡å‡ºç° */\n            background-color: #050505; /* æ·±é‚ƒé»‘èƒŒæ™¯ */\n        }\n\n        canvas {\n            display: block;\n        }\n\n        /* 2. è¦†ç›–å±‚çš„æ–‡å­—æ ·å¼ (å¯é€‰) */\n        .overlay {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            color: rgba(255, 255, 255, 0.1);\n            font-family: 'Courier New', Courier, monospace;\n            font-size: 2rem;\n            font-weight: bold;\n            pointer-events: none; /* è®©é¼ æ ‡ç©¿é€æ–‡å­—æ“ä½œç²’å­ */\n            text-transform: uppercase;\n            letter-spacing: 5px;\n            text-align: center;\n            mix-blend-mode: overlay;\n        }\n    </style>\n</head>\n<body>\n\n    <!-- è§†è§‰ä¸­å¿ƒ -->\n    <div class=\"overlay\">System Active<br><span style=\"font-size:1rem\">Interactive Core</span></div>\n    <canvas id=\"canvas1\"></canvas>\n\n    <script>\n        /**\n         * æ ¸å¿ƒé€»è¾‘ï¼šåŸç”Ÿ Canvas ç²’å­ç‰©ç†ç³»ç»Ÿ\n         * æ— ä¾èµ–ï¼Œçº¯æ•°å­¦è®¡ç®—\n         */\n        const canvas = document.getElementById('canvas1');\n        const ctx = canvas.getContext('2d');\n        \n        let particlesArray;\n        \n        // é¼ æ ‡çŠ¶æ€å¯¹è±¡\n        let mouse = {\n            x: null,\n            y: null,\n            radius: 150 // é¼ æ ‡æ–¥åŠ›èŒƒå›´\n        }\n\n        // è‡ªåŠ¨è°ƒæ•´ç”»å¸ƒå¤§å°ä»¥é€‚åº” Wix å®¹å™¨\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n\n        // ç›‘å¬é¼ æ ‡ç§»åŠ¨\n        window.addEventListener('mousemove', function(event) {\n            mouse.x = event.x;\n            mouse.y = event.y;\n        });\n\n        // ç›‘å¬çª—å£å¤§å°æ”¹å˜ (Wix ç§»åŠ¨ç«¯é€‚é…å…³é”®)\n        window.addEventListener('resize', function() {\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            mouse.radius = ((canvas.height/80) * (canvas.height/80));\n            init();\n        });\n\n        // é¼ æ ‡ç§»å‡ºæ—¶æ¸…ç©ºåæ ‡ï¼Œé˜²æ­¢ç²’å­å¡ä½\n        window.addEventListener('mouseout', function() {\n            mouse.x = undefined;\n            mouse.y = undefined;\n        });\n\n        // --- ç²’å­ç±»å®šä¹‰ ---\n        class Particle {\n            constructor(x, y, directionX, directionY, size, color) {\n                this.x = x;\n                this.y = y;\n                this.directionX = directionX;\n                this.directionY = directionY;\n                this.size = size;\n                this.color = color;\n                this.baseX = x; // è®°å½•åˆå§‹ä½ç½®ï¼ˆå¦‚æœæƒ³åšå›å¼¹æ•ˆæœå¯ç”¨ï¼‰\n                this.baseY = y;\n            }\n\n            // ç»˜åˆ¶å•é¢—ç²’å­\n            draw() {\n                ctx.beginPath();\n                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);\n                ctx.fillStyle = '#ffffff'; // æ ¸å¿ƒç‚¹æ€»æ˜¯ç™½è‰²\n                ctx.fill();\n            }\n\n            // ç‰©ç†è®¡ç®—ä¸æ›´æ–°\n            update() {\n                // 1. è¾¹ç•Œæ£€æµ‹ï¼šç¢°åˆ°è¾¹ç¼˜åå¼¹\n                if (this.x > canvas.width || this.x < 0) {\n                    this.directionX = -this.directionX;\n                }\n                if (this.y > canvas.height || this.y < 0) {\n                    this.directionY = -this.directionY;\n                }\n\n                // 2. é¼ æ ‡äº¤äº’ (æ–¥åŠ›åœº)\n                let dx = mouse.x - this.x;\n                let dy = mouse.y - this.y;\n                let distance = Math.sqrt(dx*dx + dy*dy);\n\n                if (distance < mouse.radius + this.size) {\n                    if (mouse.x < this.x && this.x < canvas.width - this.size * 10) {\n                        this.x += 10;\n                    }\n                    if (mouse.x > this.x && this.x > this.size * 10) {\n                        this.x -= 10;\n                    }\n                    if (mouse.y < this.y && this.y < canvas.height - this.size * 10) {\n                        this.y += 10;\n                    }\n                    if (mouse.y > this.y && this.y > this.size * 10) {\n                        this.y -= 10;\n                    }\n                }\n\n                // 3. ç§»åŠ¨ç²’å­\n                this.x += this.directionX;\n                this.y += this.directionY;\n\n                this.draw();\n            }\n        }\n\n        // --- åˆå§‹åŒ–ç³»ç»Ÿ ---\n        function init() {\n            particlesArray = [];\n            // æ ¹æ®å±å¹•é¢ç§¯è®¡ç®—ç²’å­æ•°é‡ï¼Œé˜²æ­¢ä½ç«¯è®¾å¤‡å¡é¡¿\n            let numberOfParticles = (canvas.height * canvas.width) / 9000;\n            \n            for (let i = 0; i < numberOfParticles; i++) {\n                let size = (Math.random() * 3) + 1;\n                let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);\n                let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);\n                let directionX = (Math.random() * 2) - 1; // é€Ÿåº¦ -1 åˆ° 1\n                let directionY = (Math.random() * 2) - 1;\n                let color = '#ffffff';\n\n                particlesArray.push(new Particle(x, y, directionX, directionY, size, color));\n            }\n        }\n\n        // --- è¿çº¿æ•ˆæœ (ç¥ç»ç½‘ç»œæ ¸å¿ƒ) ---\n        function connect() {\n            let opacityValue = 1;\n            for (let a = 0; a < particlesArray.length; a++) {\n                for (let b = a; b < particlesArray.length; b++) {\n                    let distance = ((particlesArray[a].x - particlesArray[b].x) * (particlesArray[a].x - particlesArray[b].x))\n                    + ((particlesArray[a].y - particlesArray[b].y) * (particlesArray[a].y - particlesArray[b].y));\n                    \n                    // å¦‚æœä¸¤ä¸ªç²’å­è·ç¦»è¶³å¤Ÿè¿‘ï¼Œç”»çº¿\n                    if (distance < (canvas.width/7) * (canvas.height/7)) {\n                        opacityValue = 1 - (distance/20000);\n                        \n                        // åŠ¨æ€é¢œè‰²ï¼šæ ¹æ®ä½ç½®å’Œé€æ˜åº¦ç”Ÿæˆèµ›åšæœ‹å…‹é£æ ¼çº¿æ¡\n                        ctx.strokeStyle = 'rgba(0, 255, 255,' + opacityValue + ')'; // é’è‰²\n                        // å¶å°”æ··å…¥ä¸€ç‚¹æ´‹çº¢è‰²\n                        if(a % 10 === 0) ctx.strokeStyle = 'rgba(255, 0, 255,' + opacityValue + ')'; \n                        \n                        ctx.lineWidth = 1;\n                        ctx.beginPath();\n                        ctx.moveTo(particlesArray[a].x, particlesArray[a].y);\n                        ctx.lineTo(particlesArray[b].x, particlesArray[b].y);\n                        ctx.stroke();\n                    }\n                }\n            }\n        }\n\n        // --- åŠ¨ç”»å¾ªç¯ ---\n        function animate() {\n            requestAnimationFrame(animate);\n            // æ¯ä¸€å¸§ç¨å¾®ä¿ç•™ä¸€ç‚¹ä¸Šä¸€å¸§çš„æ®‹å½±ï¼Œåˆ¶é€ æ‹–å°¾æ•ˆæœ (å¯é€‰ï¼Œè¿™é‡Œç”¨å…¨æ¸…ç©ºä¿æŒæ¸…æ™°)\n            ctx.clearRect(0, 0, innerWidth, innerHeight); \n            \n            for (let i = 0; i < particlesArray.length; i++) {\n                particlesArray[i].update();\n            }\n            connect();\n        }\n\n        // å¯åŠ¨\n        init();\n        animate();\n\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 7,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            background-color: #000000;\n            overflow: hidden;\n            font-family: 'Courier New', Courier, monospace; /* æ›´åƒä»£ç é£æ ¼ */\n        }\n\n        /* ä¿®å¤ 1: Canvas è®¾ä¸ºç»å¯¹å®šä½å¹¶ç½®äºåº•å±‚ */\n        canvas {\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            z-index: 1; /* åº•å±‚ */\n        }\n\n        /* ä¿®å¤ 2: é¢æ¿è®¾ä¸ºæœ€é«˜å±‚çº§ï¼Œå¹¶å¢åŠ èƒŒæ™¯ä¸é€æ˜åº¦ */\n        .hud-panel {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            width: 200px;\n            background: rgba(0, 0, 0, 0.85); /* æ›´é»‘çš„èƒŒæ™¯ï¼Œä¿è¯æ–‡å­—å¯è§ */\n            border: 1px solid #00ffcc; /* é’è‰²è¾¹æ¡† */\n            padding: 15px;\n            border-radius: 4px;\n            z-index: 999; /* å¼ºåˆ¶é¡¶å±‚ï¼Œç¡®ä¿ä¸è¢«é®æŒ¡ */\n            box-shadow: 0 0 15px rgba(0, 255, 204, 0.2);\n        }\n\n        .hud-title {\n            color: #fff;\n            font-weight: bold;\n            font-size: 14px;\n            margin-bottom: 12px;\n            border-bottom: 1px solid #333;\n            padding-bottom: 8px;\n            text-align: center;\n        }\n\n        .btn-group {\n            display: flex;\n            flex-direction: column;\n            gap: 8px;\n        }\n\n        button {\n            background: transparent;\n            border: 1px solid #00ffcc;\n            color: #00ffcc;\n            padding: 8px;\n            cursor: pointer;\n            font-size: 12px;\n            transition: all 0.2s;\n            text-align: left;\n        }\n\n        button:hover {\n            background: #00ffcc;\n            color: #000;\n        }\n\n        button.active {\n            background: #00ffcc;\n            color: #000;\n            font-weight: bold;\n        }\n\n        .hint {\n            margin-top: 10px;\n            font-size: 10px;\n            color: #888;\n            text-align: center;\n        }\n    </style>\n</head>\n<body>\n\n    <!-- æ§åˆ¶é¢æ¿ (HUD) -->\n    <div class=\"hud-panel\">\n        <div class=\"hud-title\">QUANTUM ENGINE</div>\n        <div class=\"btn-group\">\n            <button onclick=\"setMode('nebula')\" id=\"btn-nebula\" class=\"active\">1. Nebula (æ˜Ÿäº‘)</button>\n            <button onclick=\"setMode('vortex')\" id=\"btn-vortex\">2. Vortex (é»‘æ´)</button>\n            <button onclick=\"setMode('grid')\" id=\"btn-grid\">3. Grid (çŸ©é˜µ)</button>\n            <button onclick=\"setMode('explosion')\" id=\"btn-explosion\">4. Explosion (çˆ†å‘)</button>\n        </div>\n        <div class=\"hint\">ç‚¹å‡»å±å¹•ä»»æ„å¤„ä¹Ÿå¯åˆ‡æ¢</div>\n    </div>\n\n    <canvas id=\"canvas\"></canvas>\n\n    <script>\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        \n        let width, height;\n        let particles = [];\n        // ç¨å¾®å‡å°‘ç²’å­æ•°ä»¥ä¿è¯åœ¨Wix iframeä¸­æ›´ç¨³å®š\n        let particleCount = window.innerWidth > 800 ? 2500 : 1000; \n        \n        let mode = 'nebula'; \n        let modesList = ['nebula', 'vortex', 'grid', 'explosion'];\n        let mouse = { x: -1000, y: -1000, active: false }; // åˆå§‹ç§»å‡ºå±å¹•\n        let hue = 0;\n\n        function resize() {\n            width = canvas.width = window.innerWidth;\n            height = canvas.height = window.innerHeight;\n        }\n        window.addEventListener('resize', resize);\n        resize();\n\n        // é¼ æ ‡/è§¦æ‘¸äº¤äº’\n        canvas.addEventListener('mousemove', e => {\n            mouse.x = e.clientX;\n            mouse.y = e.clientY;\n            mouse.active = true;\n        });\n        \n        // ä¿®å¤ 3: ç‚¹å‡»ç”»å¸ƒä»»æ„ä½ç½®å¾ªç¯åˆ‡æ¢æ¨¡å¼ (å¤‡ç”¨æ–¹æ¡ˆ)\n        canvas.addEventListener('click', () => {\n            let currentIndex = modesList.indexOf(mode);\n            let nextIndex = (currentIndex + 1) % modesList.length;\n            setMode(modesList[nextIndex]);\n        });\n\n        class Particle {\n            constructor() {\n                this.reset();\n                this.x = Math.random() * width;\n                this.y = Math.random() * height;\n            }\n\n            reset() {\n                this.x = width / 2;\n                this.y = height / 2;\n                this.vx = (Math.random() - 0.5) * 2;\n                this.vy = (Math.random() - 0.5) * 2;\n                this.size = Math.random() * 2 + 0.5;\n                this.gridX = Math.floor(Math.random() * (width / 25)) * 25;\n                this.gridY = Math.floor(Math.random() * (height / 25)) * 25;\n            }\n\n            update() {\n                this.vx *= 0.95;\n                this.vy *= 0.95;\n\n                if (mode === 'nebula') {\n                    this.vx += (Math.random() - 0.5) * 0.5;\n                    this.vy += (Math.random() - 0.5) * 0.5;\n                    if (mouse.active) {\n                        let dx = mouse.x - this.x;\n                        let dy = mouse.y - this.y;\n                        let dist = Math.sqrt(dx*dx + dy*dy);\n                        if (dist < 200) {\n                            let force = (200 - dist) / 200;\n                            this.vx -= (dx / dist) * force * 1.5;\n                            this.vy -= (dy / dist) * force * 1.5;\n                        }\n                    }\n                }\n                else if (mode === 'vortex') {\n                    let centerX = mouse.active ? mouse.x : width/2;\n                    let centerY = mouse.active ? mouse.y : height/2;\n                    let dx = centerX - this.x;\n                    let dy = centerY - this.y;\n                    let dist = Math.sqrt(dx*dx + dy*dy);\n                    let force = 500 / (dist*dist + 100); \n                    this.vx += dx * force;\n                    this.vy += dy * force;\n                    this.vx += -dy * 0.008; \n                    this.vy += dx * 0.008;\n                }\n                else if (mode === 'grid') {\n                    let dx = this.gridX - this.x;\n                    let dy = this.gridY - this.y;\n                    this.vx += dx * 0.08;\n                    this.vy += dy * 0.08;\n                    if (mouse.active) {\n                        let mdx = mouse.x - this.x;\n                        let mdy = mouse.y - this.y;\n                        let mdist = Math.sqrt(mdx*mdx + mdy*mdy);\n                        if (mdist < 100) {\n                            this.vx -= (mdx/mdist) * 3;\n                            this.vy -= (mdy/mdist) * 3;\n                        }\n                    }\n                }\n                else if (mode === 'explosion') {\n                    let centerX = width/2;\n                    let centerY = height/2;\n                    let dx = this.x - centerX;\n                    let dy = this.y - centerY;\n                    let dist = Math.sqrt(dx*dx + dy*dy);\n                    if (dist < 20) {\n                        this.vx = (Math.random() - 0.5) * 60;\n                        this.vy = (Math.random() - 0.5) * 60;\n                    } else {\n                         this.vx -= dx * 0.002;\n                         this.vy -= dy * 0.002;\n                    }\n                }\n\n                this.x += this.vx;\n                this.y += this.vy;\n\n                if (this.x < 0) this.x = width;\n                if (this.x > width) this.x = 0;\n                if (this.y < 0) this.y = height;\n                if (this.y > height) this.y = 0;\n            }\n\n            draw() {\n                let speed = Math.abs(this.vx) + Math.abs(this.vy);\n                let color;\n                if (mode === 'grid') color = `hsla(120, 100%, 50%, ${speed/5 + 0.4})`;\n                else if (mode === 'vortex') color = `hsla(${200 + speed * 10}, 80%, 60%, ${speed/10 + 0.3})`;\n                else if (mode === 'explosion') color = `hsla(${10 + speed * 20}, 100%, 60%, 0.8)`;\n                else color = `hsla(${hue + this.x/width * 60}, 70%, 60%, 0.6)`;\n\n                ctx.fillStyle = color;\n                ctx.beginPath();\n                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n                ctx.fill();\n            }\n        }\n\n        function init() {\n            particles = [];\n            for (let i = 0; i < particleCount; i++) {\n                particles.push(new Particle());\n            }\n        }\n\n        window.setMode = function(newMode) {\n            mode = newMode;\n            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));\n            let btn = document.getElementById('btn-' + newMode);\n            if(btn) btn.classList.add('active');\n            \n            if (newMode === 'explosion') {\n                particles.forEach(p => {\n                    p.x = width/2;\n                    p.y = height/2;\n                    p.vx = (Math.random() - 0.5) * 50;\n                    p.vy = (Math.random() - 0.5) * 50;\n                });\n            } else if (newMode === 'grid') {\n                particles.forEach(p => { p.vx = 0; p.vy = 0; });\n            }\n        }\n\n        function animate() {\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.25)'; \n            ctx.fillRect(0, 0, width, height);\n            ctx.globalCompositeOperation = 'lighter';\n            hue += 0.5;\n            particles.forEach(p => { p.update(); p.draw(); });\n            ctx.globalCompositeOperation = 'source-over';\n            requestAnimationFrame(animate);\n        }\n\n        init();\n        animate();\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 8,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n            background-color: #020202; /* æ›´æ·±é‚ƒçš„é»‘ */\n        }\n        canvas {\n            display: block;\n        }\n        .ui-layer {\n            position: absolute;\n            bottom: 30px;\n            left: 30px;\n            color: rgba(255, 255, 255, 0.2);\n            font-family: 'Helvetica Neue', Arial, sans-serif;\n            font-size: 12px;\n            pointer-events: none;\n            letter-spacing: 2px;\n            line-height: 1.5;\n            text-transform: uppercase;\n        }\n    </style>\n</head>\n<body>\n\n    <div class=\"ui-layer\">\n        Mode: MACRO_STRUCTURE<br>\n        Scale: 300%<br>\n        Gravity: ACTIVE\n    </div>\n    <canvas id=\"canvas\"></canvas>\n\n<script>\n/**\n * æ ¸å¿ƒç®—æ³•ï¼šå®è§‚è°æ³¢æ‹“æ‰‘ (Macro Harmonic Topology)\n * è°ƒæ•´ï¼šæ‰©å¤§äº†åˆ†å¸ƒç³»æ•°ï¼Œå¢åŠ äº†è¿çº¿é˜ˆå€¼ï¼Œæ·»åŠ äº†å…¨å±€æ—‹è½¬ã€‚\n */\n\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\n\nlet width, height;\nlet particles = [];\n// ç¨å¾®å¢åŠ ç²’å­æ•°é‡ä»¥å¡«å……å¤§ç©ºé—´ï¼Œä½†ä¿æŒæ€§èƒ½\nconst numParticles = 160; \nlet mouse = { x: -1000, y: -1000 };\n\nfunction resize() {\n    width = canvas.width = window.innerWidth;\n    height = canvas.height = window.innerHeight;\n}\nwindow.addEventListener('resize', resize);\nresize();\n\nwindow.addEventListener('mousemove', (e) => {\n    mouse.x = e.clientX;\n    mouse.y = e.clientY;\n});\n\nclass Particle {\n    constructor(index) {\n        this.index = index;\n        this.angle = index * 2.39996; \n        \n        // --- æ ¸å¿ƒä¿®æ”¹ 1: æå¤§çš„æ‰©æ•£åŠå¾„ ---\n        // ä¹‹å‰çš„ç³»æ•°æ˜¯ 5ï¼Œç°åœ¨æ˜¯ 18ï¼Œè¿™ä¼šè®©å›¾å½¢éå¸¸å·¨å¤§\n        this.radius = 20 + Math.sqrt(index) * 18; \n        \n        // è¿åŠ¨å‚æ•°\n        this.speed = 0.001 + Math.random() * 0.002; // é€Ÿåº¦ç¨å¾®å‡æ…¢ï¼Œä½“ç°å·¨ç‰©çš„åšé‡æ„Ÿ\n        this.oscillationSpeed = 0.005 + Math.random() * 0.01;\n        \n        // --- æ ¸å¿ƒä¿®æ”¹ 2: æ›´å¤§çš„å‘¼å¸å¹…åº¦ ---\n        this.oscillationAmp = 80 + Math.random() * 150; \n        \n        this.baseAlpha = 0.2 + Math.random() * 0.6;\n    }\n\n    update(time) {\n        let currentAngle = this.angle + time * this.speed;\n        let r = this.radius + Math.sin(time * this.oscillationSpeed + this.index) * this.oscillationAmp;\n        \n        // è¿™é‡Œçš„ cx, cy ä¸å†æ˜¯å›ºå®šå±å¹•ä¸­å¿ƒï¼Œç¨ååœ¨ draw ä¸­é€šè¿‡ translate å¤„ç†\n        // æˆ‘ä»¬åªè®¡ç®—ç›¸å¯¹åæ ‡\n        this.relX = Math.cos(currentAngle) * r;\n        this.relY = Math.sin(currentAngle) * r;\n\n        // å°†ç›¸å¯¹åæ ‡è½¬æ¢ä¸ºç»å¯¹åæ ‡ç”¨äºé¼ æ ‡äº¤äº’è®¡ç®—\n        let absX = width/2 + this.relX;\n        let absY = height/2 + this.relY;\n\n        // é¼ æ ‡äº¤äº’ï¼ˆå¢å¼ºäº†æ–¥åŠ›èŒƒå›´ï¼‰\n        let dx = mouse.x - absX;\n        let dy = mouse.y - absY;\n        let dist = Math.sqrt(dx*dx + dy*dy);\n        \n        // æ–¥åŠ›èŒƒå›´æ‰©å¤§åˆ° 300\n        if (dist < 300) {\n            let force = (300 - dist) / 300;\n            // ç®€å•çš„ç‰©ç†æ¨åŠ›æ¨¡æ‹Ÿ\n            this.relX -= dx * force * 0.6;\n            this.relY -= dy * force * 0.6;\n        }\n    }\n\n    draw(globalRotation) {\n        // è¿™é‡Œçš„ç»˜åˆ¶é€»è¾‘ç§»åˆ°äº†ä¸»å¾ªç¯ï¼Œä¸ºäº†ç»Ÿä¸€å¤„ç†è¿çº¿\n    }\n}\n\nfor (let i = 0; i < numParticles; i++) {\n    particles.push(new Particle(i));\n}\n\nlet time = 0;\nlet globalAngle = 0; // å…¨å±€æ—‹è½¬è§’åº¦\n\nfunction animate() {\n    requestAnimationFrame(animate);\n    time += 1;\n    \n    // --- æ ¸å¿ƒä¿®æ”¹ 3: å…¨å±€ç¼“æ…¢æ—‹è½¬ ---\n    globalAngle += 0.0005; \n\n    // æ‹–å°¾æ•ˆæœ\n    ctx.fillStyle = 'rgba(2, 2, 2, 0.25)'; \n    ctx.fillRect(0, 0, width, height);\n\n    // å°†åŸç‚¹ç§»åˆ°å±å¹•ä¸­å¿ƒï¼Œæ–¹ä¾¿åšæ—‹è½¬\n    ctx.save();\n    ctx.translate(width / 2, height / 2);\n    ctx.rotate(globalAngle);\n\n    // æ›´æ–°æ•°æ®\n    particles.forEach(p => p.update(time));\n\n    // ç»˜åˆ¶è¿çº¿\n    ctx.lineWidth = 0.6; // çº¿æ¡ç¨å¾®åŠ ç²—ä¸€ç‚¹ç‚¹\n    \n    for (let i = 0; i < numParticles; i++) {\n        for (let j = i + 1; j < numParticles; j++) {\n            let p1 = particles[i];\n            let p2 = particles[j];\n            \n            let dx = p1.relX - p2.relX;\n            let dy = p1.relY - p2.relY;\n            let distSq = dx * dx + dy * dy;\n\n            // --- æ ¸å¿ƒä¿®æ”¹ 4: æå¤§çš„è¿çº¿é˜ˆå€¼ ---\n            // ä» 6000 å¢åŠ åˆ° 25000ï¼Œå…è®¸è·¨åº¦å¾ˆå¤§çš„è¿çº¿\n            if (distSq < 25000) { \n                let alpha = 1 - (distSq / 25000);\n                // é¢œè‰²è°ƒæ•´ä¸ºæ›´çº¯å‡€çš„é’›ç™½/é’è‰²\n                ctx.strokeStyle = `rgba(180, 220, 255, ${alpha * 0.35})`; \n                ctx.beginPath();\n                ctx.moveTo(p1.relX, p1.relY);\n                ctx.lineTo(p2.relX, p2.relY);\n                ctx.stroke();\n            }\n        }\n    }\n    \n    // ç»˜åˆ¶èŠ‚ç‚¹\n    particles.forEach(p => {\n        ctx.beginPath();\n        ctx.arc(p.relX, p.relY, 1.8, 0, Math.PI * 2);\n        ctx.fillStyle = `rgba(255, 255, 255, ${p.baseAlpha})`;\n        ctx.fill();\n    });\n\n    ctx.restore();\n}\n\nanimate();\n\n</script>\n</body>\n</html>"
    },
    {
        "åºå·": 9,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Black Neural Knot</title>\n    <style>\n        body { \n            margin: 0; \n            overflow: hidden; \n            background-color: #000000; /* çº¯é»‘èƒŒæ™¯ */\n        }\n        canvas { \n            display: block; \n            width: 100vw; \n            height: 100vh;\n            outline: none;\n        }\n    </style>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n</head>\n<body>\n    <script>\n        // --- æš—é»‘ç‰ˆé…ç½® ---\n        const CONFIG = {\n            count: 5000,           // ç²’å­æ•°é‡å¢åŠ ï¼Œé»‘è‰²èƒŒæ™¯èƒ½å®¹çº³æ›´å¤šç»†èŠ‚\n            color: 0xffffff,       // ç²’å­çº¯ç™½\n            bg: 0x000000,          // èƒŒæ™¯çº¯é»‘\n            speed: 0.0005,         // æ•´ä½“æ—‹è½¬é€Ÿåº¦\n            flowSpeed: 0.002       // ç²’å­åœ¨ç¯ä¸Šçš„æµåŠ¨é€Ÿåº¦\n        };\n\n        // --- å˜é‡ ---\n        let scene, camera, renderer, mesh;\n        let dummy = new THREE.Object3D();\n        \n        // æ ¸å¿ƒæ—¶é—´å˜é‡\n        let time = 0;\n        \n        // æ¨¡æ‹Ÿç¥ç»è„‰å†²å¼•æ“\n        let neuralPulse = 0;\n        let targetPulse = 0;\n        let glitchMode = false;\n\n        init();\n        animate();\n\n        function init() {\n            // 1. åœºæ™¯\n            scene = new THREE.Scene();\n            scene.background = new THREE.Color(CONFIG.bg);\n            // é»‘è‰²é›¾æ°”ï¼šè®©è¿œå¤„çš„ç²’å­éšæ²¡åœ¨é»‘æš—ä¸­ï¼Œåˆ¶é€ æ·±æ¸Šæ„Ÿ\n            scene.fog = new THREE.FogExp2(CONFIG.bg, 0.02);\n\n            // 2. ç›¸æœº\n            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);\n            camera.position.set(0, 0, 35);\n\n            // 3. ç¯å…‰ç³»ç»Ÿ (ä¸ºé»‘è‰²èƒŒæ™¯å®šåˆ¶)\n            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); // ç¯å¢ƒå…‰å¾ˆå¼±\n            scene.add(ambientLight);\n\n            // ä¸»å…‰ï¼šå¼ºçƒˆçš„ç™½è‰²èšå…‰ç¯\n            const spotLight = new THREE.SpotLight(0xffffff, 2);\n            spotLight.position.set(20, 20, 20);\n            spotLight.angle = 0.5;\n            spotLight.penumbra = 1;\n            scene.add(spotLight);\n\n            // è“è‰²è¾¹ç¼˜å…‰ï¼šç»™ç™½è‰²ç²’å­ä¸€ç‚¹ç‚¹å†·å³»çš„ç§‘æŠ€æ„Ÿåå°„\n            const rimLight = new THREE.DirectionalLight(0xaaccff, 1.5);\n            rimLight.position.set(-10, 0, -20); // ä»èƒŒåæ‰“å…‰\n            scene.add(rimLight);\n\n            // 4. æ¸²æŸ“å™¨\n            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            document.body.appendChild(renderer.domElement);\n\n            // 5. å‡ ä½•ä½“è®¾è®¡\n            // ä½¿ç”¨ç»†é•¿çš„â€œé’ˆâ€çŠ¶å‡ ä½•ä½“ï¼Œæ¨¡æ‹Ÿæ•°æ®æµ\n            const geometry = new THREE.BoxGeometry(0.08, 0.08, 1.2); \n            const material = new THREE.MeshStandardMaterial({\n                color: CONFIG.color,\n                roughness: 0.4,  // ç¨å¾®ç²—ç³™ä¸€ç‚¹ï¼Œä¸ºäº†æ›´å¥½åœ°æ•æ‰å…‰çº¿\n                metalness: 0.8,  // é«˜é‡‘å±æ„Ÿï¼Œåƒé“¶é’ˆ\n            });\n\n            mesh = new THREE.InstancedMesh(geometry, material, CONFIG.count);\n            scene.add(mesh);\n\n            window.addEventListener('resize', onWindowResize, false);\n        }\n\n        // --- ç¥ç»è„‰å†²å¼•æ“ (ä¿æŒä½ å–œæ¬¢çš„ç®—æ³•é€»è¾‘) ---\n        function updateNeuralEngine() {\n            // éšæœºè§¦å‘â€œæ•…éšœâ€æˆ–â€œå¹³é™â€\n            if (Math.random() < 0.01) {\n                targetPulse = Math.random() * 2; // çªå˜ç›®æ ‡\n                glitchMode = Math.random() < 0.15; // 15% æ¦‚ç‡æ•…éšœ\n            } else {\n                targetPulse *= 0.98; // ç¼“æ…¢è¡°å‡å½’é›¶\n            }\n            // å¹³æ»‘è¿‡æ¸¡\n            neuralPulse += (targetPulse - neuralPulse) * 0.05;\n        }\n\n        // --- æ ¸å¿ƒæ•°å­¦å½¢æ€ï¼šTorus Knot (ç¯é¢çº½ç»“) ---\n        function getKnotPosition(u, v, target) {\n            // p å’Œ q å†³å®šäº†ç»“çš„ç¼ ç»•æ–¹å¼ (3, 4) æ˜¯ä¸€ä¸ªå¾ˆç¾çš„æ¯”ä¾‹\n            const p = 3;\n            const q = 4;\n            const r = 10 + neuralPulse * 2; // ç¯çš„åŠå¾„éšè„‰å†²å‘¼å¸\n\n            // ç¯é¢çº½ç»“å…¬å¼\n            const radius = 3 + Math.cos(q * u) * 1.5;\n            const x = (r + radius * Math.cos(v)) * Math.cos(p * u);\n            const y = (r + radius * Math.cos(v)) * Math.sin(p * u);\n            const z = radius * Math.sin(v) + Math.sin(u * 10 + time) * neuralPulse; // Zè½´éœ‡åŠ¨\n\n            target.set(x, y, z);\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            time += CONFIG.speed * (1 + neuralPulse); // è„‰å†²è¶Šå¼ºï¼Œæ—¶é—´è¶Šå¿«\n            updateNeuralEngine();\n\n            // æ•´ä½“æ—‹è½¬\n            mesh.rotation.y += 0.002;\n            mesh.rotation.z += 0.001;\n\n            let i = 0;\n            const timeOffset = Date.now() * CONFIG.flowSpeed;\n\n            for (let x = 0; x < CONFIG.count; x++) {\n                // è®¡ç®—æ¯ä¸ªç²’å­åœ¨â€œæµâ€ä¸­çš„ä½ç½®\n                // u: æ²¿ç€å¤§ç¯çš„ä½ç½®\n                // v: æ²¿ç€ç®¡å£çš„ä½ç½®\n                const u = (x / CONFIG.count) * Math.PI * 2 + timeOffset * 0.1;\n                const v = (x % 50) / 50 * Math.PI * 2;\n\n                // è·å–å½“å‰ä½ç½®\n                const pos = new THREE.Vector3();\n                getKnotPosition(u, v, pos);\n\n                // è·å–\"ç¨å¾®å‰é¢ä¸€ç‚¹\"çš„ä½ç½®ï¼Œç”¨äºè®©ç²’å­\"çœ‹å‘\"å‰æ–¹\n                // è¿™è®©å‡ ä½•ä½“é¡ºç€æµå‘æ’åˆ—ï¼Œåƒé±¼ç¾¤æˆ–æ•°æ®æµ\n                const nextPos = new THREE.Vector3();\n                getKnotPosition(u + 0.05, v, nextPos);\n\n                // åŠ ä¸Šä¸€ç‚¹éšæœºå™ªæ³¢ (Glitch Effect)\n                if (glitchMode) {\n                    const noise = (Math.random() - 0.5) * neuralPulse * 3;\n                    pos.x += noise;\n                    pos.y += noise;\n                    pos.z += noise;\n                }\n\n                dummy.position.copy(pos);\n                \n                // å…³é”®ï¼šè®©ç²’å­æœå‘æµåŠ¨çš„æ–¹å‘\n                dummy.lookAt(nextPos);\n                \n                // åŠ¨æ€ç¼©æ”¾ï¼šè„‰å†²å¼ºæ—¶ï¼Œç²’å­å˜é•¿å˜ç»†\n                const scale = 1 + Math.sin(u * 10 + time) * 0.5;\n                dummy.scale.set(1, 1, scale + neuralPulse);\n\n                dummy.updateMatrix();\n                mesh.setMatrixAt(i++, dummy.matrix);\n            }\n\n            mesh.instanceMatrix.needsUpdate = true;\n            renderer.render(scene, camera);\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 10,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <style>\n        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }\n        canvas { display: block; }\n        \n        /* UI Overlay - æ¨¡æ‹ŸHUDç•Œé¢ */\n        #ui-layer {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            color: rgba(255, 255, 255, 0.8);\n            pointer-events: none;\n            z-index: 10;\n            mix-blend-mode: difference;\n        }\n        .glitch-text {\n            font-size: 14px;\n            font-weight: bold;\n            text-transform: uppercase;\n            letter-spacing: 2px;\n            animation: flicker 2s infinite;\n        }\n        \n        /* CRT æ‰«æçº¿æ•ˆæœ */\n        .scanlines {\n            position: absolute;\n            top: 0; left: 0; width: 100%; height: 100%;\n            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));\n            background-size: 100% 4px;\n            pointer-events: none;\n            z-index: 20;\n        }\n        \n        @keyframes flicker {\n            0% { opacity: 0.9; }\n            5% { opacity: 0.1; }\n            10% { opacity: 0.9; }\n            100% { opacity: 0.9; }\n        }\n    </style>\n    <!-- Import Map for Three.js (Modern Standard) -->\n    <script type=\"importmap\">\n        {\n            \"imports\": {\n                \"three\": \"https://unpkg.com/three@0.160.0/build/three.module.js\",\n                \"three/addons/\": \"https://unpkg.com/three@0.160.0/examples/jsm/\"\n            }\n        }\n    </script>\n</head>\n<body>\n\n    <div id=\"ui-layer\">\n        <div class=\"glitch-text\">System: ONLINE</div>\n        <div class=\"glitch-text\" id=\"status\">Ghost: SEARCHING...</div>\n        <div class=\"glitch-text\" style=\"margin-top:10px; font-size:10px;\">MEM: 2048TB // SYNC: 98%</div>\n    </div>\n    \n    <div class=\"scanlines\"></div>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\n        import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';\n        import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';\n\n        // --- åˆå§‹åŒ–åœºæ™¯ ---\n        const scene = new THREE.Scene();\n        scene.background = new THREE.Color(0x000000); // çº¯é»‘èƒŒæ™¯\n        scene.fog = new THREE.FogExp2(0x000000, 0.02);\n\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        camera.position.z = 5;\n\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setPixelRatio(window.devicePixelRatio);\n        document.body.appendChild(renderer.domElement);\n\n        // --- 1. The Shell (æ ¸å¿ƒå‡ ä½•ä½“ - æ¨¡æ‹Ÿå¤§è„‘/æ ¸å¿ƒ) ---\n        // ä½¿ç”¨é«˜ç»†åˆ†çš„äºŒåé¢ä½“\n        const geometry = new THREE.IcosahedronGeometry(1.5, 20); \n        \n        // åˆ›å»ºè‡ªå®šä¹‰ Shader Material ä»¥å®ç°é»‘ç™½çº¿æ¡†è„‰å†²æ•ˆæœ\n        const material = new THREE.MeshBasicMaterial({ \n            color: 0xffffff, \n            wireframe: true,\n            transparent: true,\n            opacity: 0.15\n        });\n\n        const sphere = new THREE.Mesh(geometry, material);\n        scene.add(sphere);\n\n        // å†…éƒ¨æ ¸å¿ƒ (Solid Core) - ç”¨äºé®æŒ¡åæ–¹çº¿æ¡ï¼Œå¢åŠ ä½“ç§¯æ„Ÿ\n        const coreGeo = new THREE.IcosahedronGeometry(1.4, 2);\n        const coreMat = new THREE.MeshBasicMaterial({ color: 0x000000 });\n        const core = new THREE.Mesh(coreGeo, coreMat);\n        scene.add(core);\n\n        // --- 2. The Ghost (æ•°æ®ç²’å­äº‘) ---\n        const particlesCount = 3000;\n        const posArray = new Float32Array(particlesCount * 3);\n        \n        for(let i = 0; i < particlesCount * 3; i++) {\n            // ç²’å­åˆ†å¸ƒåœ¨çƒä½“å‘¨å›´\n            posArray[i] = (Math.random() - 0.5) * 12; \n        }\n\n        const particlesGeo = new THREE.BufferGeometry();\n        particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));\n\n        const particlesMat = new THREE.PointsMaterial({\n            size: 0.02,\n            color: 0x888888, // ç°è‰²ç²’å­\n            transparent: true,\n            opacity: 0.8,\n            blending: THREE.AdditiveBlending\n        });\n\n        const particlesMesh = new THREE.Points(particlesGeo, particlesMat);\n        scene.add(particlesMesh);\n\n        // --- 3. åå¤„ç† (Post-Processing) - èµ‹äºˆèµ›åšæœ‹å…‹è´¨æ„Ÿ ---\n        const composer = new EffectComposer(renderer);\n        const renderPass = new RenderPass(scene, camera);\n        composer.addPass(renderPass);\n\n        // Bloom (å‘å…‰) - è®©ç™½è‰²çº¿æ¡äº§ç”Ÿè¿‡æ›çš„è¾‰å…‰\n        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);\n        bloomPass.threshold = 0;\n        bloomPass.strength = 2.0; // å¼ºå…‰\n        bloomPass.radius = 0.5;\n        composer.addPass(bloomPass);\n\n        // Glitch (æ•…éšœ) - æ¨¡æ‹Ÿä¿¡å·å¹²æ‰°\n        const glitchPass = new GlitchPass();\n        glitchPass.goWild = false; // ä¸ä¼šä¸€ç›´ç–¯ç‹‚æ•…éšœï¼Œè€Œæ˜¯éšæœºè§¦å‘\n        composer.addPass(glitchPass);\n\n        // --- 4. äº¤äº’ä¸åŠ¨ç”»é€»è¾‘ ---\n        \n        // é¼ æ ‡äº¤äº’\n        let mouseX = 0;\n        let mouseY = 0;\n        let targetX = 0;\n        let targetY = 0;\n\n        const windowHalfX = window.innerWidth / 2;\n        const windowHalfY = window.innerHeight / 2;\n\n        document.addEventListener('mousemove', (event) => {\n            mouseX = (event.clientX - windowHalfX);\n            mouseY = (event.clientY - windowHalfY);\n            \n            // æ›´æ–°UIçŠ¶æ€\n            document.getElementById('status').innerText = \"Ghost: CONNECTED [\" + event.clientX + \":\" + event.clientY + \"]\";\n            document.getElementById('status').style.color = \"#ffffff\";\n        });\n\n        // å™ªæ³¢ç”Ÿæˆå™¨ (ç”¨äºæ¨¡æ‹Ÿæœ‰æœºå˜å½¢)\n        // ç®€å•çš„ä¼ªå™ªæ³¢å‡½æ•°æ›¿ä»£ heavy library\n        function noise(x, y, z) {\n            return Math.sin(x * 5) * Math.cos(y * 5) * Math.sin(z * 5);\n        }\n\n        const clock = new THREE.Clock();\n\n        // åŸå§‹é¡¶ç‚¹ä½ç½®å¤‡ä»½\n        const originalPositions = geometry.attributes.position.array.slice();\n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            const time = clock.getElapsedTime();\n\n            // --- æ ¸å¿ƒå˜å½¢åŠ¨ç”» (The Breathing Shell) ---\n            const positionAttribute = geometry.attributes.position;\n            const positions = positionAttribute.array;\n\n            for (let i = 0; i < positions.length; i += 3) {\n                // è·å–åŸå§‹åæ ‡\n                const ox = originalPositions[i];\n                const oy = originalPositions[i + 1];\n                const oz = originalPositions[i + 2];\n\n                // è®¡ç®—å™ªæ³¢åç§» (æ¨¡æ‹Ÿåƒæ¶²ä½“ä¸€æ ·çš„æµåŠ¨)\n                // ç»“åˆé¼ æ ‡ä½ç½®ï¼Œè®©\"Ghost\"å½±å“\"Shell\"çš„å½¢çŠ¶\n                const mouseInfluence = (Math.abs(mouseX) + Math.abs(mouseY)) * 0.0005;\n                const offset = noise(ox + time * 0.5, oy + time * 0.5, oz) * (0.2 + mouseInfluence);\n\n                // å½’ä¸€åŒ–å‘é‡å¹¶åº”ç”¨åç§»\n                const len = Math.sqrt(ox*ox + oy*oy + oz*oz);\n                const nx = ox / len;\n                const ny = oy / len;\n                const nz = oz / len;\n\n                positions[i] = ox + nx * offset;\n                positions[i + 1] = oy + ny * offset;\n                positions[i + 2] = oz + nz * offset;\n            }\n            positionAttribute.needsUpdate = true;\n\n            // --- ç²’å­äº‘åŠ¨ç”» ---\n            particlesMesh.rotation.y = -time * 0.1;\n            particlesMesh.rotation.x = mouseY * 0.0001;\n            \n            // æ ¸å¿ƒè·Ÿéšé¼ æ ‡è½»å¾®è½¬åŠ¨\n            targetX = mouseX * 0.001;\n            targetY = mouseY * 0.001;\n            sphere.rotation.y += 0.05 * (targetX - sphere.rotation.y);\n            sphere.rotation.x += 0.05 * (targetY - sphere.rotation.x);\n\n            // æ¸²æŸ“\n            composer.render();\n        }\n\n        // å“åº”çª—å£å¤§å°è°ƒæ•´\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            composer.setSize(window.innerWidth, window.innerHeight);\n        });\n\n        animate();\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 11,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <style>\n        body { margin: 0; overflow: hidden; background-color: #000; }\n        canvas { display: block; width: 100vw; height: 100vh; }\n    </style>\n</head>\n<body>\n    <!-- å¼•å…¥ Three.js (ä»…ç”¨äºåˆ›å»ºä¸€ä¸ªç”»æ¿) -->\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n\n    <!-- é¡¶ç‚¹ç€è‰²å™¨: ä»…ä»…æ˜¯å°†ç”»æ¿é“ºæ»¡å±å¹• -->\n    <script type=\"x-shader/x-vertex\" id=\"vertexShader\">\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = vec4(position, 1.0);\n        }\n    </script>\n\n    <!-- ç‰‡å…ƒç€è‰²å™¨: Raymarching çš„é­”æ³•å‘ç”Ÿåœ° -->\n    <script type=\"x-shader/x-fragment\" id=\"fragmentShader\">\n        uniform float uTime;\n        uniform vec2 uResolution;\n        uniform vec2 uMouse;\n\n        varying vec2 vUv;\n\n        // --- SDF Functions (æ•°å­¦å»ºæ¨¡) ---\n        \n        // æ—‹è½¬çŸ©é˜µ\n        mat2 rot(float a) {\n            float s = sin(a), c = cos(a);\n            return mat2(c, -s, s, c);\n        }\n\n        // Gyroid ç»“æ„: è¿™ç§æ— é™é‡å¤çš„æ›²é¢æ˜¯ Raymarching çš„æ‹¿æ‰‹å¥½æˆ\n        float sdGyroid(vec3 p, float scale, float thickness, float bias) {\n            p *= scale;\n            return abs(dot(sin(p), cos(p.zxy)) - bias) / scale - thickness;\n        }\n\n        // åœºæ™¯å®šä¹‰: èåˆçƒä½“ä¸ Gyroid\n        float map(vec3 p) {\n            // é¼ æ ‡äº’åŠ¨: ç¨å¾®æ—‹è½¬æ•´ä¸ªç©ºé—´\n            vec3 p_rot = p;\n            p_rot.yz *= rot(uMouse.y * 3.0);\n            p_rot.xz *= rot(uMouse.x * 3.0);\n\n            // åŸºç¡€çƒä½“\n            float sphere = length(p_rot) - 1.5;\n\n            // åŠ¨æ€å™ªå£°/Gyroid\n            // è®©å®ƒéšç€æ—¶é—´ç§»åŠ¨\n            vec3 q = p_rot + vec3(uTime * 0.2, uTime * 0.1, 0.0); \n            float g = sdGyroid(q, 4.0, 0.05, 0.0);\n\n            // å¸ƒå°”è¿ç®—: çƒä½“ INTERSECT Gyroid\n            // max(a, b) åœ¨ SDF ä¸­æ„å‘³ç€å–äº¤é›†\n            // æˆ‘ä»¬æ··åˆä¸€ä¸‹ï¼Œè®©å®ƒçœ‹èµ·æ¥åƒæ˜¯åœ¨çƒä½“å†…éƒ¨ç”Ÿé•¿çš„ç»“æ„\n            float d = max(sphere, g * 0.8); \n            \n            // å†æ·»åŠ ä¸€ç‚¹æ‰­æ›²\n            d += sin(p_rot.x * 10.0 + uTime) * 0.02;\n\n            return d;\n        }\n\n        // --- Raymarching Loop ---\n\n        // è®¡ç®—æ³•çº¿ (ç”¨äºå…‰ç…§)\n        vec3 getNormal(vec3 p) {\n            vec2 e = vec2(0.001, 0.0);\n            return normalize(vec3(\n                map(p + e.xyy) - map(p - e.xyy),\n                map(p + e.yxy) - map(p - e.yxy),\n                map(p + e.yyx) - map(p - e.yyx)\n            ));\n        }\n\n        // å…‰çº¿æ­¥è¿›ä¸»å‡½æ•°\n        float raymarch(vec3 ro, vec3 rd) {\n            float dO = 0.0; // è·ç¦»åŸç‚¹çš„è·ç¦»\n            for(int i = 0; i < 100; i++) {\n                vec3 p = ro + rd * dO;\n                float dS = map(p);\n                dO += dS;\n                if(dO > 20.0 || abs(dS) < 0.001) break;\n            }\n            return dO;\n        }\n\n        void main() {\n            // åæ ‡å½’ä¸€åŒ– (-1 åˆ° 1), å¹¶ä¿®æ­£é•¿å®½æ¯”\n            vec2 uv = (gl_FragCoord.xy * 2.0 - uResolution.xy) / uResolution.y;\n\n            // ç›¸æœºè®¾ç½®\n            vec3 ro = vec3(0.0, 0.0, -4.0); // Ray Origin (ç›¸æœºä½ç½®)\n            vec3 rd = normalize(vec3(uv, 1.5)); // Ray Direction (è§†é‡)\n\n            // --- æ¸²æŸ“ (Rendering with Chromatic Aberration) ---\n            \n            vec3 col = vec3(0.0);\n            \n            // æˆ‘ä»¬è¿›è¡Œä¸‰æ¬¡é‡‡æ ·ï¼Œç¨å¾®åç§»å…‰çº¿æ–¹å‘ï¼Œæ¨¡æ‹Ÿ RGB è‰²æ•£\n            // è¿™å°±æ˜¯è®©æè´¨çœ‹èµ·æ¥åƒé«˜çº§ç»ç’ƒ/æ°´æ™¶çš„å…³é”®\n            float dR = raymarch(ro, rd); // Red channel distance\n            float dG = raymarch(ro, rd + vec3(0.002, 0.0, 0.0)); // Green (slight offset)\n            float dB = raymarch(ro, rd + vec3(0.004, 0.0, 0.0)); // Blue (more offset)\n\n            // å¦‚æœå‡»ä¸­äº†ç‰©ä½“ (è·ç¦»å°äºæœ€å¤§è·ç¦»)\n            if(dR < 20.0) {\n                vec3 p = ro + rd * dR;\n                vec3 n = getNormal(p);\n                \n                // ç®€å•çš„å…‰ç…§æ¨¡å‹ (Rim Light + Diffuse)\n                vec3 lightPos = vec3(2.0, 2.0, -3.0);\n                vec3 l = normalize(lightPos - p);\n                float diff = max(dot(n, l), 0.0);\n                \n                // è²æ¶…å°”è¾¹ç¼˜å…‰ (Fresnel)\n                float fresnel = pow(1.0 + dot(rd, n), 3.0);\n\n                // çº¢è‰²é€šé“\n                col.r = diff * 0.1 + fresnel * 2.0;\n            }\n            \n            if(dG < 20.0) {\n                vec3 p = ro + (rd + vec3(0.002, 0.0, 0.0)) * dG;\n                vec3 n = getNormal(p);\n                float fresnel = pow(1.0 + dot(rd, n), 3.0);\n                // ç»¿è‰²é€šé“\n                col.g = fresnel * 2.0; \n            }\n\n            if(dB < 20.0) {\n                vec3 p = ro + (rd + vec3(0.004, 0.0, 0.0)) * dB;\n                vec3 n = getNormal(p);\n                float fresnel = pow(1.0 + dot(rd, n), 3.0);\n                // è“è‰²é€šé“\n                col.b = fresnel * 3.0; // è“è‰²ç¨å¾®å¼ºä¸€ç‚¹ï¼Œå¢åŠ å†·æ„Ÿ\n            }\n\n            // èƒŒæ™¯è¾‰å…‰ (Vignette & Glow)\n            // å¦‚æœæ²¡æœ‰å‡»ä¸­ç‰©ä½“ï¼Œç»™ä¸€ç‚¹å¾®å¦™çš„èƒŒæ™¯è‰²\n            float glow = length(uv);\n            col += vec3(0.02, 0.02, 0.05) * (1.0 - glow);\n\n            // Gamma æ ¡æ­£\n            col = pow(col, vec3(0.4545));\n\n            gl_FragColor = vec4(col, 1.0);\n        }\n    </script>\n\n    <script>\n        let camera, scene, renderer;\n        let uniforms;\n\n        function init() {\n            const container = document.body;\n\n            // æˆ‘ä»¬ä¸éœ€è¦çœŸæ­£çš„ 3D åœºæ™¯ï¼Œåªéœ€è¦ä¸€ä¸ªå¹³é¢æ¥æ˜¾ç¤º Shader\n            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n            scene = new THREE.Scene();\n\n            const geometry = new THREE.PlaneGeometry(2, 2);\n\n            uniforms = {\n                uTime: { value: 0.0 },\n                uResolution: { value: new THREE.Vector2() },\n                uMouse: { value: new THREE.Vector2(0.5, 0.5) }\n            };\n\n            const material = new THREE.ShaderMaterial({\n                uniforms: uniforms,\n                vertexShader: document.getElementById('vertexShader').textContent,\n                fragmentShader: document.getElementById('fragmentShader').textContent\n            });\n\n            const mesh = new THREE.Mesh(geometry, material);\n            scene.add(mesh);\n\n            renderer = new THREE.WebGLRenderer();\n            renderer.setPixelRatio(window.devicePixelRatio);\n            container.appendChild(renderer.domElement);\n\n            onWindowResize();\n            window.addEventListener('resize', onWindowResize, false);\n            document.addEventListener('mousemove', onMouseMove, false);\n\n            animate();\n        }\n\n        function onWindowResize() {\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            uniforms.uResolution.value.x = renderer.domElement.width;\n            uniforms.uResolution.value.y = renderer.domElement.height;\n        }\n\n        function onMouseMove(e) {\n            // å°†é¼ æ ‡åæ ‡æ˜ å°„åˆ° 0-1 ä¹‹é—´\n            uniforms.uMouse.value.x = e.clientX / window.innerWidth;\n            uniforms.uMouse.value.y = e.clientY / window.innerHeight;\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n            uniforms.uTime.value += 0.015; // é€Ÿåº¦æ§åˆ¶\n            renderer.render(scene, camera);\n        }\n\n        init();\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 12,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <style>\n        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }\n        canvas { display: block; width: 100%; height: 100%; }\n        /* ç®€å•çš„äº¤äº’æç¤º */\n        #hint {\n            position: absolute; bottom: 20px; left: 20px; color: rgba(255,255,255,0.3);\n            font-family: monospace; font-size: 12px; pointer-events: none; mix-blend-mode: difference;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"hint\">Generative Raymarching // Move Mouse to Rotate</div>\n    <canvas id=\"glCanvas\"></canvas>\n\n    <script>\n        const canvas = document.getElementById('glCanvas');\n        const gl = canvas.getContext('webgl');\n\n        if (!gl) { alert('Your browser does not support WebGL'); }\n\n        // é¡¶ç‚¹ç€è‰²å™¨ï¼šä»…ä»…æ˜¯ä¸€ä¸ªå…¨å±çš„çŸ©å½¢ç”»å¸ƒ\n        const vsSource = `\n            attribute vec4 aVertexPosition;\n            void main() {\n                gl_Position = aVertexPosition;\n            }\n        `;\n\n        // ç‰‡æ®µç€è‰²å™¨ï¼šé­”æ³•å‘ç”Ÿçš„åœ°æ–¹ (Ray Marching + SDF)\n        const fsSource = `\n            precision highp float;\n            uniform vec2 u_resolution;\n            uniform float u_time;\n            uniform vec2 u_mouse;\n\n            // è°ƒè‰²æ¿å‡½æ•°ï¼šåŸºäºä½™å¼¦çš„ç¨‹åºåŒ–é…è‰²\n            vec3 palette(float t) {\n                vec3 a = vec3(0.5, 0.5, 0.5);\n                vec3 b = vec3(0.5, 0.5, 0.5);\n                vec3 c = vec3(1.0, 1.0, 1.0);\n                vec3 d = vec3(0.263, 0.416, 0.557);\n                return a + b * cos(6.28318 * (c * t + d));\n            }\n\n            // 2D æ—‹è½¬çŸ©é˜µ\n            mat2 rot2D(float angle) {\n                float s = sin(angle);\n                float c = cos(angle);\n                return mat2(c, -s, s, c);\n            }\n\n            // SDF (æœ‰å‘è·ç¦»åœº) å‡½æ•°ï¼šå®šä¹‰åœºæ™¯ä¸­çš„å‡ ä½•ä½“\n            // è¿™é‡Œæ··åˆäº† Gyroid (èºæ—‹é¢) å’Œ æ‰­æ›²æ“ä½œ\n            float map(vec3 p) {\n                vec3 q = p; // ä¿å­˜åŸå§‹åæ ‡ç”¨äºçº¹ç†\n                \n                // ç©ºé—´æ‰­æ›²\n                p.z += u_time * 0.4; // å‘å‰é£è¡Œ\n                \n                // å¤æ‚çš„ç©ºé—´æŠ˜å \n                p.xy *= rot2D(p.z * 0.05); \n                \n                float scale = 0.8;\n                float d = 0.0;\n                \n                // Gyroid åˆ†å½¢å åŠ \n                d = dot(sin(p * scale), cos(p.yzx * scale)) / scale;\n                p += d * 1.5; // åŸŸæ‰­æ›²\n                d = abs(d) - 0.05; // æŠ½å£³ï¼Œä½¿å…¶å˜æˆç©ºå¿ƒç»“æ„\n                \n                return d * 0.5; // æ­¥è¿›é˜»å°¼ï¼Œé˜²æ­¢ç©¿æ¨¡\n            }\n\n            void main() {\n                vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;\n                vec2 m = (u_mouse.xy * 2.0 - u_resolution.xy) / u_resolution.y;\n\n                // åˆå§‹ç›¸æœºè®¾ç½®\n                vec3 ro = vec3(0.0, 0.0, -3.0); // å°„çº¿åŸç‚¹ (ç›¸æœºä½ç½®)\n                vec3 rd = normalize(vec3(uv, 1.0)); // å°„çº¿æ–¹å‘\n                \n                // é¼ æ ‡äº¤äº’ï¼šæ—‹è½¬ç›¸æœº\n                ro.yz *= rot2D(-m.y * 0.5);\n                rd.yz *= rot2D(-m.y * 0.5);\n                ro.xz *= rot2D(-m.x * 0.5);\n                rd.xz *= rot2D(-m.x * 0.5);\n\n                float t = 0.0; // æ€»è·ç¦»\n                vec3 col = vec3(0.0); // æœ€ç»ˆé¢œè‰²\n                float glow = 0.0; // ä½“ç§¯å…‰ç´¯ç§¯\n\n                // Ray Marching å¾ªç¯\n                for(int i = 0; i < 80; i++) {\n                    vec3 p = ro + rd * t; // å½“å‰é‡‡æ ·ç‚¹\n                    \n                    float d = map(p); // è·å–åˆ°è¡¨é¢çš„è·ç¦»\n                    \n                    // ä½“ç§¯å…‰è®¡ç®—ï¼šè·ç¦»è¶Šè¿‘ï¼Œå‘å…‰è¶Šå¼º\n                    // åˆ©ç”¨ abs(d) åˆ›é€ å†…éƒ¨å‘å…‰æ•ˆæœ\n                    float glowIntensity = 0.008 / (abs(d) + 0.0001);\n                    glow += glowIntensity; \n\n                    t += d; // æ­¥è¿›\n\n                    // è¿œå¹³é¢è£å‰ªæˆ–ç¢°æ’æ£€æµ‹\n                    if(t > 80.0 || abs(d) < 0.001) break;\n                }\n\n                // é¢œè‰²åˆæˆ\n                // ä½¿ç”¨ glow å€¼ä½œä¸ºè°ƒè‰²æ¿çš„è¾“å…¥ï¼Œåˆ›é€ è¿·å¹»è‰²å½©\n                col = palette(glow * 0.04 + float(t)*0.02 + u_time * 0.1);\n                \n                // åŠ ä¸Šä½“ç§¯å…‰è¾‰å…‰\n                col *= glow * 0.06;\n                \n                // è·ç¦»é›¾ï¼šè¿œå¤„å˜é»‘\n                col *= 1.0 / (1.0 + t * t * 0.05);\n\n                // è‰²è°ƒæ˜ å°„ (Tone mapping) é˜²æ­¢è¿‡æ›\n                col = smoothstep(0.0, 1.0, col);\n                col = pow(col, vec3(0.4545)); // Gamma æ ¡æ­£\n\n                gl_FragColor = vec4(col, 1.0);\n            }\n        `;\n\n        // WebGL åˆå§‹åŒ–æ ·æ¿ä»£ç \n        function initShaderProgram(gl, vsSource, fsSource) {\n            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);\n            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\n            const shaderProgram = gl.createProgram();\n            gl.attachShader(shaderProgram, vertexShader);\n            gl.attachShader(shaderProgram, fragmentShader);\n            gl.linkProgram(shaderProgram);\n            return shaderProgram;\n        }\n\n        function loadShader(gl, type, source) {\n            const shader = gl.createShader(type);\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                console.error(gl.getShaderInfoLog(shader));\n                gl.deleteShader(shader);\n                return null;\n            }\n            return shader;\n        }\n\n        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\n        const programInfo = {\n            program: shaderProgram,\n            attribLocations: {\n                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\n            },\n            uniformLocations: {\n                resolution: gl.getUniformLocation(shaderProgram, 'u_resolution'),\n                time: gl.getUniformLocation(shaderProgram, 'u_time'),\n                mouse: gl.getUniformLocation(shaderProgram, 'u_mouse'),\n            },\n        };\n\n        // å»ºç«‹ç¼“å†²\n        const positionBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n        const positions = [-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0];\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n\n        // é¼ æ ‡è·Ÿè¸ª\n        let mouseX = 0, mouseY = 0;\n        document.addEventListener('mousemove', (e) => {\n            const rect = canvas.getBoundingClientRect();\n            mouseX = e.clientX - rect.left;\n            mouseY = e.clientY - rect.top;\n        });\n\n        // æ¸²æŸ“å¾ªç¯\n        function render(now) {\n            now *= 0.001; // è½¬æ¢ä¸ºç§’\n\n            // è°ƒæ•´ç”»å¸ƒå°ºå¯¸\n            if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {\n                canvas.width = canvas.clientWidth;\n                canvas.height = canvas.clientHeight;\n                gl.viewport(0, 0, canvas.width, canvas.height);\n            }\n\n            gl.useProgram(programInfo.program);\n\n            // ç»‘å®šé¡¶ç‚¹\n            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n            gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);\n\n            // ä¼ é€’ Uniforms\n            gl.uniform2f(programInfo.uniformLocations.resolution, canvas.width, canvas.height);\n            gl.uniform1f(programInfo.uniformLocations.time, now);\n            gl.uniform2f(programInfo.uniformLocations.mouse, mouseX, mouseY);\n\n            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n            requestAnimationFrame(render);\n        }\n\n        requestAnimationFrame(render);\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 13,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <style>\n        body { margin: 0; overflow: hidden; background-color: #000; }\n        canvas { display: block; width: 100vw; height: 100vh; }\n        #title {\n            position: absolute;\n            bottom: 20px;\n            left: 20px;\n            color: rgba(255, 255, 255, 0.3);\n            font-family: 'Courier New', Courier, monospace;\n            font-size: 12px;\n            pointer-events: none;\n            z-index: 10;\n            text-transform: uppercase;\n            letter-spacing: 2px;\n        }\n    </style>\n    <!-- å¼•å…¥ Three.js å’Œ åå¤„ç†åº“ -->\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js\"></script>\n</head>\n<body>\n    <div id=\"title\">Echoes of Entropy // Generative Void</div>\n    <script>\n        // --- åœºæ™¯åˆå§‹åŒ– ---\n        const scene = new THREE.Scene();\n        scene.fog = new THREE.FogExp2(0x000000, 0.002); // è™šç©ºé›¾æ°”\n\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        camera.position.z = 4;\n\n        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: \"high-performance\" });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n        document.body.appendChild(renderer.domElement);\n\n        // --- GLSL ç€è‰²å™¨å®šä¹‰ (æ ¸å¿ƒè‰ºæœ¯é€»è¾‘) ---\n        \n        // é¡¶ç‚¹ç€è‰²å™¨ï¼šæ§åˆ¶ç²’å­çš„å½¢çŠ¶å˜æ¢ä¸æ‰­æ›²\n        const vertexShader = `\n            uniform float time;\n            varying vec2 vUv;\n            varying float vDistortion;\n\n            // ç»å…¸çš„ Perlin Noise ç®—æ³•ç‰‡æ®µ\n            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n            float snoise(vec3 v) {\n                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n                vec3 i  = floor(v + dot(v, C.yyy) );\n                vec3 x0 = v - i + dot(i, C.xxx) ;\n                vec3 g = step(x0.yzx, x0.xyz);\n                vec3 l = 1.0 - g;\n                vec3 i1 = min( g.xyz, l.zxy );\n                vec3 i2 = max( g.xyz, l.zxy );\n                vec3 x1 = x0 - i1 + C.xxx;\n                vec3 x2 = x0 - i2 + C.yyy;\n                vec3 x3 = x0 - D.yyy;\n                i = mod289(i);\n                vec4 p = permute( permute( permute(\n                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n                float n_ = 0.142857142857;\n                vec3  ns = n_ * D.wyz - D.xzx;\n                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n                vec4 x_ = floor(j * ns.z);\n                vec4 y_ = floor(j - 7.0 * x_ );\n                vec4 x = x_ *ns.x + ns.yyyy;\n                vec4 y = y_ *ns.x + ns.yyyy;\n                vec4 h = 1.0 - abs(x) - abs(y);\n                vec4 b0 = vec4( x.xy, y.xy );\n                vec4 b1 = vec4( x.zw, y.zw );\n                vec4 s0 = floor(b0)*2.0 + 1.0;\n                vec4 s1 = floor(b1)*2.0 + 1.0;\n                vec4 sh = -step(h, vec4(0.0));\n                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n                vec3 p0 = vec3(a0.xy,h.x);\n                vec3 p1 = vec3(a0.zw,h.y);\n                vec3 p2 = vec3(a1.xy,h.z);\n                vec3 p3 = vec3(a1.zw,h.w);\n                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;\n                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n                m = m * m;\n                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n            }\n\n            void main() {\n                vUv = uv;\n                \n                // äº§ç”Ÿå¤æ‚çš„æ¹æµå™ªå£°\n                float noise = snoise(position * 1.5 + time * 0.2);\n                \n                // æ ¸å¿ƒé€»è¾‘ï¼šç²’å­åŸæœ¬æ˜¯ä¸€ä¸ªçƒä½“ï¼Œä½†è¢«å™ªå£°æ’•è£‚\n                // éšç€æ—¶é—´æ¨ç§»ï¼Œæ’•è£‚ç¨‹åº¦å‘ˆæ­£å¼¦æ³¢å˜åŒ–ï¼ˆå‘¼å¸æ„Ÿï¼‰\n                float distortionStrength = sin(time * 0.5) * 0.5 + 0.5; \n                \n                vec3 newPos = position + normal * noise * (0.5 + distortionStrength * 2.0);\n                \n                // è®°å½•æ‰­æ›²ç¨‹åº¦ä¼ ç»™ç‰‡å…ƒç€è‰²å™¨ï¼Œç”¨äºæ§åˆ¶é€æ˜åº¦\n                vDistortion = noise;\n\n                vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);\n                gl_PointSize = (4.0 * (1.0 + distortionStrength)) * (1.0 / -mvPosition.z);\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        `;\n\n        // ç‰‡å…ƒç€è‰²å™¨ï¼šæ§åˆ¶ç²’å­çš„é¢œè‰²ã€å‘å…‰å’Œæ¶ˆé€\n        const fragmentShader = `\n            uniform float time;\n            varying float vDistortion;\n\n            void main() {\n                // å°†ç²’å­æ¸²æŸ“ä¸ºæŸ”å’Œçš„åœ†å½¢ï¼Œè€Œéæ–¹å—\n                float d = distance(gl_PointCoord, vec2(0.5));\n                if(d > 0.5) discard;\n\n                // é¢œè‰²é€»è¾‘ï¼š\n                // æ ¸å¿ƒæ˜¯ç™½è‰²ï¼Œè¾¹ç¼˜æ ¹æ®æ‰­æ›²ç¨‹åº¦å˜æˆå¹½çµèˆ¬çš„é’ç°è‰²\n                vec3 color = mix(vec3(0.8, 0.9, 1.0), vec3(0.1, 0.1, 0.1), smoothstep(0.0, 1.0, d));\n                \n                // è¶Šæ··ä¹±çš„åœ°æ–¹ï¼Œç²’å­è¶Šé€æ˜ï¼Œä»¿ä½›åœ¨æ¶ˆå¤±\n                float alpha = 1.0 - smoothstep(0.3, 0.5, d);\n                alpha *= (0.5 + 0.5 * cos(time + vDistortion * 10.0)); // é—ªçƒæ•ˆæœ\n\n                gl_FragColor = vec4(color, alpha * 0.8);\n            }\n        `;\n\n        // --- å‡ ä½•ä½“æ„å»º ---\n        const geometry = new THREE.IcosahedronGeometry(1.5, 60); // é«˜ç»†åˆ†çƒä½“ï¼Œçº¦3ä¸‡ä¸ªé¡¶ç‚¹\n        \n        const material = new THREE.ShaderMaterial({\n            uniforms: {\n                time: { value: 0 }\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n            transparent: true,\n            blending: THREE.AdditiveBlending, // å åŠ æ··åˆï¼Œäº§ç”Ÿå‘å…‰æ„Ÿ\n            depthWrite: false\n        });\n\n        const sphere = new THREE.Points(geometry, material);\n        scene.add(sphere);\n\n        // --- åå¤„ç† (Bloom Effect) ---\n        const renderScene = new THREE.RenderPass(scene, camera);\n        \n        // UnrealBloomPass å‚æ•°ï¼šåˆ†è¾¨ç‡, å¼ºåº¦, åŠå¾„, é˜ˆå€¼\n        // è¿™é‡Œçš„å¼ºåº¦è®¾å¾—å¾ˆé«˜ï¼Œä¸ºäº†åˆ¶é€ é‚£ç§â€œè¿‡æ›â€çš„è™šæ— æ„Ÿ\n        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);\n        bloomPass.threshold = 0;\n        bloomPass.strength = 2.0; // å¼ºå…‰\n        bloomPass.radius = 0.5;\n\n        const composer = new THREE.EffectComposer(renderer);\n        composer.addPass(renderScene);\n        composer.addPass(bloomPass);\n\n        // --- åŠ¨ç”»å¾ªç¯ ---\n        const clock = new THREE.Clock();\n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            const elapsedTime = clock.getElapsedTime();\n\n            // æ›´æ–° Shader æ—¶é—´å˜é‡\n            material.uniforms.time.value = elapsedTime;\n\n            // ç¼“æ…¢æ—‹è½¬ï¼Œå±•ç¤ºä¸åŒè§’åº¦çš„æ··æ²Œ\n            sphere.rotation.y = elapsedTime * 0.05;\n            sphere.rotation.z = elapsedTime * 0.02;\n\n            // æ‘„åƒæœºå¾®åŠ¨ï¼Œæ¨¡æ‹Ÿæ¼‚æµ®æ„Ÿ\n            camera.position.x = Math.sin(elapsedTime * 0.1) * 0.5;\n            camera.position.y = Math.cos(elapsedTime * 0.1) * 0.5;\n            camera.lookAt(scene.position);\n\n            // ä½¿ç”¨ Composer æ¸²æŸ“è€Œéé»˜è®¤ Renderer\n            composer.render();\n        }\n\n        animate();\n\n        // --- çª—å£è‡ªé€‚åº” ---\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            composer.setSize(window.innerWidth, window.innerHeight);\n        });\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 14,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <style>\n        body { \n            margin: 0; \n            overflow: hidden; \n            background-color: #000; /* çº¯é»‘èƒŒæ™¯ */\n        }\n        canvas { \n            display: block; \n            width: 100vw; \n            height: 100vh; \n        }\n    </style>\n</head>\n<body>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n\n<!-- Vertex Shader: é¡¶ç‚¹ç€è‰²å™¨ -->\n<script type=\"x-shader/x-vertex\" id=\"vertexshader\">\n    uniform float uTime;\n    uniform float uPixelRatio;\n    \n    attribute float aScale;\n    attribute vec3 aRandomness;\n    \n    varying vec3 vColor;\n\n    void main() {\n        vec3 newPos = position;\n        \n        // === 1. ç–¯ç‹‚çš„æ¼©æ¶¡è¿åŠ¨ ===\n        float radius = length(newPos.xz);\n        float angle = atan(newPos.z, newPos.x);\n        \n        // é€Ÿåº¦åŠ å¿«ï¼šuTime * 0.8 (ä¹‹å‰æ˜¯ 0.5)\n        // æ‰­æ›²åº¦åŠ å¤§ï¼š15.0 (ä¹‹å‰æ˜¯ 10.0)\n        float angleOffset = (15.0 / (radius + 0.01)) * sin(uTime * 0.3) + uTime * 0.8;\n        angle += angleOffset;\n        \n        newPos.x = radius * cos(angle);\n        newPos.z = radius * sin(angle);\n        \n        // === 2. å‰§çƒˆçš„ä¸Šä¸‹æ³¢åŠ¨ ===\n        // æŒ¯å¹…åŠ å¤§ï¼š* 0.8 (ä¹‹å‰æ˜¯ 0.5)\n        newPos.y += sin(uTime * 2.0 + radius * 1.5) * 0.8;\n        \n        // === 3. çˆ†ç‚¸èˆ¬çš„éšæœºæŠ–åŠ¨ ===\n        newPos += aRandomness * sin(uTime * 2.0 + newPos.x);\n\n        vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);\n        gl_Position = projectionMatrix * mvPosition;\n        \n        // === 4. å·¨å‹ç²’å­ ===\n        // åŸºç¡€å¤§å°æ”¹ä¸º 40.0 (ä¹‹å‰æ˜¯ 8.0)ï¼Œæå…·è§†è§‰å†²å‡»åŠ›\n        gl_PointSize = (40.0 * aScale * uPixelRatio) * (1.0 / -mvPosition.z);\n        \n        // === 5. é«˜èƒ½é…è‰² ===\n        // æ ¸å¿ƒï¼šç”µå…‰è“ (0.2, 1.0, 1.0)\n        // è¾¹ç¼˜ï¼šèµ›åšç²‰ (1.0, 0.1, 0.5)\n        vec3 colorInner = vec3(0.2, 1.0, 1.0); \n        vec3 colorOuter = vec3(1.0, 0.1, 0.5);\n        \n        float mixStrength = smoothstep(0.0, 6.0, radius + sin(uTime));\n        vColor = mix(colorInner, colorOuter, mixStrength);\n    }\n</script>\n\n<!-- Fragment Shader: ç‰‡å…ƒç€è‰²å™¨ -->\n<script type=\"x-shader/x-fragment\" id=\"fragmentshader\">\n    varying vec3 vColor;\n\n    void main() {\n        // è®¡ç®—å…‰ç‚¹è·ç¦»\n        float distanceToCenter = distance(gl_PointCoord, vec2(0.5));\n        \n        // === 6. è¶…å¼ºè¾‰å…‰ ===\n        // 0.1 / distance (ä¹‹å‰æ˜¯ 0.05)ï¼Œäº®åº¦ç¿»å€\n        float strength = 0.1 / distanceToCenter - 0.2;\n        \n        if (strength < 0.01) discard;\n\n        gl_FragColor = vec4(vColor, strength);\n    }\n</script>\n\n<script>\n    let scene, camera, renderer, material, particles;\n    // ç²’å­æ•°é‡ï¼šå‡å°‘åˆ° 25000ï¼Œå› ä¸ºç²’å­å˜å¤§äº†ï¼Œå¤ªå¯†ä¼šå˜æˆç™½èŒ«èŒ«ä¸€ç‰‡\n    const count = 25000; \n\n    function init() {\n        scene = new THREE.Scene();\n        \n        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);\n        camera.position.set(0, 2, 3); // ç›¸æœºæ‹‰è¿œä¸€ç‚¹ï¼Œçœ‹æ¸…å…¨è²Œ\n        camera.lookAt(0, 0, 0);\n\n        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n        document.body.appendChild(renderer.domElement);\n\n        const geometry = new THREE.BufferGeometry();\n        const positions = new Float32Array(count * 3);\n        const randomness = new Float32Array(count * 3);\n        const scales = new Float32Array(count);\n\n        for(let i = 0; i < count; i++) {\n            const i3 = i * 3;\n            const radius = Math.random() * 7 + Math.random(); \n            const spinAngle = radius * 3.0;\n            const branchAngle = (i % 3) * ((2 * Math.PI) / 3);\n\n            // è®©ç²’å­åˆ†å¸ƒæ›´æ•£ä¹±ä¸€ç‚¹ï¼Œå¢åŠ ä½“ç§¯æ„Ÿ\n            const randomX = (Math.random() - 0.5) * 2.0;\n            const randomY = (Math.random() - 0.5) * 2.0;\n            const randomZ = (Math.random() - 0.5) * 2.0;\n\n            positions[i3] = Math.cos(branchAngle + spinAngle) * radius + randomX;\n            positions[i3 + 1] = randomY * 1.5; \n            positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * radius + randomZ;\n\n            randomness[i3] = (Math.random() - 0.5) * 1.0;\n            randomness[i3+1] = (Math.random() - 0.5) * 1.0;\n            randomness[i3+2] = (Math.random() - 0.5) * 1.0;\n\n            scales[i] = Math.random();\n        }\n\n        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n        geometry.setAttribute('aRandomness', new THREE.BufferAttribute(randomness, 3));\n        geometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));\n\n        material = new THREE.ShaderMaterial({\n            depthWrite: false,\n            blending: THREE.AdditiveBlending, // å åŠ å‘å…‰æ¨¡å¼\n            vertexColors: true,\n            vertexShader: document.getElementById('vertexshader').textContent,\n            fragmentShader: document.getElementById('fragmentshader').textContent,\n            uniforms: {\n                uTime: { value: 0 },\n                uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) }\n            }\n        });\n\n        particles = new THREE.Points(geometry, material);\n        scene.add(particles);\n\n        window.addEventListener('resize', onWindowResize, false);\n        animate();\n    }\n\n    function onWindowResize() {\n        camera.aspect = window.innerWidth / window.innerHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        material.uniforms.uPixelRatio.value = Math.min(window.devicePixelRatio, 2);\n    }\n\n    const clock = new THREE.Clock();\n\n    function animate() {\n        const elapsedTime = clock.getElapsedTime();\n        material.uniforms.uTime.value = elapsedTime;\n        \n        // æ•´ä½“åœºæ™¯ä¹Ÿåœ¨ç¼“æ…¢æ—‹è½¬\n        scene.rotation.y = elapsedTime * 0.1;\n        \n        renderer.render(scene, camera);\n        requestAnimationFrame(animate);\n    }\n\n    init();\n</script>\n</body>\n</html>"
    },
    {
        "åºå·": 15,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Interactive Noise Sphere</title>\n    <style>\n        body { margin: 0; overflow: hidden; background-color: #000; }\n        canvas { display: block; }\n        #instruction {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            color: rgba(255, 255, 255, 0.6);\n            font-family: sans-serif;\n            pointer-events: none;\n            user-select: none;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"instruction\">\n\n    </div>\n\n    <!-- å¼•å…¥ Three.js å’Œ lil-gui -->\n    <script type=\"importmap\">\n        {\n            \"imports\": {\n                \"three\": \"https://unpkg.com/three@0.160.0/build/three.module.js\",\n                \"three/addons/\": \"https://unpkg.com/three@0.160.0/examples/jsm/\",\n                \"lil-gui\": \"https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js\"\n            }\n        }\n    </script>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n        import GUI from 'lil-gui';\n\n        // --- 1. åœºæ™¯åŸºç¡€è®¾ç½® ---\n        const scene = new THREE.Scene();\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);\n        camera.position.z = 3;\n\n        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // æ€§èƒ½ä¼˜åŒ–\n        document.body.appendChild(renderer.domElement);\n\n        const controls = new OrbitControls(camera, renderer.domElement);\n        controls.enableDamping = true;\n\n        // --- 2. Shader å®šä¹‰ ---\n        \n        // é¡¶ç‚¹ç€è‰²å™¨ï¼šå¤„ç†å½¢çŠ¶å’Œä½ç§»\n        const vertexShader = `\n            uniform float uTime;\n            uniform float uFrequency;\n            uniform float uAmplitude;\n            uniform vec2 uMouse;\n            \n            varying float vNoise;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n\n            // Simplex Noise 3D (æ ‡å‡†å™ªå£°ç®—æ³•)\n            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n            float snoise(vec3 v) {\n                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n                vec3 i  = floor(v + dot(v, C.yyy) );\n                vec3 x0 = v - i + dot(i, C.xxx) ;\n                vec3 g = step(x0.yzx, x0.xyz);\n                vec3 l = 1.0 - g;\n                vec3 i1 = min( g.xyz, l.zxy );\n                vec3 i2 = max( g.xyz, l.zxy );\n                vec3 x1 = x0 - i1 + C.xxx;\n                vec3 x2 = x0 - i2 + C.yyy;\n                vec3 x3 = x0 - D.yyy;\n                i = mod289(i);\n                vec4 p = permute( permute( permute(\n                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n                float n_ = 0.142857142857;\n                vec3  ns = n_ * D.wyz - D.xzx;\n                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n                vec4 x_ = floor(j * ns.z);\n                vec4 y_ = floor(j - 7.0 * x_ );\n                vec4 x = x_ *ns.x + ns.yyyy;\n                vec4 y = y_ *ns.x + ns.yyyy;\n                vec4 h = 1.0 - abs(x) - abs(y);\n                vec4 b0 = vec4( x.xy, y.xy );\n                vec4 b1 = vec4( x.zw, y.zw );\n                vec4 s0 = floor(b0)*2.0 + 1.0;\n                vec4 s1 = floor(b1)*2.0 + 1.0;\n                vec4 sh = -step(h, vec4(0.0));\n                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n                vec3 p0 = vec3(a0.xy,h.x);\n                vec3 p1 = vec3(a0.zw,h.y);\n                vec3 p2 = vec3(a1.xy,h.z);\n                vec3 p3 = vec3(a1.zw,h.w);\n                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;\n                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n                m = m * m;\n                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n            }\n\n            void main() {\n                vNormal = normal;\n                \n                // äº¤äº’é€»è¾‘ï¼šé¼ æ ‡ä½ç½®è½»å¾®å½±å“å™ªå£°é‡‡æ ·çš„åæ ‡ï¼Œäº§ç”Ÿ\"æ‹–æ‹½\"æ„Ÿ\n                vec3 noisePos = position * uFrequency + uTime * 0.2;\n                noisePos.x += uMouse.x * 1.0; \n                noisePos.y += uMouse.y * 1.0;\n\n                float noise = snoise(noisePos);\n                vNoise = noise;\n\n                // æ··åˆä¹˜ç§¯ï¼šä½ç½® + æ³•çº¿ * å™ªå£° * å¹…åº¦\n                vec3 newPos = position + normal * noise * uAmplitude;\n\n                // è®¡ç®—è§†å›¾ä½ç½®ï¼Œç”¨äºè²æ¶…å°”æ•ˆæœ\n                vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);\n                vViewPosition = -mvPosition.xyz;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        `;\n\n        // ç‰‡å…ƒç€è‰²å™¨ï¼šå¤„ç†é¢œè‰²å’Œå…‰æ•ˆ\n        const fragmentShader = `\n            uniform vec3 uColorHigh;\n            uniform vec3 uColorLow;\n            uniform vec2 uMouse;\n            \n            varying float vNoise;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n\n            void main() {\n                // 1. åŸºç¡€é¢œè‰²æ··åˆ\n                float t = vNoise * 0.5 + 0.5; // å½’ä¸€åŒ–åˆ° 0-1\n                \n                // äº¤äº’ï¼šé¼ æ ‡ä½ç½®è½»å¾®åç§»é¢œè‰²æ··åˆçš„å¹³è¡¡ç‚¹\n                t += dot(uMouse, vec2(0.2)); \n\n                vec3 color = mix(uColorLow, uColorHigh, t);\n\n                // 2. è®¡ç®—è²æ¶…å°”æ•ˆåº” (Fresnel Effect) - è¾¹ç¼˜å‘å…‰\n                vec3 viewDir = normalize(vViewPosition);\n                vec3 normal = normalize(vNormal);\n                float fresnel = dot(viewDir, normal);\n                fresnel = clamp(1.0 - fresnel, 0.0, 1.0);\n                fresnel = pow(fresnel, 3.0); // è°ƒèŠ‚å‘å…‰é”åº¦\n\n                // 3. å åŠ è²æ¶…å°”å…‰\n                vec3 finalColor = color + vec3(1.0) * fresnel * 0.8;\n\n                gl_FragColor = vec4(finalColor, 1.0);\n            }\n        `;\n\n        // --- 3. åˆ›å»ºç‰©ä½“ ---\n        \n        const debugObject = {\n            colorHigh: '#203afe',\n            colorLow: '#006eff',\n            frequency: 2.54,\n            amplitude: 0.4,\n            speed: 1.51\n        };\n\n        const uniforms = {\n            uTime: { value: 0 },\n            uFrequency: { value: debugObject.frequency },\n            uAmplitude: { value: debugObject.amplitude },\n            uMouse: { value: new THREE.Vector2(0, 0) },\n            uColorHigh: { value: new THREE.Color(debugObject.colorHigh) },\n            uColorLow: { value: new THREE.Color(debugObject.colorLow) }\n        };\n\n        const material = new THREE.ShaderMaterial({\n            vertexShader,\n            fragmentShader,\n            uniforms,\n            wireframe: true\n        });\n\n        // ä½¿ç”¨ IcosahedronGeometry å¯ä»¥è·å¾—æ›´å‡åŒ€çš„ä¸‰è§’å½¢åˆ†å¸ƒï¼Œé€‚åˆçƒä½“å˜å½¢\n        const geometry = new THREE.IcosahedronGeometry(1, 60); \n        const mesh = new THREE.Mesh(geometry, material);\n        scene.add(mesh);\n\n        // --- 4. äº¤äº’ä¸åŠ¨ç”» ---\n\n        // é¼ æ ‡è¿½è¸ª\n        const mouse = new THREE.Vector2();\n        window.addEventListener('mousemove', (event) => {\n            // å½’ä¸€åŒ–é¼ æ ‡åæ ‡ (-1 åˆ° 1)\n            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n        });\n\n        // GUI æ§åˆ¶é¢æ¿\n        const gui = new GUI();\n        gui.addColor(debugObject, 'colorHigh').name('é«˜ä½é¢œè‰²').onChange(() => {\n            uniforms.uColorHigh.value.set(debugObject.colorHigh);\n        });\n        gui.addColor(debugObject, 'colorLow').name('ä½ä½é¢œè‰²').onChange(() => {\n            uniforms.uColorLow.value.set(debugObject.colorLow);\n        });\n        gui.add(debugObject, 'frequency').min(0).max(5).step(0.01).name('å™ªå£°é¢‘ç‡').onChange(() => {\n            uniforms.uFrequency.value = debugObject.frequency;\n        });\n        gui.add(debugObject, 'amplitude').min(0).max(1).step(0.01).name('å˜å½¢å¹…åº¦').onChange(() => {\n            uniforms.uAmplitude.value = debugObject.amplitude;\n        });\n        gui.add(debugObject, 'speed').min(0).max(2).step(0.01).name('æµåŠ¨é€Ÿåº¦');\n        gui.add(material, 'wireframe').name('çº¿æ¡†æ¨¡å¼');\n\n        // æ¸²æŸ“å¾ªç¯\n        const clock = new THREE.Clock();\n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            const elapsedTime = clock.getElapsedTime();\n            \n            // æ›´æ–° Uniforms\n            uniforms.uTime.value = elapsedTime * debugObject.speed;\n            \n            // å¹³æ»‘æ’å€¼æ›´æ–°é¼ æ ‡ Uniform (Lerp)\n            uniforms.uMouse.value.x += (mouse.x - uniforms.uMouse.value.x) * 0.05;\n            uniforms.uMouse.value.y += (mouse.y - uniforms.uMouse.value.y) * 0.05;\n\n            // ç¼“æ…¢è‡ªè½¬\n            mesh.rotation.y = elapsedTime * 0.1;\n            mesh.rotation.z = elapsedTime * 0.05;\n\n            controls.update();\n            renderer.render(scene, camera);\n        }\n\n        animate();\n\n        // çª—å£è‡ªé€‚åº”\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 16,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Ryoji Ikeda Style Dice World</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            background-color: #000;\n            overflow: hidden;\n            font-family: 'Courier New', Courier, monospace; /* ç­‰å®½å­—ä½“ç¬¦åˆæ•°æ®æ„Ÿ */\n        }\n        canvas {\n            display: block;\n        }\n        #overlay {\n            position: absolute;\n            bottom: 20px;\n            left: 20px;\n            color: #fff;\n            font-size: 10px;\n            pointer-events: none;\n            mix-blend-mode: difference;\n            z-index: 10;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"overlay\">\n        SYSTEM: DICE_WORLD_V.1.0<br>\n        STATUS: UNSTABLE<br>\n        FPS: <span id=\"fps\">60</span>\n    </div>\n    <canvas id=\"canvas\"></canvas>\n\n    <script>\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d', { alpha: false }); // ä¼˜åŒ–æ€§èƒ½\n        const fpsDisplay = document.getElementById('fps');\n\n        let width, height;\n        let diceArray = [];\n        let frame = 0;\n        let mouse = { x: -1000, y: -1000, active: false };\n\n        // é…ç½®å‚æ•°\n        const config = {\n            diceCount: 60,\n            baseSize: 40,\n            speed: 2,\n            glitchIntensity: 0.15, // æ•…éšœå¼ºåº¦\n            strobeInterval: 120 // é¢‘é—ªé—´éš”\n        };\n\n        // åˆå§‹åŒ–ç”»å¸ƒ\n        function resize() {\n            width = canvas.width = window.innerWidth;\n            height = canvas.height = window.innerHeight;\n            initDice();\n        }\n\n        window.addEventListener('resize', resize);\n\n        // é¼ æ ‡äº¤äº’\n        window.addEventListener('mousemove', (e) => {\n            mouse.x = e.clientX;\n            mouse.y = e.clientY;\n            mouse.active = true;\n        });\n\n        window.addEventListener('mousedown', () => {\n            // ç‚¹å‡»äº§ç”Ÿå‰§çƒˆæ•…éšœ\n            config.glitchIntensity = 0.8;\n            setTimeout(() => config.glitchIntensity = 0.15, 200);\n            diceArray.forEach(d => d.randomize());\n        });\n\n        // éª°å­ç±»\n        class Die {\n            constructor() {\n                this.reset();\n            }\n\n            reset() {\n                this.x = Math.random() * width;\n                this.y = Math.random() * height;\n                this.vx = (Math.random() - 0.5) * config.speed;\n                this.vy = (Math.random() - 0.5) * config.speed;\n                this.value = Math.floor(Math.random() * 6) + 1;\n                this.size = config.baseSize * (Math.random() > 0.9 ? 2 : 1); // å¶å°”æœ‰å¤§éª°å­\n                this.isInverted = Math.random() > 0.95;\n                this.glitchTimer = 0;\n            }\n\n            randomize() {\n                this.vx = (Math.random() - 0.5) * 10;\n                this.vy = (Math.random() - 0.5) * 10;\n                this.value = Math.floor(Math.random() * 6) + 1;\n            }\n\n            update() {\n                // ç§»åŠ¨\n                this.x += this.vx;\n                this.y += this.vy;\n\n                // è¾¹ç•Œåå¼¹ï¼ˆç¡¬åˆ‡ï¼Œç¬¦åˆæ•°å­—æ„Ÿï¼‰\n                if (this.x < 0 || this.x > width - this.size) this.vx *= -1;\n                if (this.y < 0 || this.y > height - this.size) this.vy *= -1;\n\n                // é¼ æ ‡æ’æ–¥/å¸å¼•é€»è¾‘\n                if (mouse.active) {\n                    const dx = mouse.x - (this.x + this.size/2);\n                    const dy = mouse.y - (this.y + this.size/2);\n                    const dist = Math.sqrt(dx*dx + dy*dy);\n                    \n                    if (dist < 200) {\n                        // é è¿‘é¼ æ ‡æ—¶ï¼Œæ•°å€¼ç–¯ç‹‚è·³åŠ¨\n                        if (frame % 2 === 0) this.value = Math.floor(Math.random() * 6) + 1;\n                        // è½»å¾®æ’æ–¥\n                        this.vx -= dx * 0.001;\n                        this.vy -= dy * 0.001;\n                    }\n                }\n\n                // éšæœºæ•°å€¼è·³å˜ï¼ˆæ¨¡æ‹Ÿæ•°æ®æµï¼‰\n                if (Math.random() < 0.02) {\n                    this.value = Math.floor(Math.random() * 6) + 1;\n                }\n                \n                // éšæœºåè‰²\n                if (Math.random() < 0.01) this.isInverted = !this.isInverted;\n            }\n\n            draw() {\n                // ç¡®å®šé¢œè‰²\n                let bg = this.isInverted ? '#fff' : '#000';\n                let fg = this.isInverted ? '#000' : '#fff';\n\n                // ç»˜åˆ¶åº•åº§\n                ctx.fillStyle = bg;\n                ctx.fillRect(this.x, this.y, this.size, this.size);\n                \n                // ç»˜åˆ¶è¾¹æ¡†ï¼ˆç»†çº¿ï¼‰\n                ctx.strokeStyle = fg;\n                ctx.lineWidth = 1;\n                ctx.strokeRect(this.x, this.y, this.size, this.size);\n\n                // ç»˜åˆ¶ç‚¹æ•° (ä½¿ç”¨æ–¹å½¢ç‚¹ï¼Œç¬¦åˆIkedaé£æ ¼)\n                ctx.fillStyle = fg;\n                const s = this.size;\n                const p = s / 5; // padding unit\n                const dotSize = s / 6;\n\n                const drawDot = (cx, cy) => {\n                    ctx.fillRect(this.x + cx - dotSize/2, this.y + cy - dotSize/2, dotSize, dotSize);\n                };\n\n                // æç®€çš„ç‚¹æ•°é€»è¾‘\n                if (this.value % 2 !== 0) drawDot(s/2, s/2); // 1, 3, 5\n                if (this.value > 1) { drawDot(p, p); drawDot(s-p, s-p); } // 2, 3, 4, 5, 6\n                if (this.value > 3) { drawDot(s-p, p); drawDot(p, s-p); } // 4, 5, 6\n                if (this.value === 6) { drawDot(p, s/2); drawDot(s-p, s/2); } // 6\n                \n                // è£…é¥°æ€§æ•°æ®æ–‡æœ¬\n                if (this.size > config.baseSize) {\n                    ctx.font = '8px monospace';\n                    ctx.fillText(`0x${this.value}${Math.floor(Math.random()*9)}`, this.x, this.y - 2);\n                }\n            }\n        }\n\n        function initDice() {\n            diceArray = [];\n            for (let i = 0; i < config.diceCount; i++) {\n                diceArray.push(new Die());\n            }\n        }\n\n        // æ•…éšœæ•ˆæœå¤„ç†å™¨\n        function applyGlitch() {\n            if (Math.random() > config.glitchIntensity) return;\n\n            const glitchType = Math.floor(Math.random() * 4);\n            const h = height;\n            const w = width;\n\n            // 1. æ°´å¹³åˆ‡ç‰‡ä½ç§» (Tearing)\n            if (glitchType === 0) {\n                const sliceY = Math.random() * h;\n                const sliceH = Math.random() * 50 + 10;\n                const offset = (Math.random() - 0.5) * 40;\n                // è·å–åˆ‡ç‰‡æ•°æ®\n                try {\n                    const imageData = ctx.getImageData(0, sliceY, w, sliceH);\n                    ctx.putImageData(imageData, offset, sliceY);\n                } catch(e) {} // é˜²æ­¢è·¨åŸŸæˆ–è¶…å‡ºè¾¹ç•ŒæŠ¥é”™\n            }\n\n            // 2. RGB åˆ†ç¦» (Chromatic Aberration)\n            if (glitchType === 1) {\n                ctx.globalCompositeOperation = 'screen';\n                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                // éšæœºç”»ä¸€äº›çº¢è‰²å—\n                ctx.fillRect(Math.random() * w, 0, Math.random() * 5, h);\n                ctx.globalCompositeOperation = 'source-over';\n            }\n\n            // 3. é¢œè‰²åè½¬é¢‘é—ª (Strobe)\n            if (glitchType === 2 && Math.random() < 0.1) {\n                ctx.fillStyle = '#fff';\n                ctx.globalCompositeOperation = 'difference';\n                ctx.fillRect(0, 0, w, h);\n                ctx.globalCompositeOperation = 'source-over';\n            }\n            \n            // 4. å™ªç‚¹çº¿ (Scanlines)\n            if (glitchType === 3) {\n                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';\n                for(let i=0; i<h; i+=4) {\n                    if(Math.random() > 0.5) ctx.fillRect(0, i, w, 1);\n                }\n            }\n        }\n\n        function drawGrid() {\n            ctx.strokeStyle = 'rgba(50, 50, 50, 0.5)';\n            ctx.lineWidth = 0.5;\n            const step = 100;\n            \n            // ç§»åŠ¨çš„ç½‘æ ¼\n            const offset = (frame * 2) % step;\n            \n            for (let x = offset; x < width; x += step) {\n                ctx.beginPath();\n                ctx.moveTo(x, 0);\n                ctx.lineTo(x, height);\n                ctx.stroke();\n            }\n            \n            // éšæœºå‡ºç°çš„æ°´å¹³æ•°æ®çº¿\n            if (Math.random() < 0.3) {\n                const y = Math.random() * height;\n                ctx.strokeStyle = '#fff';\n                ctx.beginPath();\n                ctx.moveTo(0, y);\n                ctx.lineTo(width, y);\n                ctx.stroke();\n                \n                // çº¿ä¸Šæ•°å­—\n                ctx.fillStyle = '#fff';\n                ctx.font = '10px monospace';\n                ctx.fillText(Math.random().toString(2).substring(2, 12), 10, y - 2);\n            }\n        }\n\n        function animate() {\n            frame++;\n            \n            // èƒŒæ™¯æ¸…é™¤ (ä¿ç•™ä¸€ç‚¹æ‹–å½±ä»¥å¢åŠ åŠ¨æ€æ„Ÿï¼Œæˆ–è€…å®Œå…¨æ¸…é™¤ä»¥è·å¾—é”åˆ©æ„Ÿ)\n            // æ± ç”°äº®å¸é£æ ¼é€šå¸¸éå¸¸é”åˆ©ï¼Œæ‰€ä»¥æˆ‘ä»¬å®Œå…¨æ¸…é™¤ï¼Œä½†ç”¨é»‘è‰²å¡«å……\n            ctx.fillStyle = '#000';\n            ctx.fillRect(0, 0, width, height);\n\n            drawGrid();\n\n            // æ›´æ–°å¹¶ç»˜åˆ¶éª°å­\n            diceArray.forEach(die => {\n                die.update();\n                die.draw();\n            });\n\n            // åå¤„ç†æ•…éšœæ•ˆæœ\n            applyGlitch();\n\n            // å‘¨æœŸæ€§çš„å¤§è§„æ¨¡é¢‘é—ª\n            if (frame % config.strobeInterval === 0) {\n                ctx.fillStyle = '#fff';\n                ctx.fillRect(0, 0, width, height);\n            }\n\n            // æ›´æ–°FPS\n            if (frame % 20 === 0) fpsDisplay.innerText = Math.round(1000 / 16); // å‡æ•°æ®ï¼Œä¿æŒè§†è§‰é£æ ¼\n\n            requestAnimationFrame(animate);\n        }\n\n        // å¯åŠ¨\n        resize();\n        animate();\n\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 17,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Minimalist 3D Vector World</title>\n    <style>\n        body { \n            margin: 0; \n            overflow: hidden; \n            background-color: #050505; /* ææ·±ç°èƒŒæ™¯ */\n            font-family: sans-serif;\n        }\n        canvas { \n            display: block; \n        }\n        #instruction {\n            position: absolute;\n            bottom: 20px;\n            left: 20px;\n            color: #444;\n            font-size: 12px;\n            pointer-events: none;\n            text-transform: uppercase;\n            letter-spacing: 2px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"instruction\">Interactive Vector Field</div>\n    \n    <!-- å¼•å…¥ Three.js -->\n    <script type=\"module\">\n        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';\n\n        // --- 1. åˆå§‹åŒ–åœºæ™¯ ---\n        const scene = new THREE.Scene();\n        scene.background = new THREE.Color(0x050505); // æç®€æ·±è‰²èƒŒæ™¯\n        scene.fog = new THREE.Fog(0x050505, 200, 1000); // è¿œå¤„çš„é›¾åŒ–æ•ˆæœ\n\n        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 2000);\n        camera.position.z = 600;\n\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.body.appendChild(renderer.domElement);\n\n        // --- 2. åˆ›å»ºæ–¹å—ç²’å­ç³»ç»Ÿ ---\n        const particleCount = 150; // æ–¹å—æ•°é‡\n        const particles = [];\n        const connectionDistance = 120; // è¿çº¿é˜ˆå€¼è·ç¦»\n        \n        // æ–¹å—å‡ ä½•ä½“ (æç®€å°æ–¹å—)\n        const geometry = new THREE.BoxGeometry(40, 40, 40);\n        const material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });\n\n        // è¾¹ç•ŒèŒƒå›´\n        const range = 400;\n\n        for (let i = 0; i < particleCount; i++) {\n            const particle = new THREE.Mesh(geometry, material);\n\n            // éšæœºä½ç½®\n            particle.position.x = Math.random() * range * 2 - range;\n            particle.position.y = Math.random() * range * 2 - range;\n            particle.position.z = Math.random() * range * 2 - range;\n\n            // éšæœºé€Ÿåº¦å‘é‡\n            particle.userData = {\n                velocity: new THREE.Vector3(\n                    (Math.random() - 0.5) * 1.5,\n                    (Math.random() - 0.5) * 1.5,\n                    (Math.random() - 0.5) * 1.5\n                ),\n                originalPos: particle.position.clone() // è®°å½•åŸå§‹ä½ç½®ç”¨äºå¼¹æ€§å›å½’ï¼ˆå¯é€‰ï¼Œè¿™é‡Œä¸»è¦ç”¨ä½œå‚è€ƒï¼‰\n            };\n\n            scene.add(particle);\n            particles.push(particle);\n        }\n\n        // --- 3. åˆ›å»ºåŠ¨æ€è¿çº¿ç³»ç»Ÿ (BufferGeometry) ---\n        // æˆ‘ä»¬é¢„å…ˆåˆ†é…ä¸€ä¸ªè¶³å¤Ÿå¤§çš„ç¼“å†²åŒºæ¥å­˜å‚¨çº¿æ®µé¡¶ç‚¹\n        const linesGeometry = new THREE.BufferGeometry();\n        const linesMaterial = new THREE.LineBasicMaterial({ \n            color: 0xffffff, \n            transparent: true, \n            opacity: 5, // çº¿æ¡æ·¡æ·¡çš„ï¼Œä¸æŠ¢çœ¼\n            vertexColors: false\n        });\n\n        // é¢„ä¼°æœ€å¤§çº¿æ®µæ•° (ç²’å­æ•° * ç²’å­æ•° / 2) - å®é™…ä¸Šä¼šå°‘å¾ˆå¤š\n        const maxConnections = particleCount * particleCount; \n        const positions = new Float32Array(maxConnections * 3); // æ¯ä¸ªè¿æ¥2ä¸ªç‚¹ï¼Œæ¯ä¸ªç‚¹3ä¸ªåæ ‡... ç®€åŒ–å¤„ç†ç›´æ¥å¼€å¤§ç‚¹\n        linesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n\n        const linesMesh = new THREE.LineSegments(linesGeometry, linesMaterial);\n        scene.add(linesMesh);\n\n        // --- 4. äº¤äº’é€»è¾‘ ---\n        const mouse = new THREE.Vector2(9999, 9999); // åˆå§‹åœ¨å±å¹•å¤–\n        const raycaster = new THREE.Raycaster();\n        const mousePlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // ç”¨äºè®¡ç®—é¼ æ ‡åœ¨3Dç©ºé—´çš„å¤§è‡´ä½ç½®\n        const mousePosition3D = new THREE.Vector3();\n\n        document.addEventListener('mousemove', onMouseMove, false);\n\n        function onMouseMove(event) {\n            event.preventDefault();\n            // å½’ä¸€åŒ–é¼ æ ‡åæ ‡\n            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n\n            // ç®€å•çš„æŠ•å½±ï¼Œè·å–é¼ æ ‡åœ¨ Z=0 å¹³é¢ä¸Šçš„ 3D åæ ‡\n            raycaster.setFromCamera(mouse, camera);\n            raycaster.ray.intersectPlane(mousePlane, mousePosition3D);\n        }\n\n        // --- 5. åŠ¨ç”»å¾ªç¯ ---\n        function animate() {\n            requestAnimationFrame(animate);\n\n            let vertexIndex = 0;\n            const positions = linesMesh.geometry.attributes.position.array;\n\n            // A. æ›´æ–°ç²’å­ä½ç½®\n            for (let i = 0; i < particleCount; i++) {\n                const p = particles[i];\n                const v = p.userData.velocity;\n\n                // 1. åŸºç¡€ç§»åŠ¨\n                p.position.add(v);\n\n                // 2. è¾¹ç•Œåå¼¹ (ä¿æŒåœ¨ç›’å­å†…)\n                if (p.position.x < -range || p.position.x > range) v.x = -v.x;\n                if (p.position.y < -range || p.position.y > range) v.y = -v.y;\n                if (p.position.z < -range || p.position.z > range) v.z = -v.z;\n\n                // 3. é¼ æ ‡äº¤äº’ (æ–¥åŠ›)\n                // è®¡ç®—ç²’å­ä¸é¼ æ ‡3Dä½ç½®çš„è·ç¦»\n                const distToMouse = p.position.distanceTo(mousePosition3D);\n                const repelRange = 150;\n                \n                if (distToMouse < repelRange) {\n                    const repelForce = new THREE.Vector3().subVectors(p.position, mousePosition3D).normalize();\n                    // è·ç¦»è¶Šè¿‘ï¼Œæ–¥åŠ›è¶Šå¤§\n                    const forceMagnitude = (repelRange - distToMouse) * 0.05; \n                    p.position.add(repelForce.multiplyScalar(forceMagnitude));\n                }\n\n                // 4. ç¼“æ…¢è‡ªè½¬æ–¹å—\n                p.rotation.x += 0.02;\n                p.rotation.y += 0.02;\n            }\n\n            // B. æ›´æ–°è¿çº¿\n            // åŒé‡å¾ªç¯æ£€æµ‹è·ç¦» (O(n^2) ä½† n=150 æ—¶æ€§èƒ½è‰¯å¥½)\n            for (let i = 0; i < particleCount; i++) {\n                for (let j = i + 1; j < particleCount; j++) {\n                    const p1 = particles[i];\n                    const p2 = particles[j];\n\n                    const dist = p1.position.distanceTo(p2.position);\n\n                    if (dist < connectionDistance) {\n                        // å¦‚æœè·ç¦»å°äºé˜ˆå€¼ï¼Œæ·»åŠ çº¿æ®µé¡¶ç‚¹\n                        positions[vertexIndex++] = p1.position.x;\n                        positions[vertexIndex++] = p1.position.y;\n                        positions[vertexIndex++] = p1.position.z;\n\n                        positions[vertexIndex++] = p2.position.x;\n                        positions[vertexIndex++] = p2.position.y;\n                        positions[vertexIndex++] = p2.position.z;\n                    }\n                }\n            }\n\n            // æ›´æ–°å‡ ä½•ä½“ç»˜åˆ¶èŒƒå›´\n            linesMesh.geometry.setDrawRange(0, vertexIndex / 3);\n            linesMesh.geometry.attributes.position.needsUpdate = true;\n\n            // C. åœºæ™¯ç¼“æ…¢æ—‹è½¬\n            scene.rotation.y += 0.001;\n            scene.rotation.x += 0.0005;\n\n            renderer.render(scene, camera);\n        }\n\n        // çª—å£å¤§å°è°ƒæ•´\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n\n        animate();\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 18,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Gray-Scott Reaction Diffusion</title>\n    <style>\n        body { margin: 0; padding: 0; overflow: hidden; background: #000; }\n        canvas { display: block; }\n        #info {\n            position: absolute;\n            bottom: 20px;\n            left: 20px;\n            color: rgba(255, 255, 255, 0.6);\n            font-family: 'Courier New', monospace;\n            font-size: 12px;\n            pointer-events: none;\n            background: rgba(0,0,0,0.5);\n            padding: 5px 10px;\n            border-radius: 4px;\n        }\n    </style>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js\"></script>\n</head>\n<body>\n    <div id=\"info\">Type: Gray-Scott Model | Feed: 0.055 | Kill: 0.062 | Interaction: Mouse Drag</div>\n    <script>\n        // æ ¸å¿ƒå‚æ•°ï¼šå†³å®šå›¾æ¡ˆçš„å½¢æ€ï¼ˆçŠç‘šçŠ¶ã€ç‚¹çŠ¶ã€è¿·å®«çŠ¶ç­‰ï¼‰\n        // è¿™æ˜¯ä¸€ä¸ªç»å…¸çš„ \"Coral\" å‚æ•°é›†\n        let feed = 0.055;\n        let kill = 0.062;\n        \n        let da = 1.0; // A çš„æ‰©æ•£ç‡\n        let db = 0.5; // B çš„æ‰©æ•£ç‡\n        let dt = 1.0; // æ—¶é—´æ­¥é•¿\n\n        let grid;\n        let next;\n        \n        // ä¸ºäº†æ€§èƒ½ï¼Œæˆ‘ä»¬åœ¨è¾ƒå°çš„ç½‘æ ¼ä¸Šè®¡ç®—ï¼Œç„¶åæ”¾å¤§æ˜¾ç¤º\n        // è¿™æ ·æ—¢èƒ½ä¿è¯ 60FPSï¼Œåˆèƒ½äº§ç”Ÿä¸€ç§å¤å¤çš„åƒç´ ç¾æ„Ÿ\n        let gridW, gridH;\n        const scaleFactor = 4; \n\n        function setup() {\n            createCanvas(windowWidth, windowHeight);\n            pixelDensity(1);\n            \n            gridW = Math.floor(width / scaleFactor);\n            gridH = Math.floor(height / scaleFactor);\n            \n            grid = [];\n            next = [];\n\n            // åˆå§‹åŒ–ç½‘æ ¼\n            for (let x = 0; x < gridW; x++) {\n                grid[x] = [];\n                next[x] = [];\n                for (let y = 0; y < gridH; y++) {\n                    // åˆå§‹çŠ¶æ€ï¼šå……æ»¡ Aï¼Œæ²¡æœ‰ B\n                    grid[x][y] = { a: 1, b: 0 };\n                    next[x][y] = { a: 1, b: 0 };\n                }\n            }\n\n            // åœ¨ä¸­å¿ƒæ’’å…¥ä¸€äº› B ç§å­ï¼Œå¯åŠ¨ååº”\n            seed(Math.floor(gridW / 2), Math.floor(gridH / 2), 10);\n        }\n\n        function seed(x, y, r) {\n            for (let i = x - r; i < x + r; i++) {\n                for (let j = y - r; j < y + r; j++) {\n                    if (i >= 0 && i < gridW && j >= 0 && j < gridH) {\n                        grid[i][j].b = 1;\n                    }\n                }\n            }\n        }\n\n        function draw() {\n            background(0);\n\n            // æ¯ä¸€å¸§è¿›è¡Œå¤šæ¬¡è¿­ä»£è®¡ç®—ï¼ŒåŠ é€Ÿæ¨¡æ‹Ÿè¿‡ç¨‹\n            // è®©ååº”çœ‹èµ·æ¥æ›´åƒæ˜¯åœ¨â€œæ²¸è…¾â€\n            for (let i = 0; i < 12; i++) {\n                updateGrid();\n            }\n\n            drawGrid();\n            \n            // äº¤äº’ï¼šé¼ æ ‡æ‹–åŠ¨æ’’å…¥åŒ–å­¦ç‰©è´¨ B\n            if (mouseIsPressed) {\n                let gridMouseX = Math.floor(mouseX / scaleFactor);\n                let gridMouseY = Math.floor(mouseY / scaleFactor);\n                seed(gridMouseX, gridMouseY, 4);\n            }\n        }\n\n        // æ ¸å¿ƒç®—æ³•ï¼šæ‹‰æ™®æ‹‰æ–¯ç®—å­ä¸ååº”æ‰©æ•£å…¬å¼\n        function updateGrid() {\n            for (let x = 1; x < gridW - 1; x++) {\n                for (let y = 1; y < gridH - 1; y++) {\n                    let a = grid[x][y].a;\n                    let b = grid[x][y].b;\n\n                    // è®¡ç®—æ‹‰æ™®æ‹‰æ–¯å·ç§¯ (Laplacian Convolution)\n                    // ç®€å•çš„ 3x3 å·ç§¯æ ¸ï¼šä¸­å¿ƒ -1ï¼Œä¸Šä¸‹å·¦å³ 0.2ï¼Œå¯¹è§’çº¿ 0.05\n                    let laplaceA = 0;\n                    let laplaceB = 0;\n\n                    laplaceA += grid[x][y].a * -1;\n                    laplaceA += grid[x - 1][y].a * 0.2;\n                    laplaceA += grid[x + 1][y].a * 0.2;\n                    laplaceA += grid[x][y - 1].a * 0.2;\n                    laplaceA += grid[x][y + 1].a * 0.2;\n                    laplaceA += grid[x - 1][y - 1].a * 0.05;\n                    laplaceA += grid[x + 1][y - 1].a * 0.05;\n                    laplaceA += grid[x - 1][y + 1].a * 0.05;\n                    laplaceA += grid[x + 1][y + 1].a * 0.05;\n\n                    laplaceB += grid[x][y].b * -1;\n                    laplaceB += grid[x - 1][y].b * 0.2;\n                    laplaceB += grid[x + 1][y].b * 0.2;\n                    laplaceB += grid[x][y - 1].b * 0.2;\n                    laplaceB += grid[x][y + 1].b * 0.2;\n                    laplaceB += grid[x - 1][y - 1].b * 0.05;\n                    laplaceB += grid[x + 1][y - 1].b * 0.05;\n                    laplaceB += grid[x - 1][y + 1].b * 0.05;\n                    laplaceB += grid[x + 1][y + 1].b * 0.05;\n\n                    // Gray-Scott å…¬å¼\n                    // newA = A + (Da * lapA - A * B * B + feed * (1 - A)) * dt\n                    // newB = B + (Db * lapB + A * B * B - (k + feed) * B) * dt\n                    let abb = a * b * b;\n                    \n                    next[x][y].a = a + (da * laplaceA - abb + feed * (1 - a)) * dt;\n                    next[x][y].b = b + (db * laplaceB + abb - (kill + feed) * b) * dt;\n\n                    // é™åˆ¶å€¼åœ¨ 0-1 ä¹‹é—´\n                    next[x][y].a = constrain(next[x][y].a, 0, 1);\n                    next[x][y].b = constrain(next[x][y].b, 0, 1);\n                }\n            }\n\n            // äº¤æ¢ç¼“å†²åŒº (Ping-pong buffer)\n            let temp = grid;\n            grid = next;\n            next = temp;\n        }\n\n        function drawGrid() {\n            loadPixels();\n            \n            // ç›´æ¥æ“ä½œåƒç´ æ•°ç»„ï¼Œæ¯” rect() å¿«å¾—å¤š\n            for (let x = 0; x < gridW; x++) {\n                for (let y = 0; y < gridH; y++) {\n                    let cell = grid[x][y];\n                    \n                    // è§†è§‰é­”æ³•ï¼šæ ¹æ® A å’Œ B çš„å·®å€¼è®¡ç®—é¢œè‰²\n                    // c å€¼å†³å®šäº†è¯¥åƒç´ æ˜¯ \"ç‰©è´¨\" è¿˜æ˜¯ \"èƒŒæ™¯\"\n                    let c = Math.floor((cell.a - cell.b) * 255);\n                    c = constrain(c, 0, 255);\n\n                    // åªæœ‰å½“æœ‰æœ‰è¶£çš„åŒ–å­¦ååº”æ—¶æ‰æ¸²æŸ“é¢œè‰²\n                    if (c < 255) {\n                         // åƒç´ ç´¢å¼•è®¡ç®— (è€ƒè™‘åˆ° scaleFactor)\n                        // è¿™é‡Œä¸ºäº†ç®€åŒ–å’Œæ€§èƒ½ï¼Œæˆ‘ä»¬ä¸åšå¤æ‚çš„æ’å€¼ï¼Œè€Œæ˜¯ç®€å•çš„å—çŠ¶æ¸²æŸ“\n                        // ä½†ç”±äºæˆ‘ä»¬æ“ä½œçš„æ˜¯ canvas çš„åƒç´ ï¼Œæˆ‘ä»¬éœ€è¦å¡«å…… scaleFactor x scaleFactor çš„åŒºåŸŸ\n                        // ä¸ºäº†ä»£ç ç®€æ´æ€§ï¼Œè¿™é‡Œæˆ‘ä»¬ç”¨ä¸€ç§ trickï¼š\n                        // æˆ‘ä»¬ç›´æ¥æŠŠè®¡ç®—ç½‘æ ¼ç”»åœ¨ canvas ä¸Šï¼Œè®©æµè§ˆå™¨å¤„ç†ç¼©æ”¾ï¼ˆå¦‚æœ canvas å°ºå¯¸è®¾ç½®å¾—å½“ï¼‰\n                        // æˆ–è€…æˆ‘ä»¬æ‰‹åŠ¨å¡«å……åƒç´ ã€‚\n                        \n                        // æ›´å¥½çš„è§†è§‰æ–¹æ¡ˆï¼šæ ¹æ® B çš„æµ“åº¦æ˜ å°„ HSB é¢œè‰²\n                        // è®©æˆ‘ä»¬åšä¸€ä¸ªè¿·å¹»çš„éœ“è™¹æ˜ å°„\n                        \n                        let r, g, b;\n                        let val = cell.b; // å…³æ³¨ç‰©è´¨ B\n                        \n                        if (val < 0.2) {\n                            // èƒŒæ™¯æ·±è‰²\n                            r = 0; g = 0; b = 0;\n                        } else {\n                            // åŠ¨æ€é¢œè‰²ï¼šæ ¹æ®æµ“åº¦å’Œä½ç½®äº§ç”Ÿæ¸å˜\n                            // ä½¿ç”¨æ­£å¼¦å‡½æ•°åˆ›é€ å¾ªç¯çš„éœ“è™¹è‰²\n                            r = Math.floor(255 * Math.sin(val * 5 + 1));\n                            g = Math.floor(255 * Math.sin(val * 5 + 2));\n                            b = Math.floor(255 * Math.sin(val * 5 + 4));\n                        }\n\n                        // å†™å…¥åƒç´ æ•°æ® (scaleFactor åŒºåŸŸå¡«å……)\n                        for (let i = 0; i < scaleFactor; i++) {\n                            for (let j = 0; j < scaleFactor; j++) {\n                                let px = (x * scaleFactor + i);\n                                let py = (y * scaleFactor + j);\n                                if (px < width && py < height) {\n                                    let index = (px + py * width) * 4;\n                                    pixels[index + 0] = r;\n                                    pixels[index + 1] = g;\n                                    pixels[index + 2] = b;\n                                    pixels[index + 3] = 255;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            updatePixels();\n        }\n\n        function windowResized() {\n            resizeCanvas(windowWidth, windowHeight);\n            setup(); // é‡ç½®ä»¥é€‚åº”æ–°å°ºå¯¸\n        }\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 19,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>ç–¯ç‹‚å…ƒèƒè‡ªåŠ¨æœº - å¤šç»´åº¦è§†è§‰å®éªŒ</title>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.js\"></script>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n            background: #000;\n        }\n        #info {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            color: white;\n            font-family: 'Courier New', monospace;\n            font-size: 12px;\n            z-index: 1000;\n            background: rgba(0,0,0,0.7);\n            padding: 10px;\n            border-radius: 5px;\n            pointer-events: none;\n        }\n        .glow {\n            text-shadow: 0 0 10px #00ff00;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"info\">\n        <div class=\"glow\">ğŸ§¬ å¤šç»´å…ƒèƒè‡ªåŠ¨æœºå®éªŒå®¤ ğŸ§¬</div>\n        <div>è§„åˆ™: è‡ªå®šä¹‰æ··æ²Œç”Ÿå‘½æ¸¸æˆ</div>\n        <div>é¼ æ ‡: åˆ›é€ ç”Ÿå‘½</div>\n        <div>ç‚¹å‡»: åˆ‡æ¢æ¨¡å¼</div>\n        <div>ç©ºæ ¼: é‡ç½®å®‡å®™</div>\n        <div id=\"stats\"></div>\n    </div>\n\n    <script>\n        // å¤šå±‚å…ƒèƒè‡ªåŠ¨æœºç³»ç»Ÿ\n        let grid, nextGrid;\n        let resolution = 4;\n        let cols, rows;\n        let mode = 0;\n        let hueOffset = 0;\n        let particles = [];\n        let trails = [];\n        let generation = 0;\n        let populationHistory = [];\n        \n        // ä¸åŒçš„CAè§„åˆ™é›†\n        const rules = [\n            { name: \"æ··æ²Œç”Ÿå‘½\", birth: [3], survive: [2, 3] },\n            { name: \"é«˜ç”Ÿå‘½\", birth: [3, 6], survive: [2, 3] },\n            { name: \"è¿·å®«\", birth: [3], survive: [1, 2, 3, 4, 5] },\n            { name: \"çŠç‘š\", birth: [3], survive: [4, 5, 6, 7, 8] },\n            { name: \"é‡å­æ€\", birth: [2, 3, 4], survive: [3, 4, 5] }\n        ];\n        \n        let currentRule = 0;\n\n        function setup() {\n            createCanvas(windowWidth, windowHeight);\n            cols = floor(width / resolution);\n            rows = floor(height / resolution);\n            \n            grid = make2DArray(cols, rows);\n            nextGrid = make2DArray(cols, rows);\n            \n            // åˆå§‹åŒ–éšæœºçŠ¶æ€\n            initializeUniverse();\n            \n            colorMode(HSB, 360, 100, 100, 100);\n            frameRate(30);\n        }\n\n        function draw() {\n            // åˆ›é€ å¤šå±‚è§†è§‰æ•ˆæœ\n            background(0, 0, 0, 15); // æ‹–å°¾æ•ˆæœ\n            \n            generation++;\n            hueOffset = (hueOffset + 0.5) % 360;\n            \n            let population = 0;\n            \n            // è®¡ç®—ä¸‹ä¸€ä»£\n            for (let i = 0; i < cols; i++) {\n                for (let j = 0; j < rows; j++) {\n                    let state = grid[i][j];\n                    let neighbors = countNeighbors(grid, i, j);\n                    \n                    let rule = rules[currentRule];\n                    \n                    if (state == 0 && rule.birth.includes(neighbors)) {\n                        nextGrid[i][j] = 1;\n                    } else if (state == 1 && rule.survive.includes(neighbors)) {\n                        nextGrid[i][j] = 1;\n                    } else {\n                        nextGrid[i][j] = 0;\n                    }\n                    \n                    // ç»˜åˆ¶å½“å‰ç»†èƒ\n                    if (grid[i][j] == 1) {\n                        population++;\n                        \n                        // æ ¹æ®é‚»å±…æ•°é‡å˜åŒ–é¢œè‰²\n                        let hue = (hueOffset + neighbors * 40 + i * 0.5) % 360;\n                        let brightness = map(neighbors, 0, 8, 50, 100);\n                        let saturation = map(sin(frameCount * 0.02 + i * 0.1), -1, 1, 60, 100);\n                        \n                        fill(hue, saturation, brightness, 80);\n                        noStroke();\n                        \n                        let x = i * resolution;\n                        let y = j * resolution;\n                        let size = resolution + sin(frameCount * 0.05 + i + j) * 2;\n                        \n                        // ä¸åŒæ¨¡å¼ä¸åŒå½¢çŠ¶\n                        if (mode == 0) {\n                            rect(x, y, size, size);\n                        } else if (mode == 1) {\n                            ellipse(x + resolution/2, y + resolution/2, size, size);\n                        } else if (mode == 2) {\n                            push();\n                            translate(x + resolution/2, y + resolution/2);\n                            rotate(frameCount * 0.02 + i + j);\n                            rectMode(CENTER);\n                            rect(0, 0, size, size);\n                            pop();\n                        }\n                        \n                        // æ·»åŠ å‘å…‰æ•ˆæœ\n                        if (neighbors >= 6) {\n                            drawingContext.shadowBlur = 20;\n                            drawingContext.shadowColor = color(hue, 100, 100);\n                            fill(hue, 100, 100, 50);\n                            ellipse(x + resolution/2, y + resolution/2, size * 1.5, size * 1.5);\n                            drawingContext.shadowBlur = 0;\n                            \n                            // åˆ›å»ºç²’å­\n                            if (random(1) < 0.05) {\n                                particles.push(new Particle(x, y, hue));\n                            }\n                        }\n                    }\n                }\n            }\n            \n            // æ›´æ–°ç½‘æ ¼\n            let temp = grid;\n            grid = nextGrid;\n            nextGrid = temp;\n            \n            // ç»˜åˆ¶ç²’å­ç³»ç»Ÿ\n            for (let i = particles.length - 1; i >= 0; i--) {\n                particles[i].update();\n                particles[i].show();\n                if (particles[i].isDead()) {\n                    particles.splice(i, 1);\n                }\n            }\n            \n            // ç»˜åˆ¶è¿æ¥çº¿ï¼ˆå±•ç¤ºç»†èƒé—´çš„\"é‡å­çº ç¼ \"ï¼‰\n            if (mode == 2) {\n                drawConnections();\n            }\n            \n            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯\n            populationHistory.push(population);\n            if (populationHistory.length > 100) {\n                populationHistory.shift();\n            }\n            \n            // ç»˜åˆ¶äººå£å›¾è¡¨\n            drawPopulationGraph();\n            \n            // æ›´æ–°ä¿¡æ¯\n            document.getElementById('stats').innerHTML = `\n                ä»£æ•°: ${generation}<br>\n                äººå£: ${population}<br>\n                æ¨¡å¼: ${mode}<br>\n                è§„åˆ™: ${rules[currentRule].name}<br>\n                ç²’å­: ${particles.length}\n            `;\n            \n            // è‡ªåŠ¨é‡ç½®é˜²æ­¢æ­»äº¡\n            if (population < 10 && generation > 50) {\n                initializeUniverse();\n                generation = 0;\n            }\n        }\n\n        function drawConnections() {\n            stroke(180, 80, 80, 20);\n            strokeWeight(1);\n            \n            let connectionCount = 0;\n            for (let i = 0; i < cols && connectionCount < 200; i += 3) {\n                for (let j = 0; j < rows && connectionCount < 200; j += 3) {\n                    if (grid[i][j] == 1) {\n                        // å¯»æ‰¾é™„è¿‘çš„æ´»ç»†èƒ\n                        for (let di = -5; di <= 5; di++) {\n                            for (let dj = -5; dj <= 5; dj++) {\n                                let ni = (i + di + cols) % cols;\n                                let nj = (j + dj + rows) % rows;\n                                if (grid[ni][nj] == 1 && random(1) < 0.1) {\n                                    line(i * resolution, j * resolution, \n                                         ni * resolution, nj * resolution);\n                                    connectionCount++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        function drawPopulationGraph() {\n            push();\n            translate(width - 210, height - 110);\n            \n            // èƒŒæ™¯\n            fill(0, 0, 0, 50);\n            noStroke();\n            rect(0, 0, 200, 100);\n            \n            // ç»˜åˆ¶å›¾è¡¨\n            stroke(120, 100, 100, 80);\n            strokeWeight(2);\n            noFill();\n            beginShape();\n            for (let i = 0; i < populationHistory.length; i++) {\n                let x = map(i, 0, 100, 0, 200);\n                let y = map(populationHistory[i], 0, cols * rows / 4, 100, 0);\n                vertex(x, y);\n            }\n            endShape();\n            pop();\n        }\n\n        function countNeighbors(grid, x, y) {\n            let sum = 0;\n            for (let i = -1; i <= 1; i++) {\n                for (let j = -1; j <= 1; j++) {\n                    let col = (x + i + cols) % cols;\n                    let row = (y + j + rows) % rows;\n                    sum += grid[col][row];\n                }\n            }\n            sum -= grid[x][y];\n            return sum;\n        }\n\n        function make2DArray(cols, rows) {\n            let arr = new Array(cols);\n            for (let i = 0; i < arr.length; i++) {\n                arr[i] = new Array(rows).fill(0);\n            }\n            return arr;\n        }\n\n        function initializeUniverse() {\n            // åˆ›é€ å¤šä¸ªéšæœºç”Ÿå‘½ä¸­å¿ƒ\n            for (let i = 0; i < cols; i++) {\n                for (let j = 0; j < rows; j++) {\n                    grid[i][j] = 0;\n                }\n            }\n            \n            // æ·»åŠ å¤šä¸ªç”Ÿå‘½ç§å­\n            for (let n = 0; n < 15; n++) {\n                let cx = floor(random(cols));\n                let cy = floor(random(rows));\n                let size = floor(random(5, 15));\n                \n                for (let i = -size; i < size; i++) {\n                    for (let j = -size; j < size; j++) {\n                        if (random(1) < 0.5) {\n                            let x = (cx + i + cols) % cols;\n                            let y = (cy + j + rows) % rows;\n                            grid[x][y] = 1;\n                        }\n                    }\n                }\n            }\n            \n            populationHistory = [];\n        }\n\n        // ç²’å­ç±»\n        class Particle {\n            constructor(x, y, hue) {\n                this.pos = createVector(x, y);\n                this.vel = p5.Vector.random2D().mult(random(1, 3));\n                this.acc = createVector(0, 0);\n                this.lifespan = 255;\n                this.hue = hue;\n                this.size = random(2, 6);\n            }\n            \n            update() {\n                this.vel.add(this.acc);\n                this.pos.add(this.vel);\n                this.acc.mult(0);\n                this.lifespan -= 3;\n                this.vel.mult(0.98);\n                \n                // æ·»åŠ åœºåŠ›\n                let center = createVector(width/2, height/2);\n                let force = p5.Vector.sub(center, this.pos);\n                force.setMag(0.05);\n                this.acc.add(force);\n            }\n            \n            show() {\n                noStroke();\n                fill(this.hue, 100, 100, map(this.lifespan, 0, 255, 0, 100));\n                ellipse(this.pos.x, this.pos.y, this.size, this.size);\n                \n                // å‘å…‰æ•ˆæœ\n                drawingContext.shadowBlur = 10;\n                drawingContext.shadowColor = color(this.hue, 100, 100);\n                ellipse(this.pos.x, this.pos.y, this.size * 0.5, this.size * 0.5);\n                drawingContext.shadowBlur = 0;\n            }\n            \n            isDead() {\n                return this.lifespan < 0;\n            }\n        }\n\n        // é¼ æ ‡äº¤äº’\n        function mouseDragged() {\n            let i = floor(mouseX / resolution);\n            let j = floor(mouseY / resolution);\n            \n            if (i >= 0 && i < cols && j >= 0 && j < rows) {\n                // åˆ›å»ºç”Ÿå‘½å›¢\n                for (let di = -3; di <= 3; di++) {\n                    for (let dj = -3; dj <= 3; dj++) {\n                        let ni = (i + di + cols) % cols;\n                        let nj = (j + dj + rows) % rows;\n                        if (random(1) < 0.7) {\n                            grid[ni][nj] = 1;\n                        }\n                    }\n                }\n            }\n        }\n\n        function mousePressed() {\n            mode = (mode + 1) % 3;\n        }\n\n        function keyPressed() {\n            if (key === ' ') {\n                initializeUniverse();\n                generation = 0;\n            } else if (key === 'r' || key === 'R') {\n                currentRule = (currentRule + 1) % rules.length;\n            }\n        }\n\n        function windowResized() {\n            resizeCanvas(windowWidth, windowHeight);\n            cols = floor(width / resolution);\n            rows = floor(height / resolution);\n            grid = make2DArray(cols, rows);\n            nextGrid = make2DArray(cols, rows);\n            initializeUniverse();\n        }\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 20,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Autonomous System: Self-Running Grid</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #020202; /* æ¥è¿‘çº¯é»‘ */\n            font-family: 'Courier New', Courier, monospace;\n        }\n        canvas {\n            display: block;\n        }\n        #ui {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            color: #00ffcc;\n            pointer-events: none;\n            background: rgba(0, 0, 0, 0.6);\n            padding: 15px;\n            border-left: 2px solid #00ffcc;\n            font-size: 12px;\n            line-height: 1.5;\n        }\n        .blink {\n            animation: blinker 1s linear infinite;\n        }\n        @keyframes blinker {\n            50% { opacity: 0; }\n        }\n    </style>\n</head>\n<body>\n\n<div id=\"ui\">\n    <div>SYSTEM: AUTONOMOUS GRID</div>\n    <div>INPUT: NONE (ISOLATED)</div>\n    <div>DRIVER: STOCHASTIC PULSE</div>\n    <div>STATUS: <span class=\"blink\">PROCESSING...</span></div>\n</div>\n\n<canvas id=\"canvas\"></canvas>\n\n<script>\n    const canvas = document.getElementById('canvas');\n    const ctx = canvas.getContext('2d');\n\n    let width, height;\n    let nodes = [];\n    \n    // --- å‚æ•°é…ç½® ---\n    const GRID_SPACING = 35; // ç½‘æ ¼æ›´ç´§å¯†ä¸€ç‚¹\n    const WAVE_SPEED = 0.02;  // ä¼ å¯¼é€Ÿåº¦åŠ å¿«ï¼Œå¢åŠ æ´»è·ƒæ„Ÿ\n    const DECAY_RATE = 0.99; // èƒ½é‡è¡°å‡\n    const IGNITION_RATE = 0.005; // è‡ªå‘ç‚¹ç«æ¦‚ç‡ (0.5%) - ç³»ç»Ÿçš„â€œå¿ƒç‡â€\n\n    // èŠ‚ç‚¹ç±»\n    class Node {\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n            this.baseX = x;\n            this.baseY = y;\n            this.energy = 0;\n            this.nextEnergy = 0;\n        }\n\n        update() {\n            // --- æ ¸å¿ƒä¿®æ”¹ï¼šå†…é©±åŠ› ---\n            // æ¯ä¸ªèŠ‚ç‚¹æ¯ä¸€å¸§éƒ½æœ‰æå°çš„æ¦‚ç‡â€œè‡ªå‘è§‰é†’â€\n            // è¿™æ¨¡æ‹Ÿäº†ç³»ç»Ÿå†…éƒ¨çš„æ•°æ®åŒ…çªå‘æˆ–ç¥ç»å…ƒæ”¾ç”µ\n            if (Math.random() < IGNITION_RATE) {\n                this.energy = 1.0; // ç¬é—´å……æ»¡èƒ½é‡\n            }\n\n            // èƒ½é‡è¡°å‡\n            this.energy *= DECAY_RATE;\n            \n            // æ™¶ä½“å¾®åŠ¨ï¼šèƒ½é‡å¯¼è‡´ä½ç½®è½»å¾®åç§»\n            this.x = this.baseX + (Math.random() - 0.5) * (this.energy * 2);\n            this.y = this.baseY + (Math.random() - 0.5) * (this.energy * 2);\n        }\n        \n        draw() {\n            if (this.energy < 0.05) return; \n\n            ctx.beginPath();\n            // é¢œè‰²é€»è¾‘ï¼šé«˜èƒ½é‡ä¸ºç™½ï¼Œä¸­èƒ½é‡ä¸ºé’ï¼Œä½èƒ½é‡ä¸ºæ·±è“\n            const r = Math.floor(this.energy * 20);\n            const g = Math.floor(this.energy * 255);\n            const b = Math.floor(150 + this.energy * 105);\n            const alpha = this.energy;\n            \n            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;\n            \n            // èŠ‚ç‚¹å¤§å°éšèƒ½é‡è„‰åŠ¨\n            const size = 1.5 + this.energy * 2.5;\n            ctx.arc(this.x, this.y, size, 0, Math.PI * 2);\n            ctx.fill();\n        }\n    }\n\n    function init() {\n        width = canvas.width = window.innerWidth;\n        height = canvas.height = window.innerHeight;\n        nodes = [];\n\n        // æ„å»ºæ™¶ä½“ç½‘æ ¼\n        for (let y = 0; y < height; y += GRID_SPACING) {\n            for (let x = 0; x < width; x += GRID_SPACING) {\n                nodes.push(new Node(x, y));\n            }\n        }\n    }\n\n    // æ³¢åŠ¨ä¼ å¯¼é€»è¾‘ (ä¿æŒä¸å˜ï¼Œè¿™æ˜¯â€œèœ‚ç¾¤å…±è¯†â€çš„æ ¸å¿ƒ)\n    function propagate() {\n        const cols = Math.ceil(width / GRID_SPACING);\n        \n        for (let i = 0; i < nodes.length; i++) {\n            let node = nodes[i];\n            node.nextEnergy = node.energy;\n\n            let neighbors = [i - 1, i + 1, i - cols, i + cols];\n\n            neighbors.forEach(nIndex => {\n                if (nodes[nIndex]) {\n                    let neighbor = nodes[nIndex];\n                    // è·ç¦»æ£€æŸ¥\n                    if (Math.abs(node.baseX - neighbor.baseX) <= GRID_SPACING && \n                        Math.abs(node.baseY - neighbor.baseY) <= GRID_SPACING) {\n                        \n                        // æ‰©æ•£é€»è¾‘ï¼šé«˜èƒ½é‡æµå‘ä½èƒ½é‡\n                        let diff = neighbor.energy - node.energy;\n                        node.nextEnergy += diff * WAVE_SPEED;\n                    }\n                }\n            });\n        }\n\n        nodes.forEach(node => {\n            node.energy = node.nextEnergy;\n        });\n    }\n\n    function animate() {\n        // ä½¿ç”¨åŠé€æ˜é»‘è‰²è¦†ç›–ï¼Œåˆ¶é€ è½»å¾®çš„â€œæ‹–å°¾â€æ•ˆæœï¼Œå¢åŠ æµåŠ¨æ„Ÿ\n        ctx.fillStyle = 'rgba(2, 2, 2, 0.3)';\n        ctx.fillRect(0, 0, width, height);\n\n        propagate();\n\n        ctx.lineWidth = 1;\n        const cols = Math.ceil(width / GRID_SPACING);\n        \n        for (let i = 0; i < nodes.length; i++) {\n            let node = nodes[i];\n            node.update();\n\n            // ç»˜åˆ¶è¿çº¿\n            let right = nodes[i + 1];\n            let down = nodes[i + cols];\n\n            // åªæœ‰å½“èƒ½é‡è¶³å¤Ÿå¼ºæ—¶ï¼Œè¿æ¥æ‰æ˜¾ç° (æ¨¡æ‹Ÿæ•°æ®é€šè·¯è¢«ç‚¹äº®)\n            const threshold = 0.1;\n\n            if (right && Math.abs(node.baseX - right.baseX) <= GRID_SPACING) {\n                let avgEnergy = (node.energy + right.energy) / 2;\n                if (avgEnergy > threshold) {\n                    ctx.strokeStyle = `rgba(0, 255, 204, ${avgEnergy * 0.6})`;\n                    ctx.beginPath();\n                    ctx.moveTo(node.x, node.y);\n                    ctx.lineTo(right.x, right.y);\n                    ctx.stroke();\n                }\n            }\n            if (down && Math.abs(node.baseY - down.baseY) <= GRID_SPACING) {\n                let avgEnergy = (node.energy + down.energy) / 2;\n                if (avgEnergy > threshold) {\n                    ctx.strokeStyle = `rgba(0, 255, 204, ${avgEnergy * 0.6})`;\n                    ctx.beginPath();\n                    ctx.moveTo(node.x, node.y);\n                    ctx.lineTo(down.x, down.y);\n                    ctx.stroke();\n                }\n            }\n            \n            node.draw();\n        }\n\n        requestAnimationFrame(animate);\n    }\n\n    window.addEventListener('resize', init);\n    init();\n    animate();\n</script>\n</body>\n</html>"
    },
    {
        "åºå·": 21,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Interactive DNA Shader</title>\n    <style>\n        body { margin: 0; overflow: hidden; background: #000; cursor: move; }\n        canvas { display: block; width: 100vw; height: 100vh; }\n        #tips {\n            position: absolute;\n            bottom: 20px;\n            left: 50%;\n            transform: translateX(-50%);\n            color: rgba(255,255,255,0.5);\n            font-family: sans-serif;\n            font-size: 12px;\n            pointer-events: none;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"tips\">æ‹–åŠ¨é¼ æ ‡æ—‹è½¬è§†è§’</div>\n    <canvas id=\"glcanvas\"></canvas>\n\n    <script id=\"vs\" type=\"x-shader/x-vertex\">\n        attribute vec2 position;\n        void main() {\n            gl_Position = vec4(position, 0.0, 1.0);\n        }\n    </script>\n\n    <script id=\"fs\" type=\"x-shader/x-fragment\">\n        precision highp float;\n        uniform vec2 u_resolution;\n        uniform float u_time;\n        uniform vec2 u_mouse; // æ–°å¢ï¼šé¼ æ ‡ä½ç½® (-1.0 åˆ° 1.0)\n\n        // æ—‹è½¬çŸ©é˜µ\n        mat2 rot(float a) {\n            float s = sin(a);\n            float c = cos(a);\n            return mat2(c, -s, s, c);\n        }\n\n        // --- è·ç¦»åœºå‡½æ•° (SDF) ---\n        vec3 map(vec3 p) {\n            // 1. æ•´ä½“è¿åŠ¨ (æ— é™ä¸Šå‡)\n            // æ³¨æ„ï¼šè¿™é‡Œåªç§»åŠ¨Yï¼Œæ‘„åƒæœºçš„æ—‹è½¬åœ¨ main å‡½æ•°å¤„ç†\n            p.y += u_time * 1.0; \n            \n            // 2. æ‰­æ›²ç©ºé—´\n            float twist = 0.5;\n            vec3 p_twisted = p;\n            p_twisted.xz *= rot(p.y * twist);\n\n            // --- èºæ—‹é“¾ (Strands) ---\n            vec3 q = p_twisted;\n            q.x = abs(q.x) - 1.3; \n            float dStrands = length(q.xz) - 0.25; \n\n            // --- æ¨ªæ¡£ (Rungs) ---\n            float rungSpacing = 0.8;\n            vec3 r = p_twisted;\n            r.y = mod(r.y, rungSpacing) - rungSpacing * 0.5;\n            \n            float dBar = length(max(abs(r.xyz) - vec3(1.3, 0.08, 0.08), 0.0));\n            float dRungs = dBar;\n\n            // --- ç»„åˆ ---\n            if (dStrands < dRungs) {\n                // ID 1.0: èºæ—‹é“¾, Z: ç”¨äºç”»çº¿çš„è§’åº¦\n                return vec3(dStrands, 1.0, atan(q.z, q.x)); \n            } else {\n                // ID 2.0: æ¨ªæ¡£, Z: ç”¨äºç”»çº¿çš„å±€éƒ¨X\n                return vec3(dRungs, 2.0, r.x); \n            }\n        }\n\n        // --- æ‘„åƒæœºçŸ©é˜µç³»ç»Ÿ ---\n        // ro: æ‘„åƒæœºä½ç½®, ta: ç›®æ ‡ç‚¹\n        mat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n            vec3 cw = normalize(ta - ro); // å‰å‘é‡\n            vec3 cp = vec3(sin(cr), cos(cr), 0.0); // ä¸´æ—¶ä¸Šå‘é‡\n            vec3 cu = normalize(cross(cw, cp)); // å³å‘é‡\n            vec3 cv = normalize(cross(cu, cw)); // çœŸæ­£çš„ä¸Šå‘é‡\n            return mat3(cu, cv, cw);\n        }\n\n        void main() {\n            vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n            \n            // --- äº¤äº’å¼æ‘„åƒæœºé€»è¾‘ ---\n            \n            // åŸºç¡€è‡ªåŠ¨æ—‹è½¬é€Ÿåº¦\n            float angle = u_time * 0.2; \n            \n            // å åŠ é¼ æ ‡æ§åˆ¶\n            // u_mouse.x æ§åˆ¶æ°´å¹³æ—‹è½¬è§’åº¦\n            angle += u_mouse.x * 3.14 * 2.0; \n            \n            // æ‘„åƒæœºåŠå¾„\n            float radius = 9.5;\n            \n            // è®¡ç®—æ‘„åƒæœºä½ç½® (Orbit)\n            // u_mouse.y æ§åˆ¶æ‘„åƒæœºé«˜åº¦ (ä¿¯ä»°)\n            float camHeight = u_mouse.y * 4.0;\n            vec3 ro = vec3(sin(angle) * radius, camHeight, cos(angle) * radius);\n            \n            // æ‘„åƒæœºçœ‹å‘çš„ç›®æ ‡ç‚¹ (å§‹ç»ˆçœ‹å‘ä¸­å¿ƒ)\n            // ç¨å¾®å‘ä¸‹çœ‹ä¸€ç‚¹ç‚¹ (-0.5) æ„å›¾æ›´å¥½\n            vec3 ta = vec3(0.0, -0.5, 0.0);\n            \n            // æ„å»ºæ‘„åƒæœºçŸ©é˜µ\n            mat3 ca = setCamera(ro, ta, 0.0);\n            \n            // è®¡ç®—å°„çº¿æ–¹å‘\n            vec3 rd = ca * normalize(vec3(uv, 2.0)); // 2.0 æ˜¯é•œå¤´ç„¦è·(FOV)\n\n            // --- Raymarching ---\n            float t = 0.0;\n            float glow = 0.0;\n            vec3 hitData = vec3(0.0);\n            \n            for(int i = 0; i < 90; i++) {\n                vec3 p = ro + rd * t;\n                vec3 res = map(p); \n                float d = res.x;\n\n                // è¾‰å…‰ç´¯ç§¯\n                glow += 0.02 / (0.002 + d * d);\n\n                if(d < 0.001) {\n                    hitData = res;\n                    break; \n                }\n                \n                t += d;\n                if(t > 30.0) break;\n            }\n\n            vec3 col = vec3(0.0);\n\n            // --- ç»˜åˆ¶çº¿æ¡† ---\n            if(t < 30.0) {\n                vec3 p = ro + rd * t;\n                p.y += u_time * 1.0; // æ¢å¤è¿åŠ¨åç§»ä»¥è®¡ç®—çº¹ç†\n                vec3 p_local = p;\n                p_local.xz *= rot(p.y * 0.5);\n\n                float lineIntensity = 0.0;\n\n                // 1. èºæ—‹é“¾\n                if(hitData.y == 1.0) {\n                    vec3 q = p_local;\n                    q.x = abs(q.x) - 1.3;\n                    float vLines = step(0.95, sin(atan(q.z, q.x) * 8.0)); \n                    float hLines = step(0.95, sin(p.y * 20.0));\n                    lineIntensity = max(vLines, hLines);\n                    col = vec3(0.1, 0.8, 1.0) * lineIntensity * 2.0;\n                } \n                // 2. æ¨ªæ¡£\n                else {\n                    float gridX = step(0.9, sin(p_local.x * 20.0));\n                    float gridY = step(0.8, sin(p_local.y * 10.0));\n                    lineIntensity = max(gridX, gridY);\n                    col = vec3(1.0, 0.6, 0.1) * lineIntensity * 3.0;\n                }\n            }\n\n            // --- å åŠ è¾‰å…‰ ---\n            vec3 glowColor = vec3(0.3, 0.6, 1.0);\n            glowColor.r += sin(u_time) * 0.2;\n            col += glow * glowColor * 0.03;\n\n            // --- è·ç¦»è¡°å‡ & Tone Mapping ---\n            col *= 1.0 / (1.0 + t * t * 0.01);\n            col = 1.0 - exp(-col * 1.5);\n            col = pow(col, vec3(1.3));\n\n            gl_FragColor = vec4(col, 1.0);\n        }\n    </script>\n\n    <script>\n        const canvas = document.getElementById('glcanvas');\n        const gl = canvas.getContext('webgl');\n\n        if (!gl) { alert('ä¸æ”¯æŒ WebGL'); }\n\n        function createShader(gl, type, source) {\n            const shader = gl.createShader(type);\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                console.error(gl.getShaderInfoLog(shader));\n                return null;\n            }\n            return shader;\n        }\n\n        const program = gl.createProgram();\n        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').text));\n        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').text));\n        gl.linkProgram(program);\n        gl.useProgram(program);\n\n        const buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);\n        \n        const posLoc = gl.getAttribLocation(program, \"position\");\n        gl.enableVertexAttribArray(posLoc);\n        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);\n\n        const resLoc = gl.getUniformLocation(program, \"u_resolution\");\n        const timeLoc = gl.getUniformLocation(program, \"u_time\");\n        const mouseLoc = gl.getUniformLocation(program, \"u_mouse\");\n\n        // --- é¼ æ ‡äº¤äº’é€»è¾‘ ---\n        let mouseX = 0;\n        let mouseY = 0;\n        // ç›®æ ‡é¼ æ ‡ä½ç½®ï¼ˆç”¨äºå¹³æ»‘è¿‡æ¸¡ï¼‰\n        let targetMouseX = 0;\n        let targetMouseY = 0;\n\n        window.addEventListener('mousemove', (e) => {\n            // å°†åæ ‡å½’ä¸€åŒ–åˆ° -1.0 åˆ° 1.0 ä¹‹é—´\n            targetMouseX = (e.clientX / window.innerWidth) * 2 - 1;\n            targetMouseY = -(e.clientY / window.innerHeight) * 2 + 1; // Yè½´åè½¬\n        });\n\n        // è§¦æ‘¸å±æ”¯æŒ\n        window.addEventListener('touchmove', (e) => {\n            e.preventDefault();\n            const touch = e.touches[0];\n            targetMouseX = (touch.clientX / window.innerWidth) * 2 - 1;\n            targetMouseY = -(touch.clientY / window.innerHeight) * 2 + 1;\n        }, { passive: false });\n\n        function render(time) {\n            if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {\n                canvas.width = canvas.clientWidth;\n                canvas.height = canvas.clientHeight;\n                gl.viewport(0, 0, canvas.width, canvas.height);\n            }\n\n            // ç®€å•çš„ç¼“åŠ¨æ•ˆæœ (Lerp)ï¼Œè®©é¼ æ ‡åŠ¨ä½œæ›´é¡ºæ»‘\n            mouseX += (targetMouseX - mouseX) * 0.05;\n            mouseY += (targetMouseY - mouseY) * 0.05;\n\n            gl.uniform2f(resLoc, canvas.width, canvas.height);\n            gl.uniform1f(timeLoc, time * 0.001);\n            gl.uniform2f(mouseLoc, mouseX, mouseY);\n\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n            requestAnimationFrame(render);\n        }\n        requestAnimationFrame(render);\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 22,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Code Poetry Typer</title>\n    <style>\n        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&display=swap');\n\n        body, html {\n            margin: 0;\n            padding: 0;\n            height: 100%;\n            background-color: #0d1117; /* GitHub Dark Dimmed style */\n            overflow: hidden;\n            font-family: 'Fira Code', monospace;\n        }\n\n        /* CRT å±å¹•æ•ˆæœå®¹å™¨ */\n        #screen {\n            position: relative;\n            width: 100%;\n            height: 100%;\n            padding: 40px;\n            box-sizing: border-box;\n            overflow-y: auto;\n            color: #58a6ff; /* åŸºç¡€è“è‰² */\n            text-shadow: 0 0 2px rgba(88, 166, 255, 0.5);\n        }\n\n        /* éšè—æ»šåŠ¨æ¡ä½†å…è®¸æ»šåŠ¨ */\n        #screen::-webkit-scrollbar {\n            display: none;\n        }\n\n        /* ä»£ç æ ·å¼ */\n        #code-display {\n            white-space: pre-wrap;\n            font-size: 18px;\n            line-height: 1.6;\n            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ */\n        }\n\n        /* è¯­æ³•é«˜äº®æ¨¡æ‹Ÿç±» */\n        .keyword { color: #ff7b72; } /* ç²‰çº¢/çº¢ */\n        .function { color: #d2a8ff; } /* ç´«è‰² */\n        .string { color: #a5d6ff; }   /* æµ…è“ */\n        .comment { color: #8b949e; font-style: italic; } /* ç°è‰²æ³¨é‡Š */\n        .operator { color: #79c0ff; }\n\n        /* å…‰æ ‡é—ªçƒ */\n        .cursor {\n            display: inline-block;\n            width: 10px;\n            height: 20px;\n            background-color: #58a6ff;\n            animation: blink 1s step-end infinite;\n            vertical-align: middle;\n            margin-left: 5px;\n        }\n\n        @keyframes blink {\n            0%, 100% { opacity: 1; }\n            50% { opacity: 0; }\n        }\n\n        /* æç¤ºå±‚ */\n        #hint {\n            position: fixed;\n            bottom: 20px;\n            right: 20px;\n            color: #8b949e;\n            font-size: 12px;\n            opacity: 0.7;\n            pointer-events: none;\n        }\n\n        /* æ‰«æçº¿ç‰¹æ•ˆ (CRT Scanline) */\n        .scanlines {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: linear-gradient(\n                to bottom,\n                rgba(255,255,255,0),\n                rgba(255,255,255,0) 50%,\n                rgba(0,0,0,0.2) 50%,\n                rgba(0,0,0,0.2)\n            );\n            background-size: 100% 4px;\n            pointer-events: none;\n            z-index: 10;\n        }\n    </style>\n</head>\n<body>\n\n    <div class=\"scanlines\"></div>\n    \n    <div id=\"screen\">\n        <div id=\"code-display\"></div><span class=\"cursor\"></span>\n    </div>\n\n    <div id=\"hint\">æŒ‰ä»»æ„é”®å¼€å§‹å†™è¯—...</div>\n\n    <script>\n        // è¿™é‡Œå®šä¹‰ä½ çš„ä»£ç è¯—\n        // ä½¿ç”¨ç®€å•çš„æ ‡è®°æ¥æ¨¡æ‹Ÿé«˜äº®: \n        // ~k = keyword (pink), ~f = function (purple), ~s = string (blue), ~c = comment (grey)\n        const rawPoem = `\n~c// File: destiny.js\n~c// Author: You & Me\n\n~kconst ~universe = ~krequire(~s'existence');\n~kimport { ~You, ~Me } ~kfrom ~s'chance_encounter';\n\n~kasync ~kfunction ~fdevelopFeelings() {\n  ~kconst ~memories = [];\n  \n  ~ktry {\n    ~kwhile (~universe.expand()) {\n      ~klet ~moment = ~kawait ~You.~fsmile();\n      \n      ~kif (~moment.~fisGenuine()) {\n        ~memories.~fpush(~moment);\n        ~Me.~heartRate++;\n      }\n\n      ~c// Optimization: Remove loneliness\n      ~kif (~Me.~isAlone) {\n        ~kbreak; ~c// Impossible with you\n      }\n    }\n  } ~kcatch (~heartbreak) {\n    console.~flog(~s\"Error: Connection lost.\");\n    ~frestoreBackup(~memories);\n  } ~kfinally {\n    ~kreturn ~s\"Forever\";\n  }\n}\n\n~c// Initializing runtime...\n~fdevelopFeelings();\n`;\n\n        // é¢„å¤„ç†è¯—æ­Œï¼Œå°†å…¶è½¬æ¢ä¸ºå¸¦æœ‰æ ·å¼çš„HTMLç‰‡æ®µæ•°ç»„\n        const tokens = [];\n        let currentTag = '';\n        \n        // ç®€å•çš„è§£æå™¨ï¼Œå°†æ ‡è®°è½¬æ¢ä¸ºHTML span\n        const lines = rawPoem.split('\\n');\n        let processedHTML = '';\n        \n        // å°†æ–‡æœ¬â€œå¹³é“ºâ€æˆå­—ç¬¦æµï¼Œä½†ä¿ç•™é¢œè‰²ä¿¡æ¯\n        // ä¸ºäº†æ‰“å­—æ•ˆæœï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå­—ç¬¦ä¸€ä¸ªå­—ç¬¦åœ°è¾“å‡ºï¼Œ\n        // ä½†å¦‚æœå­—ç¬¦åœ¨æ ‡ç­¾å†…ï¼Œæˆ‘ä»¬éœ€è¦ç‰¹æ®Šå¤„ç†ã€‚\n        // ç®€åŒ–ç­–ç•¥ï¼šæˆ‘ä»¬å°†é¢„å…ˆç”Ÿæˆçš„HTMLå­˜å…¥ç¼“å†²åŒºï¼Œæ¯æ¬¡æŒ‰é”®åå‡ºä¸€æ®µHTMLã€‚\n\n        let buffer = [];\n        \n        // è§£æé€»è¾‘ï¼šéå†å­—ç¬¦ä¸²ï¼Œé‡åˆ°æ ‡è®°ç¬¦å°±æ”¹å˜å½“å‰çš„é¢œè‰²çŠ¶æ€\n        let state = 'normal'; // normal, keyword, function, string, comment\n        \n        // æ­£åˆ™æ›¿æ¢æ ‡è®°ä¸ºHTMLæ ‡ç­¾ï¼Œç„¶åæˆ‘ä»¬å†æ‹†åˆ†å®ƒ\n        // ä¸ºäº†ç®€åŒ–æ‰“å­—æ•ˆæœï¼Œæˆ‘ä»¬ä¸é€å­—æ‹†åˆ†HTMLæ ‡ç­¾ï¼Œè€Œæ˜¯é‡‡ç”¨â€œå—â€è¾“å‡º\n        // æ¯æ¬¡æŒ‰é”®è¾“å‡º 3-6 ä¸ªå­—ç¬¦ï¼Œç¡®ä¿æµç•…æ„Ÿ\n        \n        let formattedPoem = rawPoem\n            .replace(/~k/g, '<span class=\"keyword\">')\n            .replace(/~f/g, '<span class=\"function\">')\n            .replace(/~s/g, '<span class=\"string\">')\n            .replace(/~c/g, '<span class=\"comment\">')\n            // è¿™é‡Œçš„é€»è¾‘æ˜¯ï¼šé‡åˆ°ä¸‹ä¸€ä¸ª ~ æ ‡è®°æˆ–è€…æ¢è¡Œæ—¶ï¼Œåº”è¯¥é—­åˆä¸Šä¸€ä¸ª spanï¼Ÿ\n            // è¿™ç§ç®€å•çš„æ›¿æ¢éœ€è¦é…åˆ CSS çš„ display:inline \n            // æ›´å¥½çš„æ–¹æ³•æ˜¯æ‰‹åŠ¨æ„å»ºæµã€‚\n            \n        // é‡æ–°æ„å»ºä¸€ç§æ›´ç¨³å¥çš„æµå¼è¾“å‡ºé€»è¾‘\n        function parsePoem(text) {\n            let output = [];\n            let parts = text.split(/(\\~[kfsc])/g); // æŒ‰æ ‡è®°åˆ†å‰²\n            let currentClass = '';\n            \n            parts.forEach(part => {\n                if (part === '~k') currentClass = 'keyword';\n                else if (part === '~f') currentClass = 'function';\n                else if (part === '~s') currentClass = 'string';\n                else if (part === '~c') currentClass = 'comment';\n                else {\n                    // è¿™æ˜¯å®é™…æ–‡æœ¬\n                    if (currentClass) {\n                        // å°†è¿™æ®µæ–‡æœ¬çš„æ¯ä¸ªå­—ç¬¦éƒ½åŒ…è£…åœ¨ span ä¸­ï¼Œæˆ–è€…ä½œä¸ºä¸€ä¸ªæ•´ä½“å—\n                        // ä¸ºäº†æ‰“å­—æœºæ•ˆæœï¼Œæˆ‘ä»¬æŠŠè¿™æ®µæ–‡æœ¬æ‹†åˆ†æˆå°å—\n                        let chars = part.split('');\n                        chars.forEach((c, idx) => {\n                            // ç¨å¾®éšæœºåŒ–ä¸€ä¸‹å—çš„å¤§å°ï¼Œè®©æ‰“å­—æ„Ÿè§‰æ›´è‡ªç„¶\n                            // è¿™é‡Œç®€å•å¤„ç†ï¼šæ¯ä¸ªå­—ç¬¦éƒ½å¸¦ä¸Šå®ƒçš„æ ·å¼\n                            output.push(`<span class=\"${currentClass}\">${c}</span>`);\n                        });\n                        currentClass = ''; // é‡ç½®ï¼Œé™¤éä½ æƒ³å»¶ç»­æ ·å¼ï¼ˆé€šå¸¸ä»£ç é«˜äº®æ˜¯å•è¯çº§çš„ï¼‰\n                        // æ³¨æ„ï¼šæ³¨é‡Šé€šå¸¸å»¶ç»­åˆ°è¡Œå°¾ï¼Œå­—ç¬¦ä¸²å»¶ç»­åˆ°å¼•å·ç»“æŸã€‚\n                        // ä¸Šé¢çš„ç®€å•æ ‡è®°æ³•å‡è®¾ç”¨æˆ·åœ¨æ¯ä¸ªè¯å‰éƒ½åŠ äº†æ ‡è®°ã€‚\n                        // ä¸ºäº†æ¼”ç¤ºæ•ˆæœï¼Œæˆ‘ä»¬ä¿®æ­£ä¸€ä¸‹ä¸Šé¢çš„ rawPoem å®šä¹‰é€»è¾‘ã€‚\n                    } else {\n                        // æ™®é€šæ–‡æœ¬\n                        part.split('').forEach(c => output.push(c));\n                    }\n                }\n            });\n            return output;\n        }\n\n        // ä¿®æ­£åçš„ç®€å•è§£æå™¨ï¼š\n        // æˆ‘ä»¬ä¸å®æ—¶è§£æï¼Œè€Œæ˜¯ç›´æ¥æŠŠæ•´æ®µå¸¦HTMLçš„å­—ç¬¦ä¸²å‡†å¤‡å¥½ï¼Œ\n        // æ¯æ¬¡æŒ‰é”®åªæ˜¯ç§»åŠ¨æŒ‡é’ˆï¼Œæˆªå–ä¸€æ®µ HTML å­—ç¬¦ä¸²è¿½åŠ è¿›å»ï¼Ÿ\n        // ä¸è¡Œï¼Œæˆªå– HTML å­—ç¬¦ä¸²ä¼šæˆªæ–­æ ‡ç­¾ã€‚\n        // æœ€ä½³æ–¹æ¡ˆï¼šæŠŠè¯—æ­Œè§£ææˆä¸€ä¸ªâ€œèŠ‚ç‚¹å¯¹è±¡â€æ•°ç»„ã€‚\n        \n        const charStream = [];\n        \n        // æ‰‹åŠ¨æ„å»ºæµæ•°æ®ï¼Œç¡®ä¿æ ·å¼æ­£ç¡®\n        // è¿™é‡Œçš„é€»è¾‘æ˜¯ï¼š~x å¼€å¯æ ·å¼ï¼Œç›´åˆ°é‡åˆ°ç©ºæ ¼æˆ–ç‰¹å®šç¬¦å·ï¼ˆç®€å•èµ·è§ï¼Œæˆ‘ä»¬åœ¨ rawPoem é‡Œæ‰‹åŠ¨æ§åˆ¶é—­åˆæ¯”è¾ƒéš¾ï¼‰\n        // è®©æˆ‘ä»¬æ¢ä¸€ç§è¶…ç®€å•çš„â€œé»‘å®¢â€æ–¹å¼ï¼š\n        // æ¯æ¬¡æŒ‰é”®ï¼Œè¿½åŠ  rawPoem çš„ä¸‹ 3 ä¸ªå­—ç¬¦ã€‚\n        // ç„¶åç”¨æ­£åˆ™å¯¹æ•´ä¸ªå±å¹•çš„ innerText è¿›è¡Œä¸€æ¬¡é«˜äº®å¤„ç†ï¼Ÿæ€§èƒ½å¤ªå·®ã€‚\n        // æ–¹æ¡ˆCï¼šé¢„å…ˆç”Ÿæˆå¥½å®Œæ•´çš„ HTML å­—ç¬¦æµã€‚\n        \n        function buildStream() {\n            let i = 0;\n            let style = null;\n            while (i < rawPoem.length) {\n                if (rawPoem[i] === '~') {\n                    let type = rawPoem[i+1];\n                    if (type === 'k') style = 'keyword';\n                    else if (type === 'f') style = 'function';\n                    else if (type === 's') style = 'string';\n                    else if (type === 'c') style = 'comment';\n                    i += 2;\n                } else {\n                    // å¦‚æœæ˜¯æ¢è¡Œï¼Œé‡ç½®æ ·å¼ï¼ˆé™¤äº†æ³¨é‡Šï¼Œä½†æˆ‘ä»¬ç®€åŒ–å¤„ç†ï¼‰\n                    if (rawPoem[i] === '\\n') style = null;\n                    \n                    let char = rawPoem[i];\n                    // è½¬ä¹‰ HTML\n                    if (char === '<') char = '&lt;';\n                    if (char === '>') char = '&gt;';\n                    \n                    if (style) {\n                        charStream.push(`<span class=\"${style}\">${char}</span>`);\n                        // å¦‚æœæ˜¯ç©ºæ ¼ï¼Œé€šå¸¸æ„å‘³ç€å…³é”®å­—ç»“æŸï¼Œä½†åœ¨å­—ç¬¦ä¸²/æ³¨é‡Šé‡Œä¸æ˜¯\n                        if (char === ' ' && style !== 'string' && style !== 'comment') {\n                            style = null; \n                        }\n                    } else {\n                        charStream.push(char);\n                    }\n                    i++;\n                }\n            }\n        }\n        \n        buildStream();\n\n        let currentIndex = 0;\n        const display = document.getElementById('code-display');\n        const screen = document.getElementById('screen');\n        const hint = document.getElementById('hint');\n\n        // ç›‘å¬é”®ç›˜äº‹ä»¶\n        document.addEventListener('keydown', (e) => {\n            // å¿½ç•¥æ§åˆ¶é”®\n            if (e.key === 'Meta' || e.key === 'Control' || e.key === 'Alt' || e.key === 'Shift') return;\n            \n            e.preventDefault(); // é˜»æ­¢å®é™…æ‰“å­—\n            \n            hint.style.display = 'none'; // éšè—æç¤º\n\n            // æ¯æ¬¡æŒ‰é”®è¾“å‡º 2-5 ä¸ªå­—ç¬¦ï¼Œåˆ¶é€ â€œé»‘å®¢æ‰‹é€Ÿâ€çš„å¿«æ„Ÿ\n            const charsPerKeystroke = Math.floor(Math.random() * 4) + 2;\n            \n            for (let k = 0; k < charsPerKeystroke; k++) {\n                if (currentIndex < charStream.length) {\n                    // è¿½åŠ å†…å®¹\n                    display.innerHTML += charStream[currentIndex];\n                    currentIndex++;\n                } else {\n                    // å†™å®Œäº†ï¼Œé‡ç½®æˆ–åœæ­¢\n                    // display.innerHTML += '<br/><span class=\"comment\">// End of transmission.</span>';\n                    // ç§»é™¤ç›‘å¬å™¨é˜²æ­¢æŠ¥é”™\n                }\n            }\n\n            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨\n            screen.scrollTop = screen.scrollHeight;\n        });\n        \n        // ç§»åŠ¨ç«¯è§¦æ‘¸æ”¯æŒ\n        document.addEventListener('touchstart', (e) => {\n             hint.style.display = 'none';\n             const charsPerKeystroke = 3;\n             for (let k = 0; k < charsPerKeystroke; k++) {\n                if (currentIndex < charStream.length) {\n                    display.innerHTML += charStream[currentIndex];\n                    currentIndex++;\n                }\n            }\n            screen.scrollTop = screen.scrollHeight;\n        });\n\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 23,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Geometric Breathing - Parameter Space</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            background-color: #0a0a0a; /* æ·±ç©ºé»‘ */\n            overflow: hidden;\n            font-family: 'Courier New', Courier, monospace;\n        }\n        canvas {\n            display: block;\n        }\n        #ui-layer {\n            position: absolute;\n            bottom: 30px;\n            left: 30px;\n            color: #666;\n            pointer-events: none;\n            font-size: 12px;\n            line-height: 1.6;\n        }\n        .value {\n            color: #00ffcc;\n            font-weight: bold;\n        }\n    </style>\n</head>\n<body>\n\n    <div id=\"ui-layer\">\n        <div>PARAMETER SPACE MONITOR</div>\n        <div>-----------------------</div>\n        <div>ENTROPY (Chaos): <span id=\"val-entropy\" class=\"value\">0.00</span></div>\n        <div>CONNECTIVITY : <span id=\"val-connect\" class=\"value\">0.00</span></div>\n        <div>STATUS       : <span id=\"val-status\" class=\"value\">ORDER</span></div>\n    </div>\n\n    <canvas id=\"canvas\"></canvas>\n\n<script>\n/**\n * åˆ›æ„ç¼–ç ï¼šå‡ ä½•ç§©åºä¸æ··æ²Œçš„å‘¼å¸\n * æ ¸å¿ƒæ¦‚å¿µï¼šParameter Space (å‚æ•°ç©ºé—´) çš„è‡ªåŠ¨æ¼«æ¸¸\n */\n\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\n\n// UI å…ƒç´ \nconst uiEntropy = document.getElementById('val-entropy');\nconst uiConnect = document.getElementById('val-connect');\nconst uiStatus = document.getElementById('val-status');\n\nlet width, height;\nlet particles = [];\n\n// --- å‚æ•°ç©ºé—´å®šä¹‰ ---\n// æˆ‘ä»¬ä¸ç›´æ¥å†™æ­»æ•°å€¼ï¼Œè€Œæ˜¯å®šä¹‰è¿™å‡ ä¸ªå˜é‡éšæ—¶é—´å˜åŒ–çš„èŒƒå›´\nconst CONFIG = {\n    gridSize: 40,        // ç½‘æ ¼é—´è· (ç§©åºçš„åŸºç¡€)\n    baseSpeed: 0.005,    // æ¼”åŒ–é€Ÿåº¦\n    maxDist: 100,        // æœ€å¤§è¿æ¥è·ç¦»\n    particleSize: 1.5    // ç²’å­å¤§å°\n};\n\n// ç²’å­ç±»ï¼šä»£è¡¨ç½‘æ ¼ä¸Šçš„ä¸€ä¸ªèŠ‚ç‚¹\nclass Particle {\n    constructor(x, y) {\n        this.homeX = x; // ç§©åºï¼šå®ƒçš„â€œå®¶â€åœ¨å“ªé‡Œ\n        this.homeY = y;\n        this.x = x;     // æ··æ²Œï¼šå®ƒå½“å‰åœ¨å“ªé‡Œ\n        this.y = y;\n        // ç»™æ¯ä¸ªç²’å­ä¸€ä¸ªéšæœºçš„ç›¸ä½ï¼Œè®©å®ƒä»¬ä¸è¦æ•´é½åˆ’ä¸€åœ°ç§»åŠ¨ï¼Œå¢åŠ â€œæœ‰æœºæ„Ÿâ€\n        this.phaseX = Math.random() * Math.PI * 2;\n        this.phaseY = Math.random() * Math.PI * 2;\n    }\n\n    update(time, entropy) {\n        // æ ¸å¿ƒç®—æ³•ï¼šä½ç½® = å®¶ + (å™ªéŸ³ * ç†µå€¼ * æŒ¯å¹…)\n        \n        // ä½¿ç”¨æ­£å¼¦æ³¢å åŠ æ¨¡æ‹Ÿç®€å•çš„ Perlin Noise æ•ˆæœ\n        // å½“ entropy ä¸º 0 æ—¶ï¼Œnoise å³ä½¿è®¡ç®—äº†ä¹Ÿæ²¡ç”¨ï¼Œç²’å­ä¼šå›åˆ° homeX/homeY\n        \n        // è¿™ç§è¿åŠ¨æ˜¯å¹³æ»‘çš„ï¼Œä¸æ˜¯éšæœºæŠ–åŠ¨\n        let noiseX = Math.sin(time * 2 + this.phaseX) + Math.cos(time * 1.5 + this.y * 0.01);\n        let noiseY = Math.cos(time * 2 + this.phaseY) + Math.sin(time * 1.5 + this.x * 0.01);\n\n        // ç†µå€¼å†³å®šäº†åç¦»â€œå®¶â€å¤šè¿œã€‚\n        // ç†µè¶Šå¤§ï¼Œåç¦»è¶Šè¿œï¼Œæœ€å¤§åç¦» 150 åƒç´ \n        let displacement = entropy * 150; \n\n        this.x = this.homeX + noiseX * displacement;\n        this.y = this.homeY + noiseY * displacement;\n    }\n\n    draw(ctx, entropy) {\n        ctx.beginPath();\n        // ç²’å­é¢œè‰²éšç†µå€¼å˜åŒ–ï¼šç§©åºæ—¶æš—æ·¡ï¼Œæ··æ²Œæ—¶æ˜äº®\n        let alpha = 0.3 + entropy * 0.7; \n        ctx.fillStyle = `rgba(200, 220, 255, ${alpha})`;\n        ctx.arc(this.x, this.y, CONFIG.particleSize, 0, Math.PI * 2);\n        ctx.fill();\n    }\n}\n\n// åˆå§‹åŒ–ç½‘æ ¼\nfunction init() {\n    width = canvas.width = window.innerWidth;\n    height = canvas.height = window.innerHeight;\n    particles = [];\n\n    // åˆ›å»ºä¸€ä¸ªç•™æœ‰è¾¹è·çš„ç½‘æ ¼\n    let cols = Math.floor(width / CONFIG.gridSize);\n    let rows = Math.floor(height / CONFIG.gridSize);\n    \n    let offsetX = (width - cols * CONFIG.gridSize) / 2;\n    let offsetY = (height - rows * CONFIG.gridSize) / 2;\n\n    for (let i = 0; i <= cols; i++) {\n        for (let j = 0; j <= rows; j++) {\n            particles.push(new Particle(\n                offsetX + i * CONFIG.gridSize, \n                offsetY + j * CONFIG.gridSize\n            ));\n        }\n    }\n}\n\n// åŠ¨ç”»å¾ªç¯\nlet time = 0;\n\nfunction animate() {\n    requestAnimationFrame(animate);\n    \n    // 1. æ¸…é™¤ç”»å¸ƒ (ç•™ä¸€ç‚¹æ‹–å°¾æ•ˆæœä¼šå¾ˆæ£’ï¼Œä½†ä¸ºäº†æç®€ä¸»ä¹‰ï¼Œæˆ‘ä»¬å®Œå…¨æ¸…é™¤)\n    ctx.fillStyle = '#0a0a0a';\n    ctx.fillRect(0, 0, width, height);\n\n    time += CONFIG.baseSpeed;\n\n    // --- æ¼«æ¸¸å‚æ•°ç©ºé—´ ---\n    \n    // å‚æ•° 1: ç†µ (Entropy) - æ§åˆ¶æ··ä¹±ç¨‹åº¦\n    // ä½¿ç”¨æ­£å¼¦æ³¢ï¼Œè®©å®ƒåœ¨ 0 (å®Œå…¨ç§©åº) åˆ° 1 (å®Œå…¨æ··æ²Œ) ä¹‹é—´å¾ªç¯\n    // Math.sin(time) èŒƒå›´æ˜¯ -1 åˆ° 1ï¼Œæ˜ å°„åˆ° 0 åˆ° 1\n    let entropy = (Math.sin(time) + 1) / 2; \n    // å¢åŠ ä¸€ä¸ªç¼“åŠ¨ï¼Œè®©å®ƒåœ¨â€œç§©åºâ€çŠ¶æ€åœç•™ç¨å¾®ä¹…ä¸€ç‚¹\n    entropy = Math.pow(entropy, 1.5); \n\n    // å‚æ•° 2: è¿æ¥é˜ˆå€¼ (Connectivity)\n    // å½“æ··ä¹±å‘ç”Ÿæ—¶ï¼Œæˆ‘ä»¬éœ€è¦å¢åŠ è¿æ¥è·ç¦»ï¼Œå¦åˆ™ç‚¹æ•£å¤ªå¼€å°±è¿ä¸ä¸Šäº†\n    // ä½†ä¸ºäº†ç•™ç™½ï¼Œæˆ‘ä»¬æ§åˆ¶å®ƒä¸è¦å¤ªå¤§\n    let connectDist = CONFIG.maxDist * (0.5 + entropy * 0.5);\n\n\n    // æ›´æ–° UI æ•°æ®æ˜¾ç¤º\n    uiEntropy.innerText = entropy.toFixed(2);\n    uiConnect.innerText = Math.floor(connectDist);\n    if(entropy < 0.1) uiStatus.innerText = \"PERFECT ORDER\";\n    else if(entropy > 0.8) uiStatus.innerText = \"MAXIMUM ENTROPY\";\n    else uiStatus.innerText = \"TRANSITIONING\";\n\n\n    // 2. æ›´æ–°æ‰€æœ‰ç²’å­ä½ç½®\n    particles.forEach(p => p.update(time, entropy));\n\n    // 3. ç»˜åˆ¶è¿çº¿ (å‡ ä½•æ„å»º)\n    // ä¸ºäº†æ€§èƒ½ï¼Œæˆ‘ä»¬åªæ£€æŸ¥é™„è¿‘çš„ç²’å­ã€‚\n    // åœ¨è¿™ç§æç®€é£æ ¼ä¸­ï¼ŒO(N^2) å¯¹äº 500 ä¸ªå·¦å³çš„ç²’å­æ˜¯å¯ä»¥æ¥å—çš„\n    ctx.lineWidth = 0.5;\n    \n    for (let i = 0; i < particles.length; i++) {\n        let p1 = particles[i];\n        \n        // ä¼˜åŒ–ï¼šåªç”»ä¸€éƒ¨åˆ†ç‚¹ä½œä¸ºè¿çº¿æºå¤´ï¼Œæˆ–è€…åªå‘åæ£€æŸ¥ï¼Œå‡å°‘è®¡ç®—\n        // è¿™é‡Œä¸ºäº†è§†è§‰æ•ˆæœï¼Œæˆ‘ä»¬åšå…¨é‡æ£€æŸ¥ï¼Œä½†åˆ©ç”¨è·ç¦»å¿«é€Ÿå‰”é™¤\n        for (let j = i + 1; j < particles.length; j++) {\n            let p2 = particles[j];\n            \n            // ç®€å•çš„è·ç¦»è®¡ç®—\n            let dx = p1.x - p2.x;\n            let dy = p1.y - p2.y;\n            let distSq = dx*dx + dy*dy;\n            let thresholdSq = connectDist * connectDist;\n\n            if (distSq < thresholdSq) {\n                // è·ç¦»è¶Šè¿‘ï¼Œçº¿è¶Šäº®\n                let dist = Math.sqrt(distSq);\n                let opacity = 1 - (dist / connectDist);\n                \n                // åªæœ‰å½“ç†µå€¼è¾ƒé«˜ï¼ˆæ··æ²Œï¼‰æˆ–è€…è·ç¦»æè¿‘æ—¶æ‰è¿çº¿\n                // è¿™æ ·åœ¨ç§©åºçŠ¶æ€ä¸‹ï¼Œåªæœ‰åŸæœ¬ç›¸é‚»çš„ç‚¹ä¼šè¿çº¿ï¼Œå½¢æˆç½‘æ ¼\n                ctx.strokeStyle = `rgba(0, 255, 204, ${opacity * 0.4})`;\n                ctx.beginPath();\n                ctx.moveTo(p1.x, p1.y);\n                ctx.lineTo(p2.x, p2.y);\n                ctx.stroke();\n            }\n        }\n        \n        // æœ€åç”»ç‚¹ï¼Œç›–åœ¨çº¿ä¸Šé¢\n        p1.draw(ctx, entropy);\n    }\n}\n\n// çª—å£å¤§å°æ”¹å˜æ—¶é‡ç½®\nwindow.addEventListener('resize', init);\n\n// å¯åŠ¨\ninit();\nanimate();\n\n</script>\n</body>\n</html>"
    },
    {
        "åºå·": 24,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Glacial Entropy - Glitch/Async</title>\n    <style>\n        body { \n            margin: 0; \n            overflow: hidden; \n            background-color: #000000; /* çº¯é»‘èƒŒæ™¯ï¼Œå¢å¼ºçº¿æ¡†å¯¹æ¯”åº¦ */\n            cursor: pointer; /* æç¤ºå¯ç‚¹å‡» */\n        }\n        canvas { display: block; width: 100vw; height: 100vh; }\n        \n        /* æ•…éšœé£æ ¼çš„æš—è§’ */\n        #vignette {\n            position: absolute; top: 0; left: 0; width: 100%; height: 100%;\n            background: radial-gradient(circle, transparent 40%, rgba(0,0,0,0.9) 100%);\n            pointer-events: none;\n            z-index: 10;\n        }\n\n        /* æç¤ºæ–‡å­—ï¼Œå‡ ç§’åæ¶ˆå¤± */\n        #hint {\n            position: absolute; bottom: 30px; width: 100%; text-align: center;\n            color: #445566; font-family: monospace; font-size: 10px; letter-spacing: 2px;\n            pointer-events: none; animation: fadeOut 4s forwards 2s;\n        }\n        @keyframes fadeOut { to { opacity: 0; } }\n    </style>\n    <script type=\"importmap\">\n        {\n            \"imports\": {\n                \"three\": \"https://unpkg.com/three@0.160.0/build/three.module.js\",\n                \"three/addons/\": \"https://unpkg.com/three@0.160.0/examples/jsm/\"\n            }\n        }\n    </script>\n</head>\n<body>\n\n    <div id=\"vignette\"></div>\n    <div id=\"hint\">[ CLICK TO TOGGLE GLITCH MODE ]</div>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n\n        // --- é…ç½® ---\n        const config = {\n            gridSize: 14,      \n            spacing: 1.8,      \n            cubeSize: 0.9,     \n            baseColor: 0x5588aa, \n            wireColor: 0xaaccff, // æ•…éšœæ¨¡å¼ä¸‹çš„çº¿æ¡†è‰²\n            connectionThreshold: 4.0, // è¿çº¿è·ç¦»é˜ˆå€¼\n        };\n\n        let scene, camera, renderer;\n        let mesh, lineSegments;\n        let dummy = new THREE.Object3D();\n        let clock = new THREE.Clock();\n        \n        // çŠ¶æ€\n        let isGlitchMode = false;\n        let glitchIntensity = 0; // ç”¨äºå¹³æ»‘è¿‡æ¸¡\n        \n        // æ•°æ®\n        const count = config.gridSize * config.gridSize;\n        const originalPositions = new Float32Array(count * 3);\n        const randomOffsets = new Float32Array(count * 3);\n        const randomRotations = new Float32Array(count * 3);\n        \n        // ç”¨äºè¿çº¿è®¡ç®—çš„å®æ—¶ä½ç½®ç¼“å­˜\n        const currentPositions = new Float32Array(count * 3);\n\n        // å¯¼æ¼”çŠ¶æ€\n        let directorState = {\n            entropy: 0,\n            speed: 1\n        };\n\n        function init() {\n            scene = new THREE.Scene();\n            scene.background = new THREE.Color(0x000000);\n            scene.fog = new THREE.FogExp2(0x000000, 0.02);\n\n            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);\n            \n            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: \"high-performance\" });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n            document.body.appendChild(renderer.domElement);\n\n            // ç¯å…‰\n            const ambientLight = new THREE.AmbientLight(0x222222, 1.0);\n            scene.add(ambientLight);\n            const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);\n            dirLight.position.set(10, 20, 10);\n            scene.add(dirLight);\n            const blueLight = new THREE.PointLight(0x0033ff, 3, 40);\n            blueLight.position.set(0, -10, 0);\n            scene.add(blueLight);\n\n            createObjects();\n\n            window.addEventListener('resize', onWindowResize);\n            window.addEventListener('click', toggleGlitch);\n            \n            animate();\n        }\n\n        function createObjects() {\n            // 1. æ–¹å— (InstancedMesh)\n            const geometry = new THREE.BoxGeometry(config.cubeSize, config.cubeSize, config.cubeSize);\n            const material = new THREE.MeshPhysicalMaterial({\n                color: config.baseColor,\n                metalness: 0.1, roughness: 0.1, transmission: 0.6, thickness: 2.0,\n                wireframe: false // åˆå§‹å…¶å®ä½“\n            });\n\n            mesh = new THREE.InstancedMesh(geometry, material, count);\n            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);\n\n            // åˆå§‹åŒ–ä½ç½®\n            let i = 0;\n            const offset = (config.gridSize * config.spacing) / 2;\n            for (let x = 0; x < config.gridSize; x++) {\n                for (let z = 0; z < config.gridSize; z++) {\n                    const posX = x * config.spacing - offset;\n                    const posZ = z * config.spacing - offset;\n                    const posY = 0;\n\n                    originalPositions[i * 3] = posX;\n                    originalPositions[i * 3 + 1] = posY;\n                    originalPositions[i * 3 + 2] = posZ;\n\n                    // å´©å¡Œå‚æ•°\n                    randomOffsets[i * 3] = (Math.random() - 0.5) * 18; \n                    randomOffsets[i * 3 + 1] = Math.random() * 10 + 2; \n                    randomOffsets[i * 3 + 2] = (Math.random() - 0.5) * 18;\n\n                    randomRotations[i * 3] = Math.random() * Math.PI * 2;\n                    randomRotations[i * 3 + 1] = Math.random() * Math.PI * 2;\n                    randomRotations[i * 3 + 2] = Math.random() * Math.PI * 2;\n\n                    dummy.position.set(posX, posY, posZ);\n                    dummy.updateMatrix();\n                    mesh.setMatrixAt(i, dummy.matrix);\n                    i++;\n                }\n            }\n            scene.add(mesh);\n\n            // 2. è¿çº¿ (LineSegments) - é¢„åˆ†é…ç¼“å†²åŒº\n            // æœ€å¤šè¿æ¥æ•°ä¼°ç®—ï¼šæ¯ä¸ªç‚¹è¿æœ€è¿‘çš„4-5ä¸ªç‚¹ã€‚è¿™é‡Œç»™ä¸ªå®‰å…¨ä½™é‡ã€‚\n            const maxConnections = count * 8; \n            const lineGeo = new THREE.BufferGeometry();\n            const linePos = new Float32Array(maxConnections * 6); // æ¯ä¸ªè¿æ¥2ä¸ªç‚¹ï¼Œæ¯ä¸ªç‚¹3ä¸ªåæ ‡\n            lineGeo.setAttribute('position', new THREE.BufferAttribute(linePos, 3));\n            \n            const lineMat = new THREE.LineBasicMaterial({\n                color: config.wireColor,\n                transparent: true,\n                opacity: 0.0, // åˆå§‹ä¸å¯è§\n                blending: THREE.AdditiveBlending\n            });\n\n            lineSegments = new THREE.LineSegments(lineGeo, lineMat);\n            lineSegments.frustumCulled = false; // é¿å…åŠ¨æ€æ›´æ–°å¯¼è‡´çš„è£å‰ªé”™è¯¯\n            scene.add(lineSegments);\n        }\n\n        function toggleGlitch() {\n            isGlitchMode = !isGlitchMode;\n            \n            // åˆ‡æ¢æè´¨æ¨¡å¼\n            mesh.material.wireframe = isGlitchMode;\n            mesh.material.emissive = isGlitchMode ? new THREE.Color(0x224466) : new THREE.Color(0x000000);\n            \n            // èƒŒæ™¯é—ªçƒä¸€ä¸‹\n            scene.background = new THREE.Color(isGlitchMode ? 0x111111 : 0x000000);\n            setTimeout(() => {\n                scene.background = new THREE.Color(0x000000);\n            }, 50);\n        }\n\n        function updateDirector(elapsedTime) {\n            // 1. ç†µå¾ªç¯\n            const cycleSpeed = 0.3; \n            const rawSin = Math.sin(elapsedTime * cycleSpeed);\n            let t = THREE.MathUtils.smoothstep(rawSin, 0.1, 0.95); \n            directorState.entropy = t;\n\n            // 2. æç«¯å˜é€Ÿ (Time Dilation)\n            // ç§©åºæ€(t=0) -> é€Ÿåº¦ 1.5\n            // å´©å¡Œæ€(t=1) -> é€Ÿåº¦ 0.05 (å‡ ä¹é™æ­¢)\n            // ä½¿ç”¨ easeInExpo æ›²çº¿è®©å‡é€Ÿæ›´å‰§çƒˆ\n            const speedCurve = 1 - Math.pow(t, 2); \n            directorState.speed = speedCurve * 1.5 + 0.05;\n\n            // 3. æ‘„åƒæœº\n            const camAngle = elapsedTime * 0.15;\n            const targetRadius = THREE.MathUtils.lerp(18, 28, t);\n            const targetY = THREE.MathUtils.lerp(8, 18, t);\n\n            // æ•…éšœæ¨¡å¼ä¸‹çš„æ‘„åƒæœºæŠ–åŠ¨\n            let shakeX = 0, shakeY = 0;\n            if (isGlitchMode) {\n                shakeX = (Math.random() - 0.5) * 0.3;\n                shakeY = (Math.random() - 0.5) * 0.3;\n            }\n\n            camera.position.x = Math.cos(camAngle) * targetRadius + shakeX;\n            camera.position.z = Math.sin(camAngle) * targetRadius;\n            camera.position.y = targetY + shakeY;\n            camera.lookAt(0, 0, 0);\n        }\n\n        function updateLines() {\n            // ä»…åœ¨æ•…éšœæ¨¡å¼æˆ–è¿‡æ¸¡æœŸé—´è®¡ç®—è¿çº¿\n            // ç®€å•çš„ O(N^2) è·ç¦»æ£€æµ‹ï¼Œå› ä¸º N åªæœ‰ ~200ï¼Œæ€§èƒ½æ²¡é—®é¢˜\n            const positions = lineSegments.geometry.attributes.position.array;\n            let lineIndex = 0;\n            const thresholdSq = config.connectionThreshold * config.connectionThreshold;\n\n            if (isGlitchMode) {\n                lineSegments.material.opacity = THREE.MathUtils.lerp(lineSegments.material.opacity, 0.4, 0.1);\n            } else {\n                lineSegments.material.opacity = THREE.MathUtils.lerp(lineSegments.material.opacity, 0.0, 0.2);\n                if (lineSegments.material.opacity < 0.01) return; // å®Œå…¨æ¶ˆå¤±åä¸è®¡ç®—\n            }\n\n            for (let i = 0; i < count; i++) {\n                // ä¼˜åŒ–ï¼šåªæ£€æŸ¥ i ä¹‹åçš„ç‚¹ï¼Œé¿å…é‡å¤\n                for (let j = i + 1; j < count; j++) {\n                    const dx = currentPositions[i*3] - currentPositions[j*3];\n                    const dy = currentPositions[i*3+1] - currentPositions[j*3+1];\n                    const dz = currentPositions[i*3+2] - currentPositions[j*3+2];\n                    \n                    const distSq = dx*dx + dy*dy + dz*dz;\n\n                    if (distSq < thresholdSq) {\n                        // æ·»åŠ è¿çº¿\n                        positions[lineIndex++] = currentPositions[i*3];\n                        positions[lineIndex++] = currentPositions[i*3+1];\n                        positions[lineIndex++] = currentPositions[i*3+2];\n\n                        positions[lineIndex++] = currentPositions[j*3];\n                        positions[lineIndex++] = currentPositions[j*3+1];\n                        positions[lineIndex++] = currentPositions[j*3+2];\n                    }\n                }\n            }\n            \n            // å°†å‰©ä½™çš„ buffer å½’é›¶ï¼Œé˜²æ­¢ç”»å‡ºä¹±çº¿\n            for (let k = lineIndex; k < positions.length; k++) {\n                positions[k] = 0;\n            }\n\n            lineSegments.geometry.attributes.position.needsUpdate = true;\n            lineSegments.geometry.setDrawRange(0, lineIndex / 3);\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            const elapsedTime = clock.getElapsedTime();\n            updateDirector(elapsedTime);\n\n            let i = 0;\n            const entropy = directorState.entropy;\n            // ç´¯ç§¯æ³¢æµªç›¸ä½ï¼Œæ¨¡æ‹Ÿå˜é€Ÿ\n            const wavePhase = elapsedTime * directorState.speed; \n\n            for (let x = 0; x < config.gridSize; x++) {\n                for (let z = 0; z < config.gridSize; z++) {\n                    \n                    // ç§©åºæ€\n                    const waveY = Math.sin(x * 0.5 + wavePhase) * 0.3 + Math.cos(z * 0.4 + wavePhase) * 0.3;\n\n                    const ox = originalPositions[i * 3];\n                    const oy = originalPositions[i * 3 + 1] + waveY;\n                    const oz = originalPositions[i * 3 + 2];\n\n                    // å´©å¡Œæ€\n                    const cx = ox + randomOffsets[i * 3];\n                    const cy = oy + randomOffsets[i * 3 + 1];\n                    const cz = oz + randomOffsets[i * 3 + 2];\n\n                    // æ’å€¼\n                    let px = THREE.MathUtils.lerp(ox, cx, entropy);\n                    let py = THREE.MathUtils.lerp(oy, cy, entropy);\n                    let pz = THREE.MathUtils.lerp(oz, cz, entropy);\n\n                    // æ•…éšœç‰¹æ•ˆï¼šé‡å­åŒ–è·³åŠ¨ (Quantized Jitter)\n                    // æ¨¡æ‹Ÿæ•°æ®ä¸¢å¤±ï¼Œä½ç½®ä¸å†å¹³æ»‘ï¼Œè€Œæ˜¯åƒåæ‰çš„ä¿¡å·ä¸€æ ·è·³åŠ¨\n                    if (isGlitchMode && Math.random() > 0.95) {\n                        px += (Math.random() - 0.5) * 0.5;\n                        py += (Math.random() - 0.5) * 0.5;\n                        pz += (Math.random() - 0.5) * 0.5;\n                    }\n\n                    // å­˜å‚¨å½“å‰ä½ç½®ä¾›è¿çº¿ä½¿ç”¨\n                    currentPositions[i*3] = px;\n                    currentPositions[i*3+1] = py;\n                    currentPositions[i*3+2] = pz;\n\n                    dummy.position.set(px, py, pz);\n\n                    // æ—‹è½¬\n                    const rotSpeed = elapsedTime * 0.2;\n                    dummy.rotation.x = THREE.MathUtils.lerp(0, randomRotations[i * 3] + rotSpeed, entropy);\n                    dummy.rotation.y = THREE.MathUtils.lerp(0, randomRotations[i * 3 + 1] + rotSpeed, entropy);\n                    \n                    // æ•…éšœæ¨¡å¼ä¸‹ï¼Œæ—‹è½¬å¶å°”ä¼šç¬é—´å½’é›¶\n                    if (isGlitchMode && Math.random() > 0.98) {\n                        dummy.rotation.set(0,0,0);\n                    }\n\n                    dummy.updateMatrix();\n                    mesh.setMatrixAt(i, dummy.matrix);\n                    i++;\n                }\n            }\n\n            mesh.instanceMatrix.needsUpdate = true;\n            \n            // æ›´æ–°è¿çº¿\n            updateLines();\n\n            renderer.render(scene, camera);\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        init();\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 25,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Raymarched Particles</title>\n    <style>\n        body { margin: 0; overflow: hidden; background-color: #1a1a1a; }\n        canvas { display: block; width: 100vw; height: 100vh; }\n        \n        #ui {\n            position: absolute;\n            bottom: 30px;\n            left: 30px;\n            color: #fff;\n            font-family: 'Helvetica Neue', Arial, sans-serif;\n            font-size: 12px;\n            pointer-events: none;\n            z-index: 10;\n            border-left: 3px solid #fff;\n            padding-left: 15px;\n            opacity: 0.8;\n        }\n        h1 { margin: 0; font-size: 16px; font-weight: 700; letter-spacing: 1px; }\n        p { margin: 5px 0 0; font-size: 11px; color: #aaa; }\n    </style>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js\"></script>\n</head>\n<body>\n    <div id=\"ui\">\n        <h1 id=\"mode-label\">INITIALIZING</h1>\n        <p>RENDER: RAY-CASTED SPHERES</p>\n        <p>LIGHT: DIRECTIONAL (RIGHT -> LEFT)</p>\n    </div>\n\n    <!-- é¡¶ç‚¹ç€è‰²å™¨ï¼šä¼ é€’æ•°æ® -->\n    <script type=\"x-shader/x-vertex\" id=\"vertexshader\">\n        attribute float size;\n        attribute vec3 customColor;\n        varying vec3 vColor;\n        varying vec3 vViewPosition;\n        \n        void main() {\n            vColor = customColor;\n            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n            \n            // å°†è§†å›¾ç©ºé—´çš„ä½ç½®ä¼ é€’ç»™ç‰‡å…ƒç€è‰²å™¨ï¼Œç”¨äºè®¡ç®—å…‰ç…§æ–¹å‘\n            vViewPosition = -mvPosition.xyz;\n            \n            // ç²’å­å¤§å°éšè·ç¦»è¡°å‡\n            gl_PointSize = size * (500.0 / -mvPosition.z);\n            gl_Position = projectionMatrix * mvPosition;\n        }\n    </script>\n\n    <!-- ç‰‡å…ƒç€è‰²å™¨ï¼šæ ¸å¿ƒ Raymarching å…‰å½±è®¡ç®— -->\n    <script type=\"x-shader/x-fragment\" id=\"fragmentshader\">\n        uniform vec3 uLightDir; // å…‰ç…§æ–¹å‘\n        varying vec3 vColor;\n        varying vec3 vViewPosition;\n\n        void main() {\n            // 1. åæ ‡æ˜ å°„ï¼šå°† gl_PointCoord (0åˆ°1) æ˜ å°„åˆ° (-1åˆ°1)\n            vec2 uv = gl_PointCoord.xy * 2.0 - 1.0;\n            \n            // 2. å½¢çŠ¶è£å‰ªï¼šè®¡ç®—åœ†çš„æ–¹ç¨‹ x^2 + y^2\n            float r2 = dot(uv, uv);\n            if (r2 > 1.0) discard; // å¦‚æœè¶…å‡ºåŠå¾„ï¼Œä¸¢å¼ƒåƒç´ ï¼ˆåˆ‡æˆåœ†å½¢ï¼‰\n\n            // 3. Ray-Casting é‡å»º Z è½´ (æ¨¡æ‹Ÿçƒä½“è¡¨é¢éš†èµ·)\n            // çƒä½“æ–¹ç¨‹ï¼šx^2 + y^2 + z^2 = 1  =>  z = sqrt(1 - (x^2 + y^2))\n            float z = sqrt(1.0 - r2);\n\n            // 4. è®¡ç®—æ³•çº¿ (Normal)\n            // åœ¨çƒä½“è¡¨é¢ï¼Œæ³•çº¿å°±æ˜¯ä»åœ†å¿ƒæŒ‡å‘è¯¥ç‚¹çš„å‘é‡\n            vec3 normal = normalize(vec3(uv.x, uv.y, z));\n\n            // 5. å…‰ç…§è®¡ç®— (Lighting Calculation)\n            \n            // A. å®šä¹‰å…‰æº (ä»å³å‘å·¦ï¼Œç¨å¾®åå‰)\n            // æˆ‘ä»¬éœ€è¦å°†å…‰æºè½¬æ¢åˆ°è§†å›¾ç©ºé—´ï¼Œæˆ–è€…å‡è®¾å®ƒæ˜¯å›ºå®šçš„\n            // è¿™é‡Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªå¼ºå¹³è¡Œå…‰\n            vec3 light = normalize(vec3(1.0, 0.5, 1.0)); \n\n            // B. æ¼«åå°„ (Diffuse) - Lambertian\n            // æ³•çº¿å’Œå…‰çº¿çš„ç‚¹ç§¯ã€‚å¦‚æœé¢æœå…‰ï¼Œåˆ™äº®ã€‚\n            float diffuse = max(dot(normal, light), 0.0);\n\n            // C. é«˜å…‰ (Specular) - Blinn-Phong\n            // è®¡ç®—è§†çº¿æ–¹å‘ (View Direction)\n            vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0)); \n            // åŠç¨‹å‘é‡\n            vec3 halfDir = normalize(light + viewDir);\n            float specularAngle = max(dot(normal, halfDir), 0.0);\n            // 60.0 æ˜¯é«˜å…‰é”åº¦ï¼Œè¶Šå¤§æ•°æ®è¶Šåƒé‡‘å±\n            float specular = pow(specularAngle, 60.0);\n\n            // D. ç¯å¢ƒå…‰ (Ambient) - æ¨¡æ‹Ÿæš—éƒ¨ç»†èŠ‚\n            float ambient = 0.15;\n\n            // E. è¾¹ç¼˜å…‰ (Rim Light) - å¢åŠ ä½“ç§¯æ„Ÿ\n            float rim = 1.0 - max(dot(viewDir, normal), 0.0);\n            rim = pow(rim, 3.0) * 0.3;\n\n            // 6. æœ€ç»ˆåˆæˆé¢œè‰²\n            // åŸºç¡€è‰² * (ç¯å¢ƒå…‰ + æ¼«åå°„) + é«˜å…‰ + è¾¹ç¼˜å…‰\n            vec3 finalColor = vColor * (ambient + diffuse) + vec3(0.8) * specular + vec3(0.2) * rim;\n\n            gl_FragColor = vec4(finalColor, 1.0);\n        }\n    </script>\n\n    <script>\n        // å…¨å±€å˜é‡\n        let camera, scene, renderer;\n        let particles;\n        let particleCount = 1000; // å‡å°‘æ•°é‡ï¼Œå¢åŠ å•ä¸ªç²’å­è´¨é‡\n        let currentShape = 0;\n        const shapes = { sphere: [], cube: [], torus: [], grid: [] };\n        \n        // é¼ æ ‡äº¤äº’\n        let mouseX = 0;\n        let mouseY = 0;\n\n        // é”™è¯¯å¤„ç†\n        window.onerror = function(msg) {\n            document.getElementById('mode-label').innerText = \"ERROR\";\n            document.querySelector('p').innerText = msg;\n        };\n\n        init();\n        animate();\n\n        function init() {\n            // 1. åœºæ™¯è®¾ç½®\n            scene = new THREE.Scene();\n            // æ·±ç°è‰²èƒŒæ™¯ï¼Œè¡¬æ‰˜å…‰å½±\n            scene.background = new THREE.Color(0x111111); \n\n            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 4000);\n            camera.position.z = 900;\n\n            renderer = new THREE.WebGLRenderer({ antialias: true }); // å¼€å¯æŠ—é”¯é½¿\n            renderer.setPixelRatio(window.devicePixelRatio);\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            document.body.appendChild(renderer.domElement);\n\n            // 2. æ„å»º Shader æè´¨\n            const shaderMaterial = new THREE.ShaderMaterial({\n                uniforms: {\n                    uLightDir: { value: new THREE.Vector3(1.0, 0.0, 0.0) }\n                },\n                vertexShader: document.getElementById('vertexshader').textContent,\n                fragmentShader: document.getElementById('fragmentshader').textContent,\n                // æ³¨æ„ï¼šè¿™é‡Œä¸éœ€è¦ transparent: trueï¼Œå› ä¸ºæˆ‘ä»¬è¦ç”»å®å¿ƒçƒä½“\n                // ä¹Ÿä¸éœ€è¦ blending: Additiveï¼Œæˆ‘ä»¬è¦çœŸå®çš„é®æŒ¡å…³ç³»\n            });\n\n            // 3. æ„å»ºç²’å­æ•°æ®\n            const geometry = new THREE.BufferGeometry();\n            const positions = [];\n            const colors = [];\n            const sizes = [];\n            const colorObj = new THREE.Color();\n\n            for (let i = 0; i < particleCount; i++) {\n                positions.push(0, 0, 0);\n                \n                // é¢œè‰²ç­–ç•¥ï¼šé‡‘å±è´¨æ„Ÿçš„é…è‰² (é‡‘ã€é“¶ã€é“œã€æ·±è“)\n                const rand = Math.random();\n                if (rand < 0.3) colorObj.setHex(0xffcc00); // é‡‘\n                else if (rand < 0.6) colorObj.setHex(0xcccccc); // é“¶\n                else if (rand < 0.8) colorObj.setHex(0xcd7f32); // é“œ\n                else colorObj.setHex(0x224488); // æ·±è“é‡‘å±\n\n                colors.push(colorObj.r, colorObj.g, colorObj.b);\n                \n                // ç²’å­å°ºå¯¸æ”¾å¤§ï¼Œä»¥ä¾¿çœ‹æ¸…å…‰å½±ç»†èŠ‚\n                sizes.push(30 + Math.random() * 20); \n            }\n\n            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n            geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));\n            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));\n\n            particles = new THREE.Points(geometry, shaderMaterial);\n            scene.add(particles);\n\n            // 4. è®¡ç®—å½¢æ€\n            calculateShapes();\n\n            // 5. äº‹ä»¶ç›‘å¬\n            window.addEventListener('resize', onWindowResize, false);\n            document.addEventListener('mousemove', onMouseMove, false);\n            \n            // 6. å¯åŠ¨å¾ªç¯\n            setInterval(transition, 5000);\n            transition();\n        }\n\n        function calculateShapes() {\n            // A. çƒä½“ (Sphere)\n            const r = 500;\n            for(let i=0; i<particleCount; i++) {\n                const phi = Math.acos(-1+(2*i)/particleCount);\n                const theta = Math.sqrt(particleCount*Math.PI)*phi;\n                shapes.sphere.push(r*Math.cos(theta)*Math.sin(phi), r*Math.sin(theta)*Math.sin(phi), r*Math.cos(phi));\n            }\n\n            // B. ç«‹æ–¹ä½“ (Cube) - æœ‰åºæ’åˆ—\n            const d = Math.cbrt(particleCount);\n            const s = 120; \n            const o = ((d-1)*s)/2;\n            for(let i=0; i<particleCount; i++) {\n                 shapes.cube.push((i%d)*s-o, (Math.floor(i/d)%d)*s-o, (Math.floor(i/(d*d)))*s-o);\n            }\n\n            // C. ç¯é¢ (Torus)\n            for(let i=0; i<particleCount; i++) {\n                const u = i * 0.1;\n                const v = i * 0.05;\n                const R = 400; \n                const tube = 120;\n                shapes.torus.push(\n                    (R + tube * Math.cos(v)) * Math.cos(u),\n                    (R + tube * Math.cos(v)) * Math.sin(u),\n                    tube * Math.sin(v)\n                );\n            }\n\n            // D. æ³¢æµªç½‘æ ¼ (Grid Wave)\n            const dim = Math.sqrt(particleCount);\n            const spacing = 60;\n            const offset = (dim * spacing) / 2;\n            for(let i=0; i<particleCount; i++) {\n                const x = (i % dim) * spacing - offset;\n                const z = (Math.floor(i / dim)) * spacing - offset;\n                shapes.grid.push(x, 0, z); // Yè½´åœ¨åŠ¨ç”»é‡ŒåŠ¨æ€è®¡ç®—\n            }\n        }\n\n        function transition() {\n            const keys = Object.keys(shapes);\n            const next = keys[currentShape];\n            document.getElementById('mode-label').innerText = `MODE: ${next.toUpperCase()}`;\n            \n            const target = shapes[next];\n            const current = particles.geometry.attributes.position.array;\n            const start = Float32Array.from(current);\n            \n            const tween = { t: 0 };\n            new TWEEN.Tween(tween)\n                .to({ t: 1 }, 2500)\n                .easing(TWEEN.Easing.Cubic.InOut)\n                .onUpdate(() => {\n                    for(let i=0; i<particleCount; i++) {\n                        const i3 = i*3;\n                        // å¦‚æœæ˜¯Gridæ¨¡å¼ï¼ŒYè½´åšç‰¹æ®Šæ³¢æµªå¤„ç†\n                        if (next === 'grid') {\n                            const x = target[i3];\n                            const z = target[i3+2];\n                            // ç®€å•çš„æ³¢æµªå‡½æ•°\n                            target[i3+1] = Math.sin(x * 0.01 + Date.now()*0.002) * 100 + Math.cos(z * 0.01) * 100;\n                        }\n\n                        current[i3] = start[i3] + (target[i3] - start[i3]) * tween.t;\n                        current[i3+1] = start[i3+1] + (target[i3+1] - start[i3+1]) * tween.t;\n                        current[i3+2] = start[i3+2] + (target[i3+2] - start[i3+2]) * tween.t;\n                    }\n                    particles.geometry.attributes.position.needsUpdate = true;\n                })\n                .start();\n            \n            currentShape = (currentShape + 1) % keys.length;\n        }\n\n        function onMouseMove(e) {\n            if(e) {\n                mouseX = (e.clientX - window.innerWidth/2);\n                mouseY = (e.clientY - window.innerHeight/2);\n            }\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        function animate(time) {\n            requestAnimationFrame(animate);\n            TWEEN.update();\n\n            const t = time * 0.001;\n\n            // æ•´ä½“ç¼“æ…¢æ—‹è½¬\n            particles.rotation.y = t * 0.1;\n            \n            // é¼ æ ‡è§†å·®æ•ˆæœ\n            camera.position.x += (mouseX * 0.5 - camera.position.x) * 0.05;\n            camera.position.y += (-mouseY * 0.5 - camera.position.y) * 0.05;\n            camera.lookAt(scene.position);\n\n            renderer.render(scene, camera);\n        }\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 26,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Clean Piano Loop</title>\n    <style>\n        body { margin: 0; overflow: hidden; background-color: #000000; }\n        canvas { display: block; width: 100vw; height: 100vh; }\n        #debug {\n            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);\n            color: #444; font-family: sans-serif; font-size: 10px; pointer-events: none;\n        }\n    </style>\n    <script type=\"importmap\">\n        {\n            \"imports\": {\n                \"three\": \"https://unpkg.com/three@0.160.0/build/three.module.js\",\n                \"three/addons/\": \"https://unpkg.com/three@0.160.0/examples/jsm/\"\n            }\n        }\n    </script>\n</head>\n<body>\n    <div id=\"debug\">LOADING...</div>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\n        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n        // --- 1. åœºæ™¯åŸºç¡€ ---\n        const scene = new THREE.Scene();\n        scene.background = new THREE.Color(0x000000);\n        // ç¨å¾®å‡å¼±é›¾æ°”ï¼Œè®©çº¯ç²’å­æ›´é€äº®\n        scene.fog = new THREE.FogExp2(0x000000, 0.01);\n\n        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\n        camera.position.set(0, 3, 7);\n\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setPixelRatio(window.devicePixelRatio);\n        document.body.appendChild(renderer.domElement);\n\n        const controls = new OrbitControls(camera, renderer.domElement);\n        controls.enableDamping = true;\n        controls.autoRotate = true;\n        controls.autoRotateSpeed = 0.6; \n\n        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);\n        dirLight.position.set(10, 10, 5);\n        scene.add(dirLight);\n        scene.add(new THREE.AmbientLight(0xffffff, 0.3));\n\n        // --- 2. æ ¸å¿ƒå˜é‡ (å·²ç§»é™¤ linesGroup) ---\n        let solidGroup = new THREE.Group();\n        let pointsGroup = new THREE.Group();\n        \n        const shaderUniforms = {\n            uTime: { value: 0 },\n            uWaveStrength: { value: 0.0 }, // æ³¢æµªå¼ºåº¦\n            uOpacity: { value: 0.0 },      // ç²’å­é€æ˜åº¦\n            uColor: { value: new THREE.Color(0x00ffff) }\n        };\n\n        // --- 3. Shader (ä¿æŒä¸å˜) ---\n        const particleVertexShader = `\n            uniform float uTime;\n            uniform float uWaveStrength;\n            void main() {\n                vec3 pos = position;\n                vec3 norm = normal;\n                \n                // å¤åˆæ³¢æµªç®—æ³•\n                float wave = sin(pos.x * 2.5 + uTime * 1.2) * 0.3 + \n                             cos(pos.z * 1.5 + uTime * 0.8) * 0.3 + \n                             sin(pos.y * 4.0 + uTime * 2.0) * 0.1;\n                             \n                // åº”ç”¨æ³¢æµª\n                pos += norm * wave * uWaveStrength;\n                \n                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n                gl_Position = projectionMatrix * mvPosition;\n                \n                // ç²’å­å¤§å°\n                gl_PointSize = 2.0 * (10.0 / -mvPosition.z);\n            }\n        `;\n        const particleFragmentShader = `\n            uniform float uOpacity;\n            uniform vec3 uColor;\n            void main() {\n                float r = distance(gl_PointCoord, vec2(0.5, 0.5));\n                if (r > 0.5) discard;\n                gl_FragColor = vec4(uColor, uOpacity);\n            }\n        `;\n\n        // --- 4. åŠ è½½é€»è¾‘ ---\n        const mtlLoader = new MTLLoader();\n        const objLoader = new OBJLoader();\n        const mtlUrl = 'https://raw.githubusercontent.com/Asbeel24/WebModel/main/piano.mtl';\n        const objUrl = 'https://raw.githubusercontent.com/Asbeel24/WebModel/main/piano.obj';\n\n        mtlLoader.load(mtlUrl, (materials) => {\n            materials.preload();\n            for (const key in materials.materials) {\n                materials.materials[key].transparent = true;\n                materials.materials[key].opacity = 1.0;\n                materials.materials[key].depthWrite = false;\n            }\n\n            objLoader.setMaterials(materials);\n            objLoader.load(objUrl, (object) => {\n                // A. å®ä½“æ¨¡å‹\n                solidGroup.add(object);\n                \n                // B. ç²’å­æè´¨\n                const particleMat = new THREE.ShaderMaterial({\n                    uniforms: shaderUniforms,\n                    vertexShader: particleVertexShader,\n                    fragmentShader: particleFragmentShader,\n                    transparent: true,\n                    depthWrite: false,\n                    blending: THREE.AdditiveBlending\n                });\n\n                // C. ç”Ÿæˆç‚¹äº‘ (ä¸å†ç”Ÿæˆçº¿æ¡)\n                object.traverse((child) => {\n                    if (child.isMesh) {\n                        const points = new THREE.Points(child.geometry, particleMat);\n                        pointsGroup.add(points);\n                    }\n                });\n\n                // D. å±…ä¸­ä¸ç¼©æ”¾\n                const box = new THREE.Box3().setFromObject(solidGroup);\n                const center = box.getCenter(new THREE.Vector3());\n                const size = box.getSize(new THREE.Vector3());\n                const maxDim = Math.max(size.x, size.y, size.z);\n                const scale = 4 / maxDim;\n\n                [solidGroup, pointsGroup].forEach(group => {\n                    group.position.sub(center);\n                    group.scale.set(scale, scale, scale);\n                    scene.add(group);\n                });\n                \n                animate();\n            });\n        });\n\n        // --- 5. 1-2-3-2-1 å¾ªç¯åŠ¨ç”»é€»è¾‘ ---\n        const clock = new THREE.Clock();\n        \n        function smoothRange(val, min, max) {\n            return THREE.MathUtils.smoothstep(val, min, max);\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n            \n            const time = clock.getElapsedTime();\n            shaderUniforms.uTime.value = time;\n\n            // === æ—¶é—´è½´è®¾è®¡ (24ç§’å¾ªç¯) ===\n            const cycleDuration = 24;\n            const t = time % cycleDuration;\n            \n            // 1. å˜å½¢æ§åˆ¶ (Morph): 0=å®ä½“, 1=ç‚¹äº‘\n            // 4s-8s: å˜ç‚¹äº‘\n            // 20s-24s: å˜å®ä½“\n            let morphFactor = smoothRange(t, 4, 8) - smoothRange(t, 20, 24);\n\n            // 2. æ³¢æµªæ§åˆ¶ (Wave): 0=é™æ­¢, 1=å‰§çƒˆ\n            // 10s-12s: èµ·æµª\n            // 16s-18s: åœæµª\n            let waveFactor = smoothRange(t, 10, 12) - smoothRange(t, 16, 18);\n\n            // === åº”ç”¨æ•°å€¼ ===\n            \n            // A. å®ä½“é€æ˜åº¦\n            const solidOpacity = 1.0 - morphFactor;\n            setOpacity(solidGroup, solidOpacity);\n            solidGroup.visible = solidOpacity > 0.01;\n\n            // B. ç‚¹äº‘é€æ˜åº¦\n            shaderUniforms.uOpacity.value = morphFactor;\n\n            // C. æ³¢æµªå¼ºåº¦\n            shaderUniforms.uWaveStrength.value = waveFactor * 1.5;\n\n            // æ›´æ–°çŠ¶æ€æ–‡å­—\n            let status = \"\";\n            if (t < 4) status = \"PHASE 1: SOLID (å®ä½“)\";\n            else if (t < 10) status = \"PHASE 2: STATIC POINTS (é™æ­¢ç‚¹äº‘)\";\n            else if (t < 18) status = \"PHASE 3: WAVE CHAOS (æ³¢æµªå¾‹åŠ¨)\";\n            else if (t < 20) status = \"PHASE 2: STATIC POINTS (é™æ­¢ç‚¹äº‘)\";\n            else status = \"PHASE 1: RETURNING (å›å½’å®ä½“)\";\n            document.getElementById('debug').innerText = status;\n\n            controls.update();\n            renderer.render(scene, camera);\n        }\n\n        function setOpacity(group, val) {\n            group.traverse(child => {\n                if (child.isMesh && child.material) {\n                    if (Array.isArray(child.material)) {\n                        child.material.forEach(m => m.opacity = val);\n                    } else {\n                        child.material.opacity = val;\n                    }\n                }\n            });\n        }\n\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 27,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>DARK_MATTER // LOW_BLOOM_VER</title>\n    <style>\n        /* --- CSS: CYBERPUNK UI & RESET --- */\n        :root {\n            --bg-color: #000000;\n            --primary: #00f3ff; /* Cyan */\n            --secondary: #ff0055; /* Magenta */\n            --glass: rgba(0, 20, 40, 0.6);\n            --font-mono: 'Courier New', Courier, monospace;\n        }\n\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            background-color: var(--bg-color);\n            overflow: hidden;\n            font-family: var(--font-mono);\n            color: var(--primary);\n            user-select: none;\n        }\n\n        canvas {\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            z-index: 1;\n        }\n\n        /* HUD Container */\n        #hud {\n            position: absolute;\n            bottom: 30px;\n            left: 50%;\n            transform: translateX(-50%);\n            z-index: 10;\n            display: flex;\n            flex-direction: column;\n            gap: 15px;\n            padding: 20px;\n            background: var(--glass);\n            border: 1px solid var(--primary);\n            box-shadow: 0 0 15px rgba(0, 243, 255, 0.1);\n            backdrop-filter: blur(5px);\n            border-radius: 4px;\n            min-width: 300px;\n        }\n\n        /* Header */\n        .hud-header {\n            display: flex;\n            justify-content: space-between;\n            font-size: 12px;\n            letter-spacing: 2px;\n            border-bottom: 1px solid rgba(0, 243, 255, 0.3);\n            padding-bottom: 8px;\n            margin-bottom: 5px;\n        }\n\n        /* Mode Controls */\n        .mode-controls {\n            display: flex;\n            gap: 10px;\n            justify-content: center;\n        }\n\n        button {\n            background: transparent;\n            border: 1px solid var(--primary);\n            color: var(--primary);\n            padding: 8px 16px;\n            font-family: var(--font-mono);\n            font-size: 11px;\n            cursor: pointer;\n            transition: all 0.3s ease;\n            text-transform: uppercase;\n            letter-spacing: 1px;\n            flex: 1;\n        }\n\n        button:hover {\n            background: rgba(0, 243, 255, 0.1);\n            box-shadow: 0 0 10px var(--primary);\n        }\n\n        button.active {\n            background: var(--primary);\n            color: #000;\n            font-weight: bold;\n            box-shadow: 0 0 15px var(--primary);\n        }\n\n        /* Chaos Slider */\n        .slider-container {\n            display: flex;\n            flex-direction: column;\n            gap: 5px;\n        }\n\n        .slider-label {\n            font-size: 10px;\n            display: flex;\n            justify-content: space-between;\n        }\n\n        input[type=range] {\n            -webkit-appearance: none;\n            width: 100%;\n            background: transparent;\n        }\n\n        input[type=range]::-webkit-slider-thumb {\n            -webkit-appearance: none;\n            height: 14px;\n            width: 14px;\n            background: var(--secondary);\n            cursor: pointer;\n            margin-top: -6px;\n            box-shadow: 0 0 10px var(--secondary);\n        }\n\n        input[type=range]::-webkit-slider-runnable-track {\n            width: 100%;\n            height: 2px;\n            cursor: pointer;\n            background: var(--primary);\n        }\n\n        /* Overlay */\n        .scanlines {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));\n            background-size: 100% 4px;\n            z-index: 5;\n            pointer-events: none;\n            opacity: 0.3;\n        }\n    </style>\n    \n    <script type=\"importmap\">\n        {\n            \"imports\": {\n                \"three\": \"https://unpkg.com/three@0.160.0/build/three.module.js\",\n                \"three/addons/\": \"https://unpkg.com/three@0.160.0/examples/jsm/\"\n            }\n        }\n    </script>\n</head>\n<body>\n\n    <div class=\"scanlines\"></div>\n\n    <div id=\"hud\">\n        <div class=\"hud-header\">\n            <span>SYS.STATUS: ONLINE</span>\n            <span id=\"fps-counter\">60 FPS</span>\n        </div>\n        \n        <div class=\"slider-container\">\n            <div class=\"slider-label\">\n                <span>ENTROPY (CHAOS)</span>\n                <span id=\"chaos-val\">0%</span>\n            </div>\n            <input type=\"range\" id=\"chaos-slider\" min=\"0\" max=\"100\" value=\"10\">\n        </div>\n\n        <div class=\"mode-controls\">\n            <button id=\"btn-mode1\" class=\"active\" onclick=\"app.setMode(0)\">VORTEX</button>\n            <button id=\"btn-mode2\" onclick=\"app.setMode(1)\">MATRIX</button>\n            <button id=\"btn-mode3\" onclick=\"app.setMode(2)\">PLEXUS</button>\n        </div>\n    </div>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\n        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';\n        import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';\n\n        class Sketch {\n            constructor() {\n                this.container = document.body;\n                this.width = window.innerWidth;\n                this.height = window.innerHeight;\n                this.time = 0;\n                \n                this.mouse = new THREE.Vector2(0, 0);\n                this.targetMouse = new THREE.Vector2(0, 0);\n\n                this.params = {\n                    chaos: 0.1,\n                    mode: 0\n                };\n\n                this.initScene();\n                this.initPostProcessing();\n                this.addListeners();\n                \n                this.modes = [\n                    new VortexMode(this),\n                    new MatrixGridMode(this),\n                    new PlexusWebMode(this)\n                ];\n                this.currentMode = this.modes[0];\n                this.currentMode.init();\n\n                this.animate();\n            }\n\n            initScene() {\n                this.scene = new THREE.Scene();\n                // é›¾æ°”æµ“åº¦ä¹Ÿç¨å¾®é™ä½ä¸€ç‚¹ï¼Œè®©èƒŒæ™¯æ›´é»‘\n                this.scene.fog = new THREE.FogExp2(0x000000, 0.0015);\n\n                this.camera = new THREE.PerspectiveCamera(75, this.width / this.height, 0.1, 1000);\n                this.camera.position.z = 50;\n\n                this.renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: \"high-performance\" });\n                this.renderer.setSize(this.width, this.height);\n                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n                this.container.appendChild(this.renderer.domElement);\n            }\n\n            initPostProcessing() {\n                this.composer = new EffectComposer(this.renderer);\n                this.composer.addPass(new RenderPass(this.scene, this.camera));\n\n                // --- [MODIFIED] Bloom Settings Reduced ---\n                // å‚æ•°ï¼šresolution, strength, radius, threshold\n                this.bloomPass = new UnrealBloomPass(new THREE.Vector2(this.width, this.height), 0.5, 0.3, 0.15);\n                this.bloomPass.strength = 0.5;   // é»˜è®¤å¼ºåº¦é™ä½ (åŸ 1.2)\n                this.bloomPass.radius = 0.3;     // æ‰©æ•£åŠå¾„å‡å° (åŸ 0.5)\n                this.bloomPass.threshold = 0.15; // é˜ˆå€¼æé«˜ (åŸ 0)ï¼Œåªæœ‰äº®éƒ¨å‘å…‰\n                this.composer.addPass(this.bloomPass);\n\n                this.rgbShiftPass = new ShaderPass(RGBShiftShader);\n                this.rgbShiftPass.uniforms['amount'].value = 0.0015;\n                this.composer.addPass(this.rgbShiftPass);\n            }\n\n            setMode(index) {\n                if (this.currentMode) this.currentMode.dispose();\n                this.params.mode = index;\n                this.currentMode = this.modes[index];\n                this.currentMode.init();\n                \n                document.querySelectorAll('button').forEach((btn, i) => {\n                    btn.classList.toggle('active', i === index);\n                });\n            }\n\n            updateChaos(val) {\n                this.params.chaos = val / 100;\n                document.getElementById('chaos-val').innerText = val + '%';\n                \n                // --- [MODIFIED] Dynamic Bloom Adjustment ---\n                // å³ä½¿ Chaos æ‹‰æ»¡ï¼ŒBloom ä¹Ÿä¸ä¼šè¿‡æ›\n                this.bloomPass.strength = 0.5 + (this.params.chaos * 1.0); \n                this.rgbShiftPass.uniforms['amount'].value = 0.001 + (this.params.chaos * 0.01);\n            }\n\n            addListeners() {\n                window.addEventListener('resize', () => {\n                    this.width = window.innerWidth;\n                    this.height = window.innerHeight;\n                    this.camera.aspect = this.width / this.height;\n                    this.camera.updateProjectionMatrix();\n                    this.renderer.setSize(this.width, this.height);\n                    this.composer.setSize(this.width, this.height);\n                });\n\n                window.addEventListener('mousemove', (e) => {\n                    this.targetMouse.x = (e.clientX / this.width) * 2 - 1;\n                    this.targetMouse.y = -(e.clientY / this.height) * 2 + 1;\n                });\n\n                document.getElementById('chaos-slider').addEventListener('input', (e) => {\n                    this.updateChaos(e.target.value);\n                });\n            }\n\n            animate() {\n                requestAnimationFrame(this.animate.bind(this));\n                \n                this.time += 0.01 + (this.params.chaos * 0.02);\n                \n                this.mouse.x += (this.targetMouse.x - this.mouse.x) * 0.1;\n                this.mouse.y += (this.targetMouse.y - this.mouse.y) * 0.1;\n\n                const shake = this.params.chaos * 0.5;\n                this.camera.position.x += (Math.sin(this.time) * shake - this.camera.position.x) * 0.05;\n                this.camera.position.y += (Math.cos(this.time * 0.8) * shake - this.camera.position.y) * 0.05;\n                this.camera.lookAt(0, 0, 0);\n\n                if (this.currentMode) {\n                    this.currentMode.update(this.time, this.mouse, this.params.chaos);\n                }\n\n                this.composer.render();\n            }\n        }\n\n        /* --- Visual Modes (Same as before) --- */\n\n        class VisualMode {\n            constructor(app) {\n                this.app = app;\n                this.scene = app.scene;\n                this.mesh = null;\n            }\n            init() {}\n            update(time, mouse, chaos) {}\n            dispose() {\n                if (this.mesh) {\n                    this.scene.remove(this.mesh);\n                    if (this.mesh.geometry) this.mesh.geometry.dispose();\n                    if (this.mesh.material) this.mesh.material.dispose();\n                }\n            }\n        }\n\n        class VortexMode extends VisualMode {\n            init() {\n                const count = 8000;\n                const geometry = new THREE.BufferGeometry();\n                const positions = new Float32Array(count * 3);\n                const colors = new Float32Array(count * 3);\n                \n                for(let i=0; i<count; i++) {\n                    const r = Math.random() * 40 + 5;\n                    const theta = Math.random() * Math.PI * 2;\n                    const phi = (Math.random() - 0.5) * Math.PI; \n                    \n                    positions[i*3] = r * Math.cos(theta) * Math.cos(phi);\n                    positions[i*3+1] = r * Math.sin(theta) * Math.cos(phi);\n                    positions[i*3+2] = r * Math.sin(phi);\n\n                    colors[i*3] = 0.0;\n                    colors[i*3+1] = 0.8 + Math.random() * 0.2;\n                    colors[i*3+2] = 1.0;\n                }\n\n                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n\n                const material = new THREE.PointsMaterial({\n                    size: 0.3,\n                    vertexColors: true,\n                    blending: THREE.AdditiveBlending,\n                    depthWrite: false,\n                    transparent: true\n                });\n\n                this.mesh = new THREE.Points(geometry, material);\n                this.scene.add(this.mesh);\n                this.originalPos = positions.slice();\n            }\n\n            update(time, mouse, chaos) {\n                const positions = this.mesh.geometry.attributes.position.array;\n                const colors = this.mesh.geometry.attributes.color.array;\n                const count = positions.length / 3;\n\n                for(let i=0; i<count; i++) {\n                    const ix = i * 3;\n                    const iy = i * 3 + 1;\n                    const iz = i * 3 + 2;\n\n                    const x = this.originalPos[ix];\n                    const y = this.originalPos[iy];\n                    const z = this.originalPos[iz];\n\n                    const angle = time * (0.5 + chaos) + Math.sqrt(x*x + y*y) * 0.1;\n                    \n                    let nx = x * Math.cos(angle) - z * Math.sin(angle);\n                    let nz = x * Math.sin(angle) + z * Math.cos(angle);\n                    let ny = y + Math.sin(time * 2 + x * 0.1) * 2 * chaos;\n\n                    const dx = nx - mouse.x * 30;\n                    const dy = ny - mouse.y * 30;\n                    const dist = Math.sqrt(dx*dx + dy*dy);\n                    const force = Math.max(0, (15 - dist) / 15);\n\n                    nx += dx * force * 2.0;\n                    ny += dy * force * 2.0;\n\n                    positions[ix] = nx;\n                    positions[iy] = ny;\n                    positions[iz] = nz;\n\n                    colors[ix] = chaos; \n                    colors[iy] = 1.0 - chaos; \n                }\n                \n                this.mesh.geometry.attributes.position.needsUpdate = true;\n                this.mesh.geometry.attributes.color.needsUpdate = true;\n                this.mesh.rotation.z = time * 0.1;\n            }\n        }\n\n        class MatrixGridMode extends VisualMode {\n            init() {\n                const size = 60;\n                const divisions = 50;\n                const geometry = new THREE.PlaneGeometry(size, size, divisions, divisions);\n                \n                const count = geometry.attributes.position.count;\n                const colors = new Float32Array(count * 3);\n                \n                for(let i=0; i<count; i++) {\n                    colors[i*3] = 1.0;   \n                    colors[i*3+1] = 0.0; \n                    colors[i*3+2] = 0.8; \n                }\n                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n\n                const material = new THREE.PointsMaterial({\n                    size: 0.4,\n                    vertexColors: true,\n                    blending: THREE.AdditiveBlending\n                });\n\n                this.mesh = new THREE.Points(geometry, material);\n                this.mesh.rotation.x = -Math.PI / 2; \n                this.scene.add(this.mesh);\n            }\n\n            update(time, mouse, chaos) {\n                const positions = this.mesh.geometry.attributes.position.array;\n                const count = positions.length / 3;\n                const width = 51; \n\n                for(let i=0; i<count; i++) {\n                    const x = i % width;\n                    const y = Math.floor(i / width);\n                    \n                    const ix = positions[i*3];\n                    const iy = positions[i*3+1]; \n\n                    let height = Math.sin(ix * 0.3 + time * 2) * 2;\n                    height += Math.cos(iy * 0.2 + time) * 2;\n                    \n                    if (Math.random() < chaos * 0.1) {\n                        height += (Math.random() - 0.5) * 10;\n                    }\n\n                    const mx = mouse.x * 30;\n                    const my = -mouse.y * 30; \n                    const dist = Math.sqrt(Math.pow(ix - mx, 2) + Math.pow(iy - my, 2));\n                    if (dist < 10) {\n                        height += (10 - dist) * 2;\n                    }\n\n                    positions[i*3+2] = height;\n                }\n                this.mesh.geometry.attributes.position.needsUpdate = true;\n                this.mesh.rotation.z = time * 0.05 * chaos;\n            }\n        }\n\n        class PlexusWebMode extends VisualMode {\n            init() {\n                this.particleCount = 150; \n                this.group = new THREE.Group();\n                this.scene.add(this.group);\n\n                const pGeo = new THREE.BufferGeometry();\n                const pPos = new Float32Array(this.particleCount * 3);\n                this.particlesData = [];\n\n                for (let i = 0; i < this.particleCount; i++) {\n                    const x = Math.random() * 60 - 30;\n                    const y = Math.random() * 60 - 30;\n                    const z = Math.random() * 60 - 30;\n\n                    pPos[i * 3] = x;\n                    pPos[i * 3 + 1] = y;\n                    pPos[i * 3 + 2] = z;\n\n                    this.particlesData.push({\n                        velocity: new THREE.Vector3(\n                            -1 + Math.random() * 2,\n                            -1 + Math.random() * 2,\n                            -1 + Math.random() * 2\n                        ),\n                        numConnections: 0\n                    });\n                }\n                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));\n                \n                const pMat = new THREE.PointsMaterial({\n                    color: 0xFFFFFF,\n                    size: 0.8,\n                    blending: THREE.AdditiveBlending,\n                    transparent: true,\n                    opacity: 0.8\n                });\n                this.pointCloud = new THREE.Points(pGeo, pMat);\n                this.group.add(this.pointCloud);\n\n                const lGeo = new THREE.BufferGeometry();\n                const maxConnections = this.particleCount * this.particleCount; \n                const lPos = new Float32Array(maxConnections * 3);\n                const lCol = new Float32Array(maxConnections * 3); \n                \n                lGeo.setAttribute('position', new THREE.BufferAttribute(lPos, 3).setUsage(THREE.DynamicDrawUsage));\n                lGeo.setAttribute('color', new THREE.BufferAttribute(lCol, 3).setUsage(THREE.DynamicDrawUsage));\n\n                const lMat = new THREE.LineBasicMaterial({\n                    vertexColors: true,\n                    blending: THREE.AdditiveBlending,\n                    transparent: true,\n                    opacity: 0.4\n                });\n\n                this.linesMesh = new THREE.LineSegments(lGeo, lMat);\n                this.group.add(this.linesMesh);\n                \n                this.mesh = this.group; \n            }\n\n            update(time, mouse, chaos) {\n                const pPos = this.pointCloud.geometry.attributes.position.array;\n                const lPos = this.linesMesh.geometry.attributes.position.array;\n                const lCol = this.linesMesh.geometry.attributes.color.array;\n\n                let vertexpos = 0;\n                let colorpos = 0;\n                let numConnected = 0;\n                \n                for (let i = 0; i < this.particleCount; i++) {\n                    const data = this.particlesData[i];\n                    \n                    const speed = 0.2 + chaos * 0.5;\n\n                    pPos[i*3] += data.velocity.x * speed;\n                    pPos[i*3+1] += data.velocity.y * speed;\n                    pPos[i*3+2] += data.velocity.z * speed;\n\n                    if (pPos[i*3] < -30 || pPos[i*3] > 30) data.velocity.x = -data.velocity.x;\n                    if (pPos[i*3+1] < -30 || pPos[i*3+1] > 30) data.velocity.y = -data.velocity.y;\n                    if (pPos[i*3+2] < -30 || pPos[i*3+2] > 30) data.velocity.z = -data.velocity.z;\n\n                    const dx = mouse.x * 40 - pPos[i*3];\n                    const dy = mouse.y * 40 - pPos[i*3+1];\n                    const dist = Math.sqrt(dx*dx + dy*dy);\n                    if (dist < 20) {\n                        pPos[i*3] += dx * 0.02;\n                        pPos[i*3+1] += dy * 0.02;\n                    }\n                }\n                this.pointCloud.geometry.attributes.position.needsUpdate = true;\n\n                const connectionDist = 12 + chaos * 5; \n\n                for (let i = 0; i < this.particleCount; i++) {\n                    for (let j = i + 1; j < this.particleCount; j++) {\n                        \n                        const dx = pPos[i*3] - pPos[j*3];\n                        const dy = pPos[i*3+1] - pPos[j*3+1];\n                        const dz = pPos[i*3+2] - pPos[j*3+2];\n                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);\n\n                        if (dist < connectionDist) {\n                            lPos[vertexpos++] = pPos[i*3];\n                            lPos[vertexpos++] = pPos[i*3+1];\n                            lPos[vertexpos++] = pPos[i*3+2];\n                            \n                            lPos[vertexpos++] = pPos[j*3];\n                            lPos[vertexpos++] = pPos[j*3+1];\n                            lPos[vertexpos++] = pPos[j*3+2];\n\n                            const alpha = 1.0 - dist / connectionDist;\n                            \n                            lCol[colorpos++] = 0.0; \n                            lCol[colorpos++] = 1.0; \n                            lCol[colorpos++] = 1.0; \n\n                            lCol[colorpos++] = 1.0; \n                            lCol[colorpos++] = 0.0; \n                            lCol[colorpos++] = 0.5; \n\n                            numConnected++;\n                        }\n                    }\n                }\n\n                this.linesMesh.geometry.setDrawRange(0, numConnected * 2);\n                this.linesMesh.geometry.attributes.position.needsUpdate = true;\n                this.linesMesh.geometry.attributes.color.needsUpdate = true;\n                \n                this.group.rotation.y = time * 0.1;\n            }\n        }\n\n        window.app = new Sketch();\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 28,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>The Omni-Core | Generative Art</title>\n    <style>\n        /* CSS Reset & Layout */\n        body {\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n            background-color: #050505;\n            font-family: 'Courier New', Courier, monospace;\n            user-select: none;\n        }\n\n        canvas {\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            z-index: 1;\n        }\n\n        /* HUD UI Styling */\n        #hud {\n            position: absolute;\n            bottom: 30px;\n            left: 30px;\n            z-index: 10;\n            color: rgba(255, 255, 255, 0.8);\n            pointer-events: none;\n            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);\n            line-height: 1.5;\n        }\n\n        .hud-line {\n            display: block;\n            font-size: 14px;\n            letter-spacing: 1px;\n        }\n\n        .hud-label {\n            color: #888;\n            font-weight: bold;\n        }\n\n        .hud-value {\n            font-weight: bold;\n        }\n\n        /* Mode Colors for UI */\n        .mode-order { color: #00ffff; }\n        .mode-organic { color: #ff00ff; }\n        .mode-chaos { color: #ff3333; }\n\n        /* Overlay for click hint */\n        #hint {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            color: rgba(255, 255, 255, 0.3);\n            font-size: 12px;\n            z-index: 5;\n            pointer-events: none;\n            animation: fadeOut 4s forwards;\n        }\n\n        @keyframes fadeOut {\n            0% { opacity: 1; }\n            80% { opacity: 1; }\n            100% { opacity: 0; }\n        }\n    </style>\n</head>\n<body>\n\n    <!-- UI Layer -->\n    <div id=\"hint\">[ CLICK TO SWITCH PHASE ]</div>\n    <div id=\"hud\">\n        <span class=\"hud-line\"><span class=\"hud-label\">SYSTEM:</span> <span id=\"ui-mode\" class=\"hud-value mode-order\">INITIALIZING...</span></span>\n        <span class=\"hud-line\"><span class=\"hud-label\">PARTICLES:</span> <span id=\"ui-particles\" class=\"hud-value\">0</span></span>\n        <span class=\"hud-line\"><span class=\"hud-label\">RUNTIME:</span> <span id=\"ui-time\" class=\"hud-value\">00:00</span></span>\n    </div>\n\n    <!-- WebGL Container -->\n    <div id=\"canvas-container\"></div>\n\n    <!-- Import Map for Three.js and Addons -->\n    <script type=\"importmap\">\n        {\n            \"imports\": {\n                \"three\": \"https://unpkg.com/three@0.160.0/build/three.module.js\",\n                \"three/addons/\": \"https://unpkg.com/three@0.160.0/examples/jsm/\"\n            }\n        }\n    </script>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\n        import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';\n\n        /**\n         * THE OMNI-CORE\n         * A Generative Interactive Art System\n         */\n        class OmniCore {\n            constructor() {\n                this.container = document.getElementById('canvas-container');\n                \n                // Configuration\n                this.config = {\n                    particleCount: 4000,\n                    colors: {\n                        order: new THREE.Color(0x00ffff),   // Cyan\n                        organic: new THREE.Color(0xff00ff), // Magenta\n                        chaos: new THREE.Color(0xffffff)    // White/Red mix\n                    },\n                    bg: 0x050505\n                };\n\n                // State\n                this.phases = ['ORDER', 'ORGANIC', 'CHAOS'];\n                this.currentPhaseIdx = 0;\n                this.time = 0;\n                this.mouse = { x: 0, y: 0 };\n                this.targetMouse = { x: 0, y: 0 };\n                \n                // Core Components\n                this.scene = null;\n                this.camera = null;\n                this.renderer = null;\n                this.composer = null;\n                this.coreMesh = null;\n                this.particles = null;\n                this.particleGeo = null;\n                this.originalCorePos = null; // Store original vertices for morphing\n\n                // Post Processing Refs\n                this.bloomPass = null;\n                this.glitchPass = null;\n\n                this.init();\n            }\n\n            init() {\n                // 1. Setup Scene\n                this.scene = new THREE.Scene();\n                this.scene.background = new THREE.Color(this.config.bg);\n                // Subtle fog for depth\n                this.scene.fog = new THREE.FogExp2(this.config.bg, 0.02);\n\n                // 2. Camera\n                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n                this.camera.position.z = 12;\n\n                // 3. Renderer\n                this.renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: \"high-performance\" });\n                this.renderer.setSize(window.innerWidth, window.innerHeight);\n                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n                this.container.appendChild(this.renderer.domElement);\n\n                // 4. Create Objects\n                this.createCore();\n                this.createParticles();\n                this.createAtmosphere();\n\n                // 5. Post Processing\n                this.setupPostProcessing();\n\n                // 6. Events\n                window.addEventListener('resize', this.onResize.bind(this));\n                document.addEventListener('mousemove', this.onMouseMove.bind(this));\n                document.addEventListener('click', this.nextPhase.bind(this));\n\n                // 7. Start Loop\n                this.updateUI();\n                this.animate();\n            }\n\n            createCore() {\n                // Complex Geometry: TorusKnot\n                const geometry = new THREE.TorusKnotGeometry(2, 0.6, 150, 20);\n                \n                // Store original positions for \"Glitch\" and \"Organic\" morphing\n                const posAttribute = geometry.attributes.position;\n                this.originalCorePos = [];\n                for (let i = 0; i < posAttribute.count; i++) {\n                    this.originalCorePos.push(\n                        new THREE.Vector3(posAttribute.getX(i), posAttribute.getY(i), posAttribute.getZ(i))\n                    );\n                }\n\n                const material = new THREE.MeshBasicMaterial({\n                    color: this.config.colors.order,\n                    wireframe: true,\n                    transparent: true,\n                    opacity: 0.8\n                });\n\n                this.coreMesh = new THREE.Mesh(geometry, material);\n                this.scene.add(this.coreMesh);\n            }\n\n            createParticles() {\n                const geometry = new THREE.BufferGeometry();\n                const positions = new Float32Array(this.config.particleCount * 3);\n                const speeds = new Float32Array(this.config.particleCount); // For individual movement speed\n                \n                // Initialize random positions\n                for (let i = 0; i < this.config.particleCount; i++) {\n                    const r = 5 + Math.random() * 5;\n                    const theta = Math.random() * Math.PI * 2;\n                    const phi = Math.acos(2 * Math.random() - 1);\n                    \n                    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);\n                    positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);\n                    positions[i * 3 + 2] = r * Math.cos(phi);\n                    \n                    speeds[i] = 0.5 + Math.random() * 0.5;\n                }\n\n                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n                geometry.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));\n\n                // Create two layers of particles visually via size attenuation\n                const material = new THREE.PointsMaterial({\n                    color: this.config.colors.order,\n                    size: 0.08,\n                    transparent: true,\n                    opacity: 0.6,\n                    blending: THREE.AdditiveBlending\n                });\n\n                this.particles = new THREE.Points(geometry, material);\n                this.particleGeo = geometry;\n                this.scene.add(this.particles);\n            }\n\n            createAtmosphere() {\n                // A subtle noise background sphere\n                const geo = new THREE.IcosahedronGeometry(30, 2);\n                const mat = new THREE.MeshBasicMaterial({\n                    color: 0x111111,\n                    wireframe: true,\n                    transparent: true,\n                    opacity: 0.03,\n                    side: THREE.BackSide\n                });\n                const bgMesh = new THREE.Mesh(geo, mat);\n                this.scene.add(bgMesh);\n                \n                // Add simple ambient light just in case we switch materials later\n                const ambient = new THREE.AmbientLight(0xffffff, 0.5);\n                this.scene.add(ambient);\n            }\n\n            setupPostProcessing() {\n                this.composer = new EffectComposer(this.renderer);\n                \n                const renderPass = new RenderPass(this.scene, this.camera);\n                this.composer.addPass(renderPass);\n\n                // Bloom for Neon Glow\n                this.bloomPass = new UnrealBloomPass(\n                    new THREE.Vector2(window.innerWidth, window.innerHeight),\n                    1.5, // strength\n                    0.4, // radius\n                    0.85 // threshold\n                );\n                this.composer.addPass(this.bloomPass);\n\n                // Glitch for Chaos Mode\n                this.glitchPass = new GlitchPass();\n                this.glitchPass.enabled = false; // Start disabled\n                this.glitchPass.goWild = false;\n                this.composer.addPass(this.glitchPass);\n            }\n\n            // --- LOGIC & ANIMATION ---\n\n            nextPhase() {\n                this.currentPhaseIdx = (this.currentPhaseIdx + 1) % this.phases.length;\n                this.updateUI();\n                this.triggerPhaseTransition();\n            }\n\n            triggerPhaseTransition() {\n                const phase = this.phases[this.currentPhaseIdx];\n                \n                // Reset Glitch\n                this.glitchPass.enabled = (phase === 'CHAOS');\n                \n                // Color Transition\n                let targetColor;\n                if (phase === 'ORDER') targetColor = this.config.colors.order;\n                else if (phase === 'ORGANIC') targetColor = this.config.colors.organic;\n                else targetColor = this.config.colors.chaos;\n\n                this.coreMesh.material.color.set(targetColor);\n                this.particles.material.color.set(targetColor);\n\n                // Bloom Adjustment\n                if(phase === 'CHAOS') {\n                    this.bloomPass.strength = 2.5;\n                    this.bloomPass.radius = 0.8;\n                } else {\n                    this.bloomPass.strength = 1.5;\n                    this.bloomPass.radius = 0.4;\n                }\n            }\n\n            updateCore(time, phase) {\n                const positions = this.coreMesh.geometry.attributes.position;\n                \n                // Reset rotation default\n                this.coreMesh.rotation.y += 0.002;\n                this.coreMesh.rotation.z += 0.001;\n\n                if (phase === 'ORDER') {\n                    // Stable, return to original shape smoothly\n                    for (let i = 0; i < positions.count; i++) {\n                        const orig = this.originalCorePos[i];\n                        positions.setXYZ(i, orig.x, orig.y, orig.z);\n                    }\n                } \n                else if (phase === 'ORGANIC') {\n                    // Breathing / Heartbeat\n                    const scale = 1 + Math.sin(time * 2) * 0.1 + Math.sin(time * 5) * 0.05;\n                    this.coreMesh.scale.setScalar(scale);\n                    \n                    // Subtle wave distortion\n                    for (let i = 0; i < positions.count; i++) {\n                        const orig = this.originalCorePos[i];\n                        const noise = Math.sin(orig.y * 2 + time) * 0.1;\n                        positions.setXYZ(i, orig.x + noise, orig.y, orig.z + noise);\n                    }\n                } \n                else if (phase === 'CHAOS') {\n                    // Jitter vertices\n                    this.coreMesh.scale.setScalar(1);\n                    for (let i = 0; i < positions.count; i++) {\n                        const orig = this.originalCorePos[i];\n                        // Random jitter\n                        const jitter = (Math.random() - 0.5) * 0.3;\n                        positions.setXYZ(i, orig.x + jitter, orig.y + jitter, orig.z + jitter);\n                    }\n                    // Erratic rotation\n                    this.coreMesh.rotation.x += Math.random() * 0.1;\n                }\n\n                positions.needsUpdate = true;\n            }\n\n            updateParticles(time, phase) {\n                const positions = this.particleGeo.attributes.position.array;\n                const speeds = this.particleGeo.attributes.speed.array;\n                const count = this.config.particleCount;\n\n                for (let i = 0; i < count; i++) {\n                    const i3 = i * 3;\n                    let x = positions[i3];\n                    let y = positions[i3 + 1];\n                    let z = positions[i3 + 2];\n                    const s = speeds[i];\n\n                    if (phase === 'ORDER') {\n                        // Form a structured sphere/grid shell\n                        // Simple orbital mechanics\n                        const r = 6;\n                        // Slowly lerp towards a spherical shell\n                        const currentLen = Math.sqrt(x*x + y*y + z*z);\n                        const factor = 0.02 * s;\n                        \n                        x += (x / currentLen * r - x) * factor;\n                        y += (y / currentLen * r - y) * factor;\n                        z += (z / currentLen * r - z) * factor;\n                        \n                        // Rotate entire cloud\n                        const cos = Math.cos(0.001);\n                        const sin = Math.sin(0.001);\n                        const nx = x * cos - z * sin;\n                        const nz = x * sin + z * cos;\n                        x = nx; z = nz;\n                    } \n                    else if (phase === 'ORGANIC') {\n                        // Flow Field / Noise simulation using Sine waves\n                        x += Math.sin(y * 0.5 + time) * 0.02 * s;\n                        y += Math.cos(z * 0.5 + time) * 0.02 * s;\n                        z += Math.sin(x * 0.5 + time) * 0.02 * s;\n\n                        // Boundary check (keep them somewhat contained)\n                        if (x*x + y*y + z*z > 100) {\n                            x *= 0.95; y *= 0.95; z *= 0.95;\n                        }\n                    } \n                    else if (phase === 'CHAOS') {\n                        // Explosion / High speed random\n                        x += (Math.random() - 0.5) * 0.5;\n                        y += (Math.random() - 0.5) * 0.5;\n                        z += (Math.random() - 0.5) * 0.5;\n                        \n                        // If too far, reset to center\n                        if (x*x + y*y + z*z > 200) {\n                            x = 0; y = 0; z = 0;\n                        }\n                    }\n\n                    positions[i3] = x;\n                    positions[i3 + 1] = y;\n                    positions[i3 + 2] = z;\n                }\n\n                this.particleGeo.attributes.position.needsUpdate = true;\n            }\n\n            animate() {\n                requestAnimationFrame(this.animate.bind(this));\n\n                const time = performance.now() * 0.001;\n                const phase = this.phases[this.currentPhaseIdx];\n\n                // 1. Mouse Parallax (Smooth)\n                this.targetMouse.x += (this.mouse.x - this.targetMouse.x) * 0.05;\n                this.targetMouse.y += (this.mouse.y - this.targetMouse.y) * 0.05;\n                this.camera.position.x = this.targetMouse.x * 2;\n                this.camera.position.y = this.targetMouse.y * 2;\n                this.camera.lookAt(0, 0, 0);\n\n                // 2. Update Objects\n                this.updateCore(time, phase);\n                this.updateParticles(time, phase);\n\n                // 3. Update HUD Time\n                const mins = Math.floor(time / 60).toString().padStart(2, '0');\n                const secs = Math.floor(time % 60).toString().padStart(2, '0');\n                document.getElementById('ui-time').innerText = `${mins}:${secs}`;\n\n                // 4. Render\n                this.composer.render();\n            }\n\n            // --- UTILS ---\n\n            onResize() {\n                this.camera.aspect = window.innerWidth / window.innerHeight;\n                this.camera.updateProjectionMatrix();\n                this.renderer.setSize(window.innerWidth, window.innerHeight);\n                this.composer.setSize(window.innerWidth, window.innerHeight);\n            }\n\n            onMouseMove(e) {\n                // Normalize mouse -1 to 1\n                this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;\n                this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;\n            }\n\n            updateUI() {\n                const phase = this.phases[this.currentPhaseIdx];\n                const uiMode = document.getElementById('ui-mode');\n                \n                uiMode.innerText = phase;\n                uiMode.className = 'hud-value'; // reset\n                \n                if (phase === 'ORDER') uiMode.classList.add('mode-order');\n                else if (phase === 'ORGANIC') uiMode.classList.add('mode-organic');\n                else uiMode.classList.add('mode-chaos');\n\n                document.getElementById('ui-particles').innerText = this.config.particleCount;\n            }\n        }\n\n        // Initialize\n        new OmniCore();\n\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 29,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Matrix Rain | Digital Fall</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #000000;\n            font-family: 'Courier New', Courier, monospace;\n        }\n        canvas {\n            display: block;\n        }\n        #ui {\n            position: absolute;\n            top: 20px;\n            right: 20px;\n            color: #0F0;\n            font-size: 14px;\n            font-weight: bold;\n            pointer-events: none;\n            text-align: right;\n            text-shadow: 0 0 5px #0F0;\n            z-index: 10;\n        }\n        .blink {\n            animation: blinker 1s linear infinite;\n        }\n        @keyframes blinker {\n            50% { opacity: 0; }\n        }\n    </style>\n</head>\n<body>\n\n    <div id=\"ui\">\n        <p>SYSTEM STATUS: <span class=\"blink\">CONNECTED</span></p>\n        <p>SOURCE: MATRIX_CORE</p>\n    </div>\n\n    <canvas id=\"canvas\"></canvas>\n\n    <script>\n        /**\n         * åˆ›æ„ç¼–ç¨‹ä¸“å®¶æ¨¡å¼: ON\n         * æ ¸å¿ƒé€»è¾‘: åˆ—çŠ¶æ€ç®¡ç† (Column State) + Alpha é®ç½©æ‹–å½± (Alpha Mask Trails)\n         */\n\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n\n        // --- 1. å­—ç¬¦é›†å®šä¹‰ ---\n        // ç»å…¸çš„é»‘å®¢å¸å›½æ•ˆæœä¸»è¦ä½¿ç”¨åŠè§’ç‰‡å‡å\n        const katakana = 'ã‚¢ã‚¡ã‚«ã‚µã‚¿ãƒŠãƒãƒãƒ¤ãƒ£ãƒ©ãƒ¯ã‚¬ã‚¶ãƒ€ãƒãƒ‘ã‚¤ã‚£ã‚­ã‚·ãƒãƒ‹ãƒ’ãƒŸãƒªãƒ°ã‚®ã‚¸ãƒ‚ãƒ“ãƒ”ã‚¦ã‚¥ã‚¯ã‚¹ãƒ„ãƒŒãƒ•ãƒ ãƒ¦ãƒ¥ãƒ«ã‚°ã‚ºãƒ–ãƒ…ãƒ—ã‚¨ã‚§ã‚±ã‚»ãƒ†ãƒãƒ˜ãƒ¡ãƒ¬ãƒ±ã‚²ã‚¼ãƒ‡ãƒ™ãƒšã‚ªã‚©ã‚³ã‚½ãƒˆãƒãƒ›ãƒ¢ãƒ¨ãƒ§ãƒ­ãƒ²ã‚´ã‚¾ãƒ‰ãƒœãƒãƒ´ãƒƒãƒ³';\n        const latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n        const nums = '0123456789';\n        \n        // ç»„åˆå¹¶è½¬æ¢æˆæ•°ç»„\n        const alphabet = katakana + latin + nums;\n        \n        // --- 2. é…ç½®å‚æ•° ---\n        const fontSize = 16;\n        let columns;\n        let drops = []; // å­˜å‚¨æ¯ä¸€åˆ—é›¨æ»´å½“å‰çš„ Y åæ ‡ (ä»¥è¡Œæ•° grid row ä¸ºå•ä½)\n\n        function init() {\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n\n            // è®¡ç®—å±å¹•èƒ½å®¹çº³å¤šå°‘åˆ—\n            columns = Math.floor(canvas.width / fontSize);\n            \n            // åˆå§‹åŒ–æ¯ä¸€åˆ—çš„ Y åæ ‡\n            // åˆå§‹çŠ¶æ€è®¾ä¸º 1ï¼Œæˆ–è€…éšæœºè´Ÿæ•°è®©å®ƒä»¬é”™è½è½ä¸‹\n            drops = [];\n            for (let x = 0; x < columns; x++) {\n                drops[x] = Math.floor(Math.random() * -100); // éšæœºå»¶è¿Ÿå¯åŠ¨\n            }\n        }\n\n        // --- 3. æ ¸å¿ƒç»˜åˆ¶å¾ªç¯ ---\n        function draw() {\n            // å…³é”®æŠ€å·§ï¼šåˆ¶é€ æ‹–å½±\n            // ä¸å®Œå…¨æ¸…é™¤ç”»å¸ƒï¼Œè€Œæ˜¯ç”»ä¸€ä¸ªåŠé€æ˜çš„é»‘è‰²çŸ©å½¢\n            // é€æ˜åº¦è¶Šä½ (0.05)ï¼Œæ‹–å½±è¶Šé•¿ï¼›é€æ˜åº¦è¶Šé«˜ (0.2)ï¼Œæ‹–å½±è¶ŠçŸ­\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            // è®¾ç½®å­—ä½“æ ·å¼\n            ctx.font = fontSize + 'px monospace';\n            \n            // éå†æ¯ä¸€åˆ—\n            for (let i = 0; i < drops.length; i++) {\n                \n                // éšæœºå–ä¸€ä¸ªå­—ç¬¦\n                const text = alphabet.charAt(Math.floor(Math.random() * alphabet.length));\n                \n                // è®¡ç®—åæ ‡\n                const x = i * fontSize;\n                const y = drops[i] * fontSize;\n\n                // ç»˜åˆ¶é€»è¾‘ï¼š\n                // ä¸ºäº†å¢åŠ ç»†èŠ‚ï¼Œæˆ‘ä»¬è®©é›¨æ»´çš„â€œå¤´éƒ¨â€æ˜¯ç™½è‰²çš„ï¼Œçœ‹èµ·æ¥åƒåœ¨å‘å…‰\n                // ä½†ç”±äºæˆ‘ä»¬ä½¿ç”¨äº†åŠé€æ˜é®ç½©ï¼Œä¸Šä¸€å¸§ç”»çš„ç™½è‰²ä¼šè¢«ç›–ä¸Šä¸€å±‚é»‘ï¼Œè‡ªç„¶å˜æˆç°è‰²/ç»¿è‰²\n                // æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ä¸€ç›´ç”»ç™½è‰²æˆ–äº®ç»¿è‰²å³å¯\n                \n                // å¶å°”è®©å­—ç¬¦å˜ç™½ (æ¨¡æ‹Ÿé—ªçƒ)\n                if (Math.random() > 0.95) {\n                    ctx.fillStyle = '#FFF'; // äº®ç™½\n                } else {\n                    ctx.fillStyle = '#0F0'; // ç»å…¸ç»¿\n                }\n                \n                ctx.fillText(text, x, y);\n\n                // é‡ç½®é€»è¾‘ï¼š\n                // å¦‚æœé›¨æ»´è·‘å‡ºå±å¹•åº•éƒ¨ï¼Œæˆ–è€…éšæœºé‡ç½® (è®©é›¨æ»´çœ‹èµ·æ¥æœ‰é•¿æœ‰çŸ­)\n                // Math.random() > 0.975 æ§åˆ¶äº†é›¨æ»´çš„å¯†åº¦å’Œé•¿åº¦\n                if (y > canvas.height && Math.random() > 0.975) {\n                    drops[i] = 0;\n                }\n\n                // Y åæ ‡ä¸‹ç§»ä¸€è¡Œ\n                drops[i]++;\n            }\n            \n            requestAnimationFrame(draw);\n        }\n\n        // --- 4. å¯åŠ¨ä¸è‡ªé€‚åº” ---\n        window.addEventListener('resize', init);\n        \n        init();\n        draw();\n\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 30,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Matrix Rain | Digital Fall</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #000000;\n            font-family: 'Courier New', Courier, monospace;\n        }\n        canvas {\n            display: block;\n        }\n        #ui {\n            position: absolute;\n            top: 20px;\n            right: 20px;\n            color: #0F0;\n            font-size: 14px;\n            font-weight: bold;\n            pointer-events: none;\n            text-align: right;\n            text-shadow: 0 0 5px #0F0;\n            z-index: 10;\n        }\n        .blink {\n            animation: blinker 1s linear infinite;\n        }\n        @keyframes blinker {\n            50% { opacity: 0; }\n        }\n    </style>\n</head>\n<body>\n\n    <div id=\"ui\">\n        <p>SYSTEM STATUS: <span class=\"blink\">CONNECTED</span></p>\n        <p>SOURCE: MATRIX_CORE</p>\n    </div>\n\n    <canvas id=\"canvas\"></canvas>\n\n    <script>\n        /**\n         * åˆ›æ„ç¼–ç¨‹ä¸“å®¶æ¨¡å¼: ON\n         * æ ¸å¿ƒé€»è¾‘: åˆ—çŠ¶æ€ç®¡ç† (Column State) + Alpha é®ç½©æ‹–å½± (Alpha Mask Trails)\n         */\n\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n\n        // --- 1. å­—ç¬¦é›†å®šä¹‰ ---\n        // ç»å…¸çš„é»‘å®¢å¸å›½æ•ˆæœä¸»è¦ä½¿ç”¨åŠè§’ç‰‡å‡å\n        const katakana = 'ã‚¢ã‚¡ã‚«ã‚µã‚¿ãƒŠãƒãƒãƒ¤ãƒ£ãƒ©ãƒ¯ã‚¬ã‚¶ãƒ€ãƒãƒ‘ã‚¤ã‚£ã‚­ã‚·ãƒãƒ‹ãƒ’ãƒŸãƒªãƒ°ã‚®ã‚¸ãƒ‚ãƒ“ãƒ”ã‚¦ã‚¥ã‚¯ã‚¹ãƒ„ãƒŒãƒ•ãƒ ãƒ¦ãƒ¥ãƒ«ã‚°ã‚ºãƒ–ãƒ…ãƒ—ã‚¨ã‚§ã‚±ã‚»ãƒ†ãƒãƒ˜ãƒ¡ãƒ¬ãƒ±ã‚²ã‚¼ãƒ‡ãƒ™ãƒšã‚ªã‚©ã‚³ã‚½ãƒˆãƒãƒ›ãƒ¢ãƒ¨ãƒ§ãƒ­ãƒ²ã‚´ã‚¾ãƒ‰ãƒœãƒãƒ´ãƒƒãƒ³';\n        const latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n        const nums = '0123456789';\n        \n        // ç»„åˆå¹¶è½¬æ¢æˆæ•°ç»„\n        const alphabet = katakana + latin + nums;\n        \n        // --- 2. é…ç½®å‚æ•° ---\n        const fontSize = 16;\n        let columns;\n        let drops = []; // å­˜å‚¨æ¯ä¸€åˆ—é›¨æ»´å½“å‰çš„ Y åæ ‡ (ä»¥è¡Œæ•° grid row ä¸ºå•ä½)\n\n        function init() {\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n\n            // è®¡ç®—å±å¹•èƒ½å®¹çº³å¤šå°‘åˆ—\n            columns = Math.floor(canvas.width / fontSize);\n            \n            // åˆå§‹åŒ–æ¯ä¸€åˆ—çš„ Y åæ ‡\n            // åˆå§‹çŠ¶æ€è®¾ä¸º 1ï¼Œæˆ–è€…éšæœºè´Ÿæ•°è®©å®ƒä»¬é”™è½è½ä¸‹\n            drops = [];\n            for (let x = 0; x < columns; x++) {\n                drops[x] = Math.floor(Math.random() * -100); // éšæœºå»¶è¿Ÿå¯åŠ¨\n            }\n        }\n\n        // --- 3. æ ¸å¿ƒç»˜åˆ¶å¾ªç¯ ---\n        function draw() {\n            // å…³é”®æŠ€å·§ï¼šåˆ¶é€ æ‹–å½±\n            // ä¸å®Œå…¨æ¸…é™¤ç”»å¸ƒï¼Œè€Œæ˜¯ç”»ä¸€ä¸ªåŠé€æ˜çš„é»‘è‰²çŸ©å½¢\n            // é€æ˜åº¦è¶Šä½ (0.05)ï¼Œæ‹–å½±è¶Šé•¿ï¼›é€æ˜åº¦è¶Šé«˜ (0.2)ï¼Œæ‹–å½±è¶ŠçŸ­\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            // è®¾ç½®å­—ä½“æ ·å¼\n            ctx.font = fontSize + 'px monospace';\n            \n            // éå†æ¯ä¸€åˆ—\n            for (let i = 0; i < drops.length; i++) {\n                \n                // éšæœºå–ä¸€ä¸ªå­—ç¬¦\n                const text = alphabet.charAt(Math.floor(Math.random() * alphabet.length));\n                \n                // è®¡ç®—åæ ‡\n                const x = i * fontSize;\n                const y = drops[i] * fontSize;\n\n                // ç»˜åˆ¶é€»è¾‘ï¼š\n                // ä¸ºäº†å¢åŠ ç»†èŠ‚ï¼Œæˆ‘ä»¬è®©é›¨æ»´çš„â€œå¤´éƒ¨â€æ˜¯ç™½è‰²çš„ï¼Œçœ‹èµ·æ¥åƒåœ¨å‘å…‰\n                // ä½†ç”±äºæˆ‘ä»¬ä½¿ç”¨äº†åŠé€æ˜é®ç½©ï¼Œä¸Šä¸€å¸§ç”»çš„ç™½è‰²ä¼šè¢«ç›–ä¸Šä¸€å±‚é»‘ï¼Œè‡ªç„¶å˜æˆç°è‰²/ç»¿è‰²\n                // æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ä¸€ç›´ç”»ç™½è‰²æˆ–äº®ç»¿è‰²å³å¯\n                \n                // å¶å°”è®©å­—ç¬¦å˜ç™½ (æ¨¡æ‹Ÿé—ªçƒ)\n                if (Math.random() > 0.95) {\n                    ctx.fillStyle = '#FFF'; // äº®ç™½\n                } else {\n                    ctx.fillStyle = '#0F0'; // ç»å…¸ç»¿\n                }\n                \n                ctx.fillText(text, x, y);\n\n                // é‡ç½®é€»è¾‘ï¼š\n                // å¦‚æœé›¨æ»´è·‘å‡ºå±å¹•åº•éƒ¨ï¼Œæˆ–è€…éšæœºé‡ç½® (è®©é›¨æ»´çœ‹èµ·æ¥æœ‰é•¿æœ‰çŸ­)\n                // Math.random() > 0.975 æ§åˆ¶äº†é›¨æ»´çš„å¯†åº¦å’Œé•¿åº¦\n                if (y > canvas.height && Math.random() > 0.975) {\n                    drops[i] = 0;\n                }\n\n                // Y åæ ‡ä¸‹ç§»ä¸€è¡Œ\n                drops[i]++;\n            }\n            \n            requestAnimationFrame(draw);\n        }\n\n        // --- 4. å¯åŠ¨ä¸è‡ªé€‚åº” ---\n        window.addEventListener('resize', init);\n        \n        init();\n        draw();\n\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 31,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Geometric Order | p5.js</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #000000;\n            font-family: 'Courier New', Courier, monospace;\n        }\n        canvas {\n            display: block;\n        }\n        #ui {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            color: rgba(255, 255, 255, 0.7);\n            pointer-events: none;\n            font-size: 12px;\n            z-index: 10;\n            letter-spacing: 1px;\n        }\n        .highlight {\n            color: #00ffaa; /* Spring Green */\n            font-weight: bold;\n        }\n    </style>\n</head>\n<body>\n\n    <div id=\"ui\">\n        <p>MODE: <span id=\"mode-label\" class=\"highlight\">FIBONACCI_SPHERE</span></p>\n        <p>STATUS: <span class=\"highlight\">CONNECTED</span></p>\n        <p>[CLICK] TO MORPH GEOMETRY</p>\n    </div>\n\n    <!-- p5.js CDN -->\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js\"></script>\n\n    <script>\n        /**\n         * åˆ›æ„ç¼–ç¨‹ä¸“å®¶æ¨¡å¼: ON\n         * æ ¸å¿ƒé€»è¾‘: 3D ç‚¹é›†æ’å€¼ (Morphing) + åŠ¨æ€æ‹“æ‰‘è¿çº¿\n         */\n\n        let particles = [];\n        let targets = [];\n        const numParticles = 250; // ç²’å­æ•°é‡ï¼Œè¿‡å¤šä¼šå½±å“è¿çº¿æ€§èƒ½\n        let shapeIndex = 0;\n        const shapes = ['FIBONACCI_SPHERE', 'TORUS_KNOT', 'CUBE_GRID', 'HELIX'];\n        let morphSpeed = 0.05;\n        let connectionDist = 60;\n        let baseRotation = 0;\n\n        function setup() {\n            createCanvas(windowWidth, windowHeight, WEBGL);\n            setAttributes('antialias', true);\n            \n            // åˆå§‹åŒ–ç²’å­\n            for (let i = 0; i < numParticles; i++) {\n                particles.push(createVector(0, 0, 0));\n                targets.push(createVector(0, 0, 0));\n            }\n\n            // ç”Ÿæˆåˆå§‹å½¢çŠ¶ç›®æ ‡\n            updateTargets(0);\n        }\n\n        function draw() {\n            background(5); // ææ·±ç°ï¼Œéçº¯é»‘ä»¥ä¿ç•™æ‹–å½±æ„Ÿ\n            \n            // æ‘„åƒæœºä¸æ—‹è½¬æ§åˆ¶\n            orbitControl(); // å…è®¸ç”¨æˆ·å¾®è°ƒè§†è§’\n            rotateY(frameCount * 0.005);\n            rotateX(frameCount * 0.002);\n\n            // è§†è§‰é£æ ¼è®¾ç½®\n            noFill();\n            \n            // 1. æ›´æ–°ç²’å­ä½ç½® (Morphing Logic)\n            for (let i = 0; i < numParticles; i++) {\n                // ç®€å•çš„çº¿æ€§æ’å€¼ (Lerp) å®ç°å¹³æ»‘å˜å½¢\n                particles[i].x = lerp(particles[i].x, targets[i].x, morphSpeed);\n                particles[i].y = lerp(particles[i].y, targets[i].y, morphSpeed);\n                particles[i].z = lerp(particles[i].z, targets[i].z, morphSpeed);\n            }\n\n            // 2. ç»˜åˆ¶è¿çº¿ (Topology)\n            // ä¸ºäº†æ€§èƒ½ï¼Œä¸è¿›è¡Œå…¨æ’åˆ—éå†ï¼Œè€Œæ˜¯ç®€åŒ–é€»è¾‘æˆ–æ¥å— O(N^2) åœ¨ N=250 æ—¶çš„è´Ÿè½½\n            strokeWeight(1);\n            \n            // åŠ¨æ€å‘¼å¸é¢œè‰²\n            let r = map(sin(frameCount * 0.02), -1, 1, 0, 50);\n            let g = map(cos(frameCount * 0.03), -1, 1, 200, 255);\n            let b = 255;\n            \n            beginShape(LINES);\n            for (let i = 0; i < numParticles; i++) {\n                let p1 = particles[i];\n                \n                // ç»˜åˆ¶èŠ‚ç‚¹\n                push();\n                translate(p1.x, p1.y, p1.z);\n                stroke(255, 200);\n                strokeWeight(2);\n                point(0, 0, 0);\n                pop();\n\n                // å¯»æ‰¾é‚»è¿‘ç‚¹è¿›è¡Œè¿çº¿\n                // ä¼˜åŒ–ï¼šåªæ£€æŸ¥ç´¢å¼•æ¯”è‡ªå·±å¤§çš„ï¼Œé¿å…é‡å¤è¿çº¿\n                for (let j = i + 1; j < numParticles; j++) {\n                    let p2 = particles[j];\n                    let d = p1.dist(p2);\n\n                    if (d < connectionDist) {\n                        // è·ç¦»è¶Šè¿‘ï¼Œçº¿è¶Šäº®\n                        let alpha = map(d, 0, connectionDist, 200, 0);\n                        stroke(r, g, b, alpha);\n                        vertex(p1.x, p1.y, p1.z);\n                        vertex(p2.x, p2.y, p2.z);\n                    }\n                }\n            }\n            endShape();\n        }\n\n        // --- å‡ ä½•ä½“ç”Ÿæˆç®—æ³• ---\n\n        function updateTargets(index) {\n            let r = 200; // åŸºç¡€åŠå¾„\n\n            for (let i = 0; i < numParticles; i++) {\n                let x, y, z;\n                let t = map(i, 0, numParticles, 0, TWO_PI); // å½’ä¸€åŒ–å‚æ•°\n\n                if (index === 0) { \n                    // [Fibonacci Sphere] å‡åŒ€åˆ†å¸ƒçš„çƒä½“\n                    let phi = Math.acos(1 - 2 * (i + 0.5) / numParticles);\n                    let theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);\n                    x = r * Math.sin(phi) * Math.cos(theta);\n                    y = r * Math.sin(phi) * Math.sin(theta);\n                    z = r * Math.cos(phi);\n                } \n                else if (index === 1) {\n                    // [Torus Knot] ç¯é¢ç»“\n                    let p = 2; let q = 3; // ç»“çš„å‚æ•°\n                    let angle = map(i, 0, numParticles, 0, TWO_PI * p);\n                    let r_tube = 60;\n                    let r_torus = 140;\n                    x = (r_torus + r_tube * cos(q * angle)) * cos(angle);\n                    y = (r_torus + r_tube * cos(q * angle)) * sin(angle);\n                    z = r_tube * sin(q * angle);\n                }\n                else if (index === 2) {\n                    // [Cube Grid] éšæœºåˆ†å¸ƒåœ¨ç«‹æ–¹ä½“è¡¨é¢æˆ–å†…éƒ¨\n                    // è¿™é‡Œåšä¸€ä¸ªæ•´é½çš„æ™¶æ ¼åŒ–å¤„ç†\n                    let side = Math.cbrt(numParticles);\n                    let spacing = 300 / side;\n                    let ix = i % side;\n                    let iy = Math.floor((i / side)) % side;\n                    let iz = Math.floor(i / (side * side));\n                    x = (ix - side/2) * spacing * 1.5;\n                    y = (iy - side/2) * spacing * 1.5;\n                    z = (iz - side/2) * spacing * 1.5;\n                    \n                    // åŠ ä¸Šä¸€ç‚¹å™ªæ³¢æ‰“ç ´ç»å¯¹æ•´é½ï¼Œå¢åŠ æœ‰æœºæ„Ÿ\n                    x += random(-10, 10);\n                    y += random(-10, 10);\n                    z += random(-10, 10);\n                }\n                else if (index === 3) {\n                    // [Helix] åŒèºæ—‹ç»“æ„\n                    let h = map(i, 0, numParticles, -300, 300);\n                    let angle = i * 0.2;\n                    let rad = 100 + sin(i * 0.1) * 20;\n                    // åˆ†æˆä¸¤è‚¡\n                    if (i % 2 == 0) {\n                        x = cos(angle) * rad;\n                        z = sin(angle) * rad;\n                    } else {\n                        x = cos(angle + PI) * rad;\n                        z = sin(angle + PI) * rad;\n                    }\n                    y = h;\n                }\n\n                targets[i].set(x, y, z);\n            }\n            \n            // æ›´æ–° UI\n            document.getElementById('mode-label').innerText = shapes[index];\n        }\n\n        // --- äº¤äº’ ---\n\n        function mousePressed() {\n            shapeIndex = (shapeIndex + 1) % shapes.length;\n            updateTargets(shapeIndex);\n            \n            // ç‚¹å‡»æ—¶çš„è§†è§‰åé¦ˆï¼šç¬é—´æ”¹å˜èƒŒæ™¯è‰²ï¼ˆé—ªçƒï¼‰\n            background(50);\n        }\n\n        function windowResized() {\n            resizeCanvas(windowWidth, windowHeight);\n        }\n\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 32,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Digital Aether | Canvas API</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #000000;\n            cursor: crosshair;\n        }\n        canvas {\n            display: block;\n        }\n        #ui {\n            position: absolute;\n            bottom: 30px;\n            right: 30px;\n            color: rgba(255, 255, 255, 0.4);\n            font-family: 'Courier New', Courier, monospace;\n            font-size: 10px;\n            text-align: right;\n            pointer-events: none;\n            user-select: none;\n        }\n        .blink {\n            animation: blinker 2s linear infinite;\n        }\n        @keyframes blinker {\n            50% { opacity: 0; }\n        }\n    </style>\n</head>\n<body>\n\n    <div id=\"ui\">\n        <p>ENTITY_COUNT: <span id=\"count\">0</span></p>\n        <p class=\"blink\">SYSTEM_STATUS: STABLE</p>\n    </div>\n\n    <canvas id=\"canvas\"></canvas>\n\n    <script>\n        /**\n         * åˆ›æ„ç¼–ç¨‹ä¸“å®¶æ¨¡å¼: ON\n         * æ ¸å¿ƒé€»è¾‘: åŸç”Ÿ Canvas 2D ç‰©ç†æ¨¡æ‹Ÿ + ç©ºé—´å“ˆå¸Œä¼˜åŒ–(å¯é€‰) + åƒç´ çº§æ“ä½œ\n         */\n\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d', { alpha: false }); // ä¼˜åŒ–ï¼šå…³é—­é€æ˜é€šé“ä»¥æå‡æ€§èƒ½\n        const uiCount = document.getElementById('count');\n\n        let width, height;\n        let particles = [];\n        const particleCount = 4000; // ç²’å­æ•°é‡\n        \n        // é¼ æ ‡äº¤äº’\n        const mouse = { x: -1000, y: -1000, active: false };\n        const repulsionRadius = 150;\n        const repulsionStrength = 2;\n\n        // æ•…éšœæ•ˆæœå˜é‡\n        let glitchFrame = 0;\n        let isGlitching = false;\n\n        // --- ç²’å­ç±» ---\n        class Particle {\n            constructor() {\n                this.reset(true);\n            }\n\n            reset(randomY = false) {\n                this.x = Math.random() * width;\n                this.y = randomY ? Math.random() * height : -10;\n                this.vx = 0;\n                this.vy = Math.random() * 2 + 1; // ä¸‹è½é€Ÿåº¦\n                this.len = Math.random() * 20 + 5; // å°¾è¿¹é•¿åº¦\n                this.color = Math.random() > 0.9 ? '#ffffff' : '#00ffaa'; // 90% é’è‰²ï¼Œ10% ç™½è‰²é«˜å…‰\n                this.alpha = Math.random() * 0.5 + 0.1;\n                this.friction = 0.95; // æ¢å¤åŸå§‹è·¯å¾„çš„æ‘©æ“¦åŠ›\n            }\n\n            update() {\n                // 1. åŸºç¡€é‡åŠ›\n                this.y += this.vy;\n                this.x += this.vx;\n\n                // 2. é¼ æ ‡æ–¥åŠ›ç‰©ç†è®¡ç®—\n                const dx = this.x - mouse.x;\n                const dy = this.y - mouse.y;\n                const distSq = dx * dx + dy * dy;\n                const dist = Math.sqrt(distSq);\n\n                if (dist < repulsionRadius) {\n                    const force = (repulsionRadius - dist) / repulsionRadius; // è·ç¦»è¶Šè¿‘åŠ›åº¦è¶Šå¤§\n                    const angle = Math.atan2(dy, dx);\n                    \n                    this.vx += Math.cos(angle) * force * repulsionStrength;\n                    this.vy += Math.sin(angle) * force * repulsionStrength;\n                }\n\n                // 3. é˜»å°¼å›å½’ (è®©ç²’å­æ…¢æ…¢æ¢å¤å‚ç›´ä¸‹è½)\n                this.vx *= this.friction;\n                // é™åˆ¶æœ€å¤§é€Ÿåº¦\n                if (this.vy > 5) this.vy = 5;\n                if (this.vy < 1) this.vy += 0.05;\n\n                // 4. è¾¹ç•Œæ£€æŸ¥\n                if (this.y > height + this.len) {\n                    this.reset();\n                }\n                if (this.x > width) this.x = 0;\n                if (this.x < 0) this.x = width;\n            }\n\n            draw(context) {\n                context.globalAlpha = this.alpha;\n                context.fillStyle = this.color;\n                context.fillRect(this.x, this.y, 1.5, this.len); // ä½¿ç”¨ fillRect æ¯” lineTo æ€§èƒ½ç•¥å¥½\n            }\n        }\n\n        // --- åˆå§‹åŒ– ---\n        function init() {\n            resize();\n            particles = [];\n            for (let i = 0; i < particleCount; i++) {\n                particles.push(new Particle());\n            }\n            uiCount.innerText = particleCount;\n        }\n\n        function resize() {\n            width = window.innerWidth;\n            height = window.innerHeight;\n            canvas.width = width;\n            canvas.height = height;\n        }\n\n        // --- æ ¸å¿ƒåŠ¨ç”»å¾ªç¯ ---\n        function animate() {\n            // 1. æ‹–å½±æ•ˆæœ (Trails)\n            // ä¸å®Œå…¨æ¸…é™¤ç”»å¸ƒï¼Œè€Œæ˜¯è¦†ç›–ä¸€å±‚åŠé€æ˜é»‘è‰²ï¼Œå½¢æˆè¿åŠ¨è½¨è¿¹\n            ctx.globalAlpha = 0.2; \n            ctx.fillStyle = '#000000';\n            ctx.fillRect(0, 0, width, height);\n\n            // 2. éšæœºæ•…éšœè§¦å‘ (Glitch Trigger)\n            if (Math.random() < 0.005) { // 0.5% æ¦‚ç‡è§¦å‘\n                isGlitching = true;\n                glitchFrame = 5; // æŒç»­ 5 å¸§\n            }\n\n            // 3. ç»˜åˆ¶ç²’å­\n            ctx.globalCompositeOperation = 'lighter'; // å åŠ æ··åˆæ¨¡å¼ï¼Œäº§ç”Ÿå‘å…‰æ„Ÿ\n            \n            // å¦‚æœæ­£åœ¨æ•…éšœï¼Œåº”ç”¨ RGB åˆ†ç¦»æ•ˆæœ\n            if (isGlitching && glitchFrame > 0) {\n                ctx.save();\n                // çº¢è‰²é€šé“åç§»\n                ctx.translate(Math.random() * 10 - 5, 0);\n                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                particles.forEach(p => {\n                    ctx.fillRect(p.x, p.y, 2, p.len);\n                });\n                ctx.restore();\n\n                // è“è‰²é€šé“åç§»\n                ctx.save();\n                ctx.translate(Math.random() * 10 - 5, 0);\n                ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n                particles.forEach(p => {\n                    ctx.fillRect(p.x, p.y, 2, p.len);\n                });\n                ctx.restore();\n                \n                glitchFrame--;\n            } else {\n                isGlitching = false;\n                // æ­£å¸¸ç»˜åˆ¶\n                for (let i = 0; i < particles.length; i++) {\n                    particles[i].update();\n                    particles[i].draw(ctx);\n                }\n            }\n\n            ctx.globalCompositeOperation = 'source-over'; // æ¢å¤é»˜è®¤æ··åˆæ¨¡å¼\n\n            requestAnimationFrame(animate);\n        }\n\n        // --- äº‹ä»¶ç›‘å¬ ---\n        window.addEventListener('resize', () => {\n            resize();\n            // é‡æ–°åˆ†å¸ƒç²’å­ä»¥é˜²å±å¹•æ‹‰ä¼¸å¯¼è‡´ç©ºç™½\n            particles.forEach(p => {\n                if(p.x > width) p.x = Math.random() * width;\n            });\n        });\n\n        window.addEventListener('mousemove', (e) => {\n            mouse.x = e.clientX;\n            mouse.y = e.clientY;\n            mouse.active = true;\n        });\n\n        // è§¦æ‘¸æ”¯æŒ\n        window.addEventListener('touchmove', (e) => {\n            e.preventDefault();\n            mouse.x = e.touches[0].clientX;\n            mouse.y = e.touches[0].clientY;\n        }, { passive: false });\n\n        // å¯åŠ¨\n        init();\n        animate();\n\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 33,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Neon Cortex Glitch | Raymarching</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #000000;\n            font-family: 'Courier New', Courier, monospace;\n        }\n        canvas {\n            display: block;\n        }\n        #ui {\n            position: absolute;\n            top: 20px;\n            right: 20px;\n            color: rgba(0, 255, 255, 0.8);\n            text-align: right;\n            pointer-events: none;\n            z-index: 10;\n            text-shadow: 2px 0 0 rgba(255,0,0,0.5), -2px 0 0 rgba(0,0,255,0.5); /* Glitch text effect */\n        }\n        .scanline {\n            width: 100%;\n            height: 100px;\n            z-index: 5;\n            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(255, 255, 255, 0.02) 50%, rgba(0,0,0,0) 100%);\n            opacity: 0.1;\n            position: absolute;\n            bottom: 100%;\n            animation: scanline 10s linear infinite;\n            pointer-events: none;\n        }\n        @keyframes scanline {\n            0% { bottom: 100%; }\n            100% { bottom: -100px; }\n        }\n        h1 { margin: 0; font-size: 16px; letter-spacing: 2px; }\n        p { margin: 5px 0 0 0; font-size: 10px; opacity: 0.7; }\n    </style>\n</head>\n<body>\n\n    <div id=\"ui\">\n        <h1>NEON_CORTEX // V.0.9</h1>\n        <p>RENDERING: RAYMARCHING_SDF</p>\n        <p>INTERFERENCE: DETECTED</p>\n    </div>\n    <div class=\"scanline\"></div>\n\n    <!-- Three.js CDN -->\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n\n    <script>\n        /**\n         * åˆ›æ„ç¼–ç¨‹ä¸“å®¶æ¨¡å¼: ON\n         * æ ¸å¿ƒé€»è¾‘: Fragment Shader Raymarching (SDF) + Post-Processing Glitch inside shader\n         */\n\n        const scene = new THREE.Scene();\n        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1); // å…¨å±æ­£äº¤ç›¸æœº\n        const renderer = new THREE.WebGLRenderer({ antialias: false }); // Raymarching ä¸éœ€è¦ä¼ ç»Ÿ AA\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.body.appendChild(renderer.domElement);\n\n        // --- äº¤äº’å˜é‡ ---\n        const mouse = new THREE.Vector2(0.5, 0.5);\n        const targetMouse = new THREE.Vector2(0.5, 0.5);\n\n        document.addEventListener('mousemove', (e) => {\n            targetMouse.x = e.clientX / window.innerWidth;\n            targetMouse.y = 1.0 - e.clientY / window.innerHeight;\n        });\n\n        // --- GLSL Shader ä»£ç  ---\n        const fragmentShader = `\n            uniform float iTime;\n            uniform vec2 iResolution;\n            uniform vec2 iMouse;\n\n            // æ—‹è½¬çŸ©é˜µ\n            mat2 rot(float a) {\n                float s = sin(a);\n                float c = cos(a);\n                return mat2(c, -s, s, c);\n            }\n\n            // SDF: Box Frame (ä¸­ç©ºçš„ç›’å­)\n            float sdBoxFrame( vec3 p, vec3 b, float e ) {\n                p = abs(p)-b;\n                vec3 q = abs(p+e)-e;\n                return min(min(\n                    length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n                    length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n                    length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n            }\n\n            // åœºæ™¯åœ°å›¾ (Map Function)\n            float map(vec3 p) {\n                vec3 p_orig = p;\n                \n                // 1. ç©ºé—´æ‰­æ›² (åŸºäºé¼ æ ‡å’Œæ—¶é—´)\n                // è¿™ç§æ‰­æ›²ä¼šè®©ç›´çº¿éš§é“å˜æˆèºæ—‹\n                float twistAmt = (iMouse.x * 2.0 - 1.0) * 0.5;\n                p.xy *= rot(p.z * (0.1 + twistAmt));\n\n                // 2. ç©ºé—´æŠ˜å  (Modulus) - åˆ¶é€ æ— é™é‡å¤\n                // å°†ç©ºé—´åˆ†å‰²æˆä¸€ä¸ªä¸ªå°æ ¼å­\n                float spacing = 2.5;\n                // ä½¿ç”¨ mod ä¹‹å‰å…ˆè®°å½• IDï¼Œç”¨äºåˆ¶é€ å˜åŒ–\n                float id = floor(p.z / spacing);\n                p.z = mod(p.z, spacing) - spacing * 0.5;\n\n                // 3. å‡ ä½•ä½“å®šä¹‰\n                // æ¯ä¸€ä¸ªé‡å¤å•å…ƒé‡Œæœ‰ä¸€ä¸ªæ—‹è½¬çš„ç›’å­æ¡†æ¶\n                p.xy *= rot(iTime * 0.5 + id); \n                \n                // é¼ æ ‡ Y è½´æ§åˆ¶ç›’å­çš„å¤§å°è„‰å†²\n                float pulse = sin(iTime * 2.0 + p_orig.z * 0.5) * 0.1;\n                float boxSize = 0.8 + (iMouse.y * 0.5) + pulse;\n                \n                return sdBoxFrame(p, vec3(boxSize, boxSize, 0.1), 0.05);\n            }\n\n            // éšæœºå‡½æ•°\n            float random(vec2 st) {\n                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n            }\n\n            void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n                vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n                \n                // --- GLITCH EFFECT 1: UV æŠ–åŠ¨ ---\n                // å¶å°”å‰§çƒˆæŠ–åŠ¨å±å¹•\n                float glitchTrigger = sin(iTime * 10.0) + sin(iTime * 23.0);\n                if (glitchTrigger > 1.8) {\n                    uv.x += (random(vec2(iTime, uv.y)) - 0.5) * 0.1;\n                }\n\n                // --- Raymarching Setup ---\n                vec3 ro = vec3(0.0, 0.0, iTime * 4.0); // æ‘„åƒæœºä½ç½® (æ²¿ Z è½´åŒ€é€Ÿå‰è¿›)\n                \n                // æ‘„åƒæœºæŠ–åŠ¨\n                ro.xy += vec2(sin(iTime)*0.1, cos(iTime*0.8)*0.1) * (iMouse.x * 2.0);\n\n                vec3 rd = normalize(vec3(uv, 1.0)); // å°„çº¿æ–¹å‘\n\n                float t = 0.0; // æ€»è·ç¦»\n                float d = 0.0; // å½“å‰æ­¥è¿›è·ç¦»\n                int i = 0;\n                \n                // --- Raymarching Loop ---\n                for(i = 0; i < 80; i++) {\n                    vec3 p = ro + rd * t;\n                    d = map(p);\n                    t += d;\n                    if(d < 0.001 || t > 50.0) break;\n                }\n\n                // --- Coloring ---\n                vec3 col = vec3(0.0);\n\n                if(t < 50.0) {\n                    // å‡»ä¸­ç‰©ä½“\n                    vec3 p = ro + rd * t;\n                    \n                    // ç®€å•çš„åŸºäºæ·±åº¦çš„é›¾\n                    float fog = 1.0 / (1.0 + t * t * 0.05);\n                    \n                    // éœ“è™¹è‰²è°ƒï¼šåŸºäºè¿­ä»£æ¬¡æ•° (i) å’Œ ç©ºé—´ä½ç½®\n                    // è¾¹ç¼˜å‘å…‰æ•ˆæœ (Glow)\n                    vec3 glowColor = vec3(0.0, 1.0, 1.0); // é’è‰²\n                    if (mod(p.z, 10.0) < 5.0) glowColor = vec3(1.0, 0.0, 1.0); // äº¤æ›¿æ´‹çº¢\n\n                    // æ ¸å¿ƒé¢œè‰²è®¡ç®—\n                    col = glowColor * fog * (float(i) / 80.0) * 2.0;\n                    \n                    // å¢åŠ ä¸€ç‚¹é‡‘å±åå…‰æ„Ÿ\n                    col += vec3(0.2) * fog;\n                } else {\n                    // èƒŒæ™¯ (æ— é™è¿œ)\n                    col = vec3(0.0);\n                }\n\n                // --- GLITCH EFFECT 2: Chromatic Aberration (è‰²å·®) ---\n                // åœ¨æœ€ç»ˆé¢œè‰²ä¸Šåˆ†ç¦» RGB é€šé“\n                float aber = 0.02 * (1.0 + sin(iTime * 20.0) * 0.5); // åŠ¨æ€è‰²å·®å¼ºåº¦\n                // è¿™é‡Œä¸ºäº†æ€§èƒ½ç®€åŒ–ï¼Œå®é™…ä¸Šåº”è¯¥é‡æ–°é‡‡æ ·ï¼Œä½†æˆ‘ä»¬ç”¨ä¸€ç§è¿‘ä¼¼æ–¹æ³•\n                // æˆ‘ä»¬æ ¹æ®å±å¹•è¾¹ç¼˜è·ç¦»å¢åŠ è‰²å·®\n                float distFromCenter = length(uv);\n                col.r += distFromCenter * aber;\n                col.b -= distFromCenter * aber;\n\n                // --- Scanlines (æ‰«æçº¿) ---\n                col *= 0.9 + 0.1 * sin(fragCoord.y * 0.5 + iTime * 10.0);\n\n                // --- Vignette (æš—è§’) ---\n                col *= 1.0 - dot(uv, uv) * 0.8;\n\n                // Gamma correction\n                col = pow(col, vec3(0.4545));\n\n                fragColor = vec4(col, 1.0);\n            }\n\n            void main() {\n                mainImage(gl_FragColor, gl_FragCoord.xy);\n            }\n        `;\n\n        const vertexShader = `\n            void main() {\n                gl_Position = vec4( position, 1.0 );\n            }\n        `;\n\n        // --- 3. åˆ›å»ºå…¨å± Quad ---\n        const geometry = new THREE.PlaneGeometry(2, 2);\n        const uniforms = {\n            iTime: { value: 0 },\n            iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },\n            iMouse: { value: new THREE.Vector2(0.5, 0.5) }\n        };\n\n        const material = new THREE.ShaderMaterial({\n            uniforms: uniforms,\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n            depthWrite: false,\n            depthTest: false\n        });\n\n        const quad = new THREE.Mesh(geometry, material);\n        scene.add(quad);\n\n        // --- 4. åŠ¨ç”»å¾ªç¯ ---\n        const clock = new THREE.Clock();\n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            const time = clock.getElapsedTime();\n            \n            // å¹³æ»‘é¼ æ ‡æ’å€¼\n            mouse.x += (targetMouse.x - mouse.x) * 0.05;\n            mouse.y += (targetMouse.y - mouse.y) * 0.05;\n\n            uniforms.iTime.value = time;\n            uniforms.iMouse.value = mouse;\n\n            renderer.render(scene, camera);\n        }\n\n        // --- 5. çª—å£è‡ªé€‚åº” ---\n        window.addEventListener('resize', () => {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n            renderer.setSize(width, height);\n            uniforms.iResolution.value.set(width, height);\n        });\n\n        animate();\n\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 34,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Neon Turbulance | p5.js</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #000000;\n        }\n        canvas {\n            display: block;\n        }\n        #ui {\n            position: absolute;\n            bottom: 20px;\n            left: 20px;\n            color: rgba(255, 255, 255, 0.5);\n            font-family: 'Courier New', Courier, monospace;\n            font-size: 11px;\n            pointer-events: none;\n            z-index: 10;\n            line-height: 1.5;\n        }\n        .highlight {\n            color: #ff0055;\n            font-weight: bold;\n        }\n    </style>\n</head>\n<body>\n\n    <div id=\"ui\">\n        <p>ALGORITHM: <span class=\"highlight\">PERLIN_FLOW_FIELD</span></p>\n        <p>PARTICLES: <span id=\"p-count\">2000</span></p>\n        <p>INTERACTION: MOUSE DISTORTION</p>\n    </div>\n\n    <!-- p5.js CDN -->\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js\"></script>\n\n    <script>\n        /**\n         * åˆ›æ„ç¼–ç¨‹ä¸“å®¶æ¨¡å¼: ON\n         * æ ¸å¿ƒé€»è¾‘: å‘é‡æµåœº (Vector Flow Field) + ç²’å­è€åŒ–é‡ç½®æœºåˆ¶ + HSB è‰²å½©æ˜ å°„\n         */\n\n        let particles = [];\n        const numParticles = 2000; // ç²’å­æ•°é‡\n        let flowField;\n        let cols, rows;\n        let scl = 20; // æ …æ ¼å¤§å° (Scale)\n        let zOff = 0; // æ—¶é—´ç»´åº¦ (Z-offset for noise)\n        let flowStrength = 0.5; // æµåŠ¨å¼ºåº¦\n\n        function setup() {\n            createCanvas(windowWidth, windowHeight);\n            colorMode(HSB, 360, 100, 100, 100); // ä½¿ç”¨ HSB æ¨¡å¼ä»¥è·å¾—æ›´å¥½çš„éœ“è™¹æ¸å˜\n            background(0);\n            \n            // åˆå§‹åŒ–ç½‘æ ¼åˆ—æ•°å’Œè¡Œæ•°\n            cols = floor(width / scl);\n            rows = floor(height / scl);\n            flowField = new Array(cols * rows);\n\n            // åˆå§‹åŒ–ç²’å­\n            for (let i = 0; i < numParticles; i++) {\n                particles[i] = new Particle();\n            }\n            \n            document.getElementById('p-count').innerText = numParticles;\n        }\n\n        function draw() {\n            // å…³é”®æŠ€å·§ï¼šä¸å®Œå…¨æ¸…é™¤èƒŒæ™¯ï¼Œè€Œæ˜¯è¦†ç›–ä¸€å±‚åŠé€æ˜çš„é»‘è‰²\n            // è¿™åˆ›é€ äº†è¿·äººçš„â€œæ‹–å½±â€æ•ˆæœ\n            noStroke();\n            fill(0, 0, 0, 5); // Alpha = 5 (éå¸¸ä½ï¼Œæ‹–å½±å¾ˆé•¿)\n            rect(0, 0, width, height);\n\n            // 1. è®¡ç®—æµåœº (Flow Field Calculation)\n            let yoff = 0;\n            for (let y = 0; y < rows; y++) {\n                let xoff = 0;\n                for (let x = 0; x < cols; x++) {\n                    // è®¡ç®—ç´¢å¼•\n                    let index = x + y * cols;\n                    \n                    // åŸºç¡€ Perlin Noise è§’åº¦\n                    let angle = noise(xoff, yoff, zOff) * TWO_PI * 4;\n                    \n                    // åˆ›å»ºå‘é‡\n                    let v = p5.Vector.fromAngle(angle);\n                    \n                    // --- äº¤äº’é€»è¾‘ ---\n                    // å¦‚æœé¼ æ ‡åœ¨ç”»å¸ƒå†…ï¼Œè®¡ç®—é¼ æ ‡å¯¹å½“å‰ç½‘æ ¼çš„å½±å“\n                    let mouseDist = dist(x * scl, y * scl, mouseX, mouseY);\n                    if (mouseDist < 300) {\n                        // è®¡ç®—æŒ‡å‘é¼ æ ‡çš„å‘é‡\n                        let mouseVec = createVector(mouseX - x * scl, mouseY - y * scl);\n                        mouseVec.setMag(5); // è®¾å®šå½±å“åŠ›åº¦\n                        // å°†å™ªæ³¢å‘é‡ä¸é¼ æ ‡å‘é‡æ··åˆ\n                        // è·ç¦»è¶Šè¿‘ï¼Œé¼ æ ‡å½±å“è¶Šå¤§\n                        let lerpAmt = map(mouseDist, 0, 300, 0.8, 0);\n                        v.lerp(mouseVec, lerpAmt); \n                    }\n                    \n                    v.setMag(flowStrength); // é™åˆ¶åŠ›çš„å¤§å°\n                    flowField[index] = v;\n                    \n                    xoff += 0.1; // å™ªæ³¢ç©ºé—´æ­¥è¿›\n                }\n                yoff += 0.1;\n            }\n            zOff += 0.003; // æ—¶é—´æµé€ï¼Œè®©æµåœºç¼“æ…¢å˜åŒ–\n\n            // 2. æ›´æ–°å¹¶ç»˜åˆ¶ç²’å­\n            for (let i = 0; i < particles.length; i++) {\n                particles[i].follow(flowField);\n                particles[i].update();\n                particles[i].edges();\n                particles[i].show();\n            }\n        }\n\n        // --- ç²’å­ç±»å®šä¹‰ ---\n        class Particle {\n            constructor() {\n                this.pos = createVector(random(width), random(height));\n                this.vel = createVector(0, 0);\n                this.acc = createVector(0, 0);\n                this.maxSpeed = random(2, 4);\n                \n                // ä¸Šä¸€æ¬¡çš„ä½ç½®ï¼Œç”¨äºç»˜åˆ¶çº¿æ¡\n                this.prevPos = this.pos.copy();\n                \n                // é¢œè‰²åç§»é‡\n                this.hOffset = random(0, 50); \n            }\n\n            follow(vectors) {\n                // æ‰¾åˆ°è‡ªå·±æ‰€åœ¨çš„ç½‘æ ¼åæ ‡\n                let x = floor(this.pos.x / scl);\n                let y = floor(this.pos.y / scl);\n                \n                // è¾¹ç¼˜ä¿æŠ¤ï¼Œé˜²æ­¢ç´¢å¼•è¶Šç•Œ\n                x = constrain(x, 0, cols - 1);\n                y = constrain(y, 0, rows - 1);\n                \n                let index = x + y * cols;\n                let force = vectors[index];\n                this.applyForce(force);\n            }\n\n            applyForce(force) {\n                this.acc.add(force);\n            }\n\n            update() {\n                this.vel.add(this.acc);\n                this.vel.limit(this.maxSpeed);\n                this.pos.add(this.vel);\n                this.acc.mult(0); // é‡ç½®åŠ é€Ÿåº¦\n            }\n\n            show() {\n                // é¢œè‰²é€»è¾‘ï¼šåŸºäºé€Ÿåº¦æ–¹å‘ (Heading) å†³å®šè‰²ç›¸\n                // è¿™ä¼šè®©ä¸åŒæµå‘çš„ç²’å­å‘ˆç°ä¸åŒé¢œè‰²\n                // map è§’åº¦ (-PI åˆ° PI) åˆ° è‰²ç›¸ (0 åˆ° 360)\n                let angle = this.vel.heading(); \n                let hue = map(angle, -PI, PI, 180, 360); \n                \n                // åŠ ä¸Šä¸€ç‚¹éšæœºåç§»å’Œæ—¶é—´å˜åŒ–\n                hue = (hue + this.hOffset + frameCount * 0.1) % 360;\n                \n                // é¥±å’Œåº¦å’Œäº®åº¦è®¾ä¸ºé«˜å€¼ï¼ŒAlpha è®¾ä¸ºä¸­ç­‰\n                stroke(hue, 80, 100, 30); \n                strokeWeight(1.5); // ç¨å¾®åŠ ç²—ä¸€ç‚¹\n                \n                // ç»˜åˆ¶ä»ä¸Šä¸€å¸§ä½ç½®åˆ°å½“å‰ä½ç½®çš„çº¿æ®µï¼Œæ¯”ç”»ç‚¹æ›´è¿è´¯\n                line(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y);\n                \n                this.updatePrev();\n            }\n\n            updatePrev() {\n                this.prevPos.x = this.pos.x;\n                this.prevPos.y = this.pos.y;\n            }\n\n            edges() {\n                // ç¯ç»•å¼è¾¹ç¼˜å¤„ç† (Wrap around)\n                // å½“ç²’å­è·‘å‡ºå±å¹•ï¼Œè®©å®ƒä»å¦ä¸€è¾¹å‡ºç°ï¼Œå¹¶é‡ç½® prevPos ä»¥å…ç”»å‡ºæ¨ªè·¨å±å¹•çš„é•¿çº¿\n                let wrapped = false;\n                if (this.pos.x > width) { this.pos.x = 0; wrapped = true; }\n                if (this.pos.x < 0) { this.pos.x = width; wrapped = true; }\n                if (this.pos.y > height) { this.pos.y = 0; wrapped = true; }\n                if (this.pos.y < 0) { this.pos.y = height; wrapped = true; }\n                \n                if (wrapped) {\n                    this.updatePrev();\n                }\n            }\n        }\n\n        function windowResized() {\n            resizeCanvas(windowWidth, windowHeight);\n            background(0);\n            // é‡æ–°è®¡ç®—ç½‘æ ¼\n            cols = floor(width / scl);\n            rows = floor(height / scl);\n            flowField = new Array(cols * rows);\n        }\n\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 35,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Chaos Attractor | The Butterfly Effect</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #000000;\n            font-family: 'Courier New', Courier, monospace;\n        }\n        canvas {\n            display: block;\n        }\n        #ui {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            color: rgba(255, 255, 255, 0.6);\n            pointer-events: none;\n            font-size: 12px;\n            z-index: 10;\n        }\n        .val {\n            color: #ffaa00;\n            font-weight: bold;\n        }\n    </style>\n</head>\n<body>\n\n    <div id=\"ui\">\n        <p>MODEL: LORENZ_ATTRACTOR</p>\n        <p>SIGMA (MouseX): <span id=\"s-val\" class=\"val\">10.0</span></p>\n        <p>RHO (MouseY): <span id=\"r-val\" class=\"val\">28.0</span></p>\n        <p>POINTS: <span id=\"p-count\" class=\"val\">0</span></p>\n    </div>\n\n    <!-- p5.js CDN -->\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js\"></script>\n\n    <script>\n        /**\n         * åˆ›æ„ç¼–ç¨‹ä¸“å®¶æ¨¡å¼: ON\n         * æ ¸å¿ƒé€»è¾‘: æ´›ä¼¦å…¹æ–¹ç¨‹å¾®åˆ†è®¡ç®— (Euler Integration) + 3D è½¨è¿¹ç»˜åˆ¶\n         */\n\n        // æ´›ä¼¦å…¹æ–¹ç¨‹çš„ä¸‰ä¸ªå˜é‡\n        let x = 0.1;\n        let y = 0;\n        let z = 0;\n\n        // æ´›ä¼¦å…¹æ–¹ç¨‹çš„ä¸‰ä¸ªå¸¸æ•°\n        let sigma = 10;\n        let rho = 28;\n        let beta = 8.0 / 3.0;\n\n        // å­˜å‚¨è½¨è¿¹ç‚¹\n        let points = [];\n        const maxPoints = 4000; // é™åˆ¶æœ€å¤§ç‚¹æ•°ä»¥ä¿è¯æ€§èƒ½\n\n        function setup() {\n            createCanvas(windowWidth, windowHeight, WEBGL);\n            colorMode(HSB, 100); // ä½¿ç”¨ HSB æ¨¡å¼å®ç°å½©è™¹æ¸å˜\n            setAttributes('antialias', true);\n            \n            // ç¨å¾®æ”¾å¤§ä¸€ç‚¹è§†è§’\n            camera(0, 0, 80, 0, 0, 0, 0, 1, 0);\n        }\n\n        function draw() {\n            background(0);\n            \n            // 1. äº¤äº’ï¼šæ ¹æ®é¼ æ ‡ä½ç½®åŠ¨æ€è°ƒæ•´å‚æ•°\n            // åªæœ‰å½“é¼ æ ‡åœ¨ç”»å¸ƒå†…æ—¶æ‰è°ƒæ•´\n            if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {\n                // Sigma èŒƒå›´ 5 - 30\n                sigma = map(mouseX, 0, width, 5, 30);\n                // Rho èŒƒå›´ 10 - 60\n                rho = map(mouseY, 0, height, 10, 60);\n            }\n\n            // æ›´æ–° UI\n            document.getElementById('s-val').innerText = sigma.toFixed(2);\n            document.getElementById('r-val').innerText = rho.toFixed(2);\n            document.getElementById('p-count').innerText = points.length;\n\n            // 2. æ•°å­¦æ ¸å¿ƒï¼šè®¡ç®—å¾®åˆ†æ–¹ç¨‹ (dt æ˜¯æ—¶é—´æ­¥é•¿)\n            let dt = 0.01;\n            \n            // æ´›ä¼¦å…¹æ–¹ç¨‹ç»„\n            let dx = (sigma * (y - x)) * dt;\n            let dy = (x * (rho - z) - y) * dt;\n            let dz = (x * y - beta * z) * dt;\n\n            x = x + dx;\n            y = y + dy;\n            z = z + dz;\n\n            // å°†æ–°ç‚¹å­˜å…¥æ•°ç»„\n            points.push(new p5.Vector(x, y, z));\n\n            // å¦‚æœç‚¹å¤ªå¤šï¼Œç§»é™¤æœ€æ—©çš„ç‚¹ (ä¿æŒè½¨è¿¹é•¿åº¦æ’å®š)\n            if (points.length > maxPoints) {\n                points.shift();\n            }\n\n            // 3. æ¸²æŸ“\n            // è‡ªåŠ¨æ—‹è½¬è§†è§’\n            orbitControl();\n            rotateY(frameCount * 0.005);\n            scale(5); // ç¼©æ”¾æ¨¡å‹ä»¥ä¾¿è§‚å¯Ÿ\n\n            noFill();\n            strokeWeight(0.5); // ç»†çº¿æ›´ç²¾è‡´\n\n            beginShape();\n            for (let i = 0; i < points.length; i++) {\n                let v = points[i];\n                \n                // é¢œè‰²ç®—æ³•ï¼šåŸºäºç‚¹çš„ç´¢å¼•æˆ–ä½ç½®è¿›è¡Œæ¸å˜\n                // è®©é¢œè‰²åœ¨ 0-100 ä¹‹é—´å¾ªç¯\n                let hu = map(i, 0, points.length, 0, 100);\n                // åŠ ä¸Šä¸€ç‚¹åŸºäº Z è½´çš„é¢œè‰²åç§»\n                // hu = (hu + v.z) % 100; \n                \n                stroke(hu, 80, 100);\n                vertex(v.x, v.y, v.z);\n            }\n            endShape();\n            \n            // ç»˜åˆ¶å½“å‰çš„â€œå¤´â€éƒ¨äº®ç‚¹\n            push();\n            translate(x, y, z);\n            stroke(255);\n            strokeWeight(2);\n            point(0,0,0);\n            pop();\n        }\n\n        function windowResized() {\n            resizeCanvas(windowWidth, windowHeight);\n        }\n\n        // åŒå‡»é‡ç½®ç³»ç»Ÿ\n        function doubleClicked() {\n            points = [];\n            x = 0.1;\n            y = 0;\n            z = 0;\n            background(0);\n        }\n\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 36,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Kinetic ASCII | Canvas</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #000000;\n            font-family: 'Courier New', Courier, monospace; /* å¿…é¡»ä½¿ç”¨ç­‰å®½å­—ä½“ */\n        }\n        canvas {\n            display: block;\n        }\n        #ui {\n            position: absolute;\n            bottom: 20px;\n            left: 20px;\n            color: #00ff41;\n            font-size: 12px;\n            pointer-events: none;\n            text-shadow: 0 0 5px #00ff41;\n            background: rgba(0, 0, 0, 0.8);\n            padding: 10px;\n            border: 1px solid #00ff41;\n        }\n    </style>\n</head>\n<body>\n\n    <div id=\"ui\">\n        <p>MODE: ASCII_DENSITY_MAP</p>\n        <p>CHARS: <span id=\"char-count\">0</span></p>\n        <p>FPS: <span id=\"fps\">0</span></p>\n    </div>\n\n    <canvas id=\"canvas\"></canvas>\n\n    <script>\n        /**\n         * åˆ›æ„ç¼–ç¨‹ä¸“å®¶æ¨¡å¼: ON\n         * æ ¸å¿ƒé€»è¾‘: å°† 2D å™ªå£°/æ³¢å½¢å€¼æ˜ å°„åˆ°å­—ç¬¦å¯†åº¦å­—ç¬¦ä¸²ç´¢å¼• (Density String Mapping)\n         */\n\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        \n        // --- é…ç½®å‚æ•° ---\n        const fontSize = 14; // å­—ä½“å¤§å° (åƒç´ )\n        const fontName = 'monospace';\n        \n        // æ ¸å¿ƒï¼šå¯†åº¦å­—ç¬¦ä¸² (ä»æœ€å¯†åˆ°æœ€ç¨€)\n        // ä¸åŒçš„å­—ç¬¦å æ®çš„åƒç´ é¢ç§¯ä¸åŒï¼Œç”¨æ¥æ¨¡æ‹Ÿç°åº¦\n        const density = \"Ã‘@#W$9876543210?!abc;:+=-,._                    \";\n        const len = density.length;\n\n        let cols, rows;\n        let charCount = 0;\n        \n        // äº¤äº’\n        const mouse = { x: -1000, y: -1000 };\n\n        // æ€§èƒ½ç›‘æ§\n        let lastTime = 0;\n        let frameCount = 0;\n\n        function init() {\n            resize();\n            window.addEventListener('resize', resize);\n            window.addEventListener('mousemove', e => {\n                mouse.x = e.clientX;\n                mouse.y = e.clientY;\n            });\n        }\n\n        function resize() {\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            \n            // è®¡ç®—ç½‘æ ¼è¡Œåˆ—\n            cols = Math.floor(canvas.width / fontSize);\n            rows = Math.floor(canvas.height / fontSize);\n            \n            // è®¾ç½®å­—ä½“ä¸Šä¸‹æ–‡ (å¿…é¡»åœ¨ resize åé‡æ–°è®¾ç½®)\n            ctx.font = `${fontSize}px ${fontName}`;\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            \n            charCount = cols * rows;\n            document.getElementById('char-count').innerText = charCount;\n        }\n\n        function draw(time) {\n            // è®¡ç®— FPS\n            const now = performance.now();\n            if (now - lastTime >= 1000) {\n                document.getElementById('fps').innerText = frameCount;\n                frameCount = 0;\n                lastTime = now;\n            }\n            frameCount++;\n\n            // æ¸…é™¤èƒŒæ™¯ (ä½¿ç”¨åŠé€æ˜é»‘è‰²åˆ¶é€ ä¸€ç‚¹ç‚¹æ®‹å½±ï¼Œæˆ–è€…çº¯é»‘)\n            ctx.fillStyle = '#000000';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            // æ—¶é—´å˜é‡ (ç§’)\n            const t = time * 0.001;\n\n            // --- æ ¸å¿ƒå¾ªç¯ ---\n            for (let y = 0; y < rows; y++) {\n                for (let x = 0; x < cols; x++) {\n                    \n                    // 1. è®¡ç®—å½“å‰æ ¼å­çš„åƒç´ åæ ‡\n                    const posX = x * fontSize + fontSize / 2;\n                    const posY = y * fontSize + fontSize / 2;\n\n                    // 2. ç”Ÿæˆâ€œå™ªå£°â€å€¼ (0.0 åˆ° 1.0)\n                    // è¿™é‡Œæˆ‘ä»¬ç»„åˆå‡ ä¸ªæ­£å¼¦æ³¢æ¥æ¨¡æ‹Ÿæµä½“\n                    // æ³¢ 1: å¯¹è§’çº¿ç§»åŠ¨\n                    const wave1 = Math.sin(x * 0.05 + y * 0.05 + t);\n                    // æ³¢ 2: æ—‹è½¬å¹²æ‰°\n                    const wave2 = Math.cos(x * 0.03 - y * 0.03 - t * 0.5);\n                    \n                    let value = (wave1 + wave2 + 2) / 4; // å½’ä¸€åŒ–åˆ° 0-1\n\n                    // 3. é¼ æ ‡äº¤äº’ (è·ç¦»åœº)\n                    const dx = posX - mouse.x;\n                    const dy = posY - mouse.y;\n                    const dist = Math.sqrt(dx*dx + dy*dy);\n                    const mouseRadius = 300;\n\n                    if (dist < mouseRadius) {\n                        // é¼ æ ‡é™„è¿‘å¢åŠ äº®åº¦/å¯†åº¦\n                        const interaction = (mouseRadius - dist) / mouseRadius;\n                        value += interaction * 0.8; \n                    }\n\n                    // 4. æ˜ å°„åˆ°å­—ç¬¦ç´¢å¼•\n                    // value è¶Šå¤§ï¼Œç´¢å¼•è¶Šå° (è¶Šå¯†)\n                    // value è¶Šå°ï¼Œç´¢å¼•è¶Šå¤§ (è¶Šç¨€ï¼Œç›´åˆ°ç©ºæ ¼)\n                    let charIndex = Math.floor(map(value, 0, 1.5, len - 1, 0));\n                    \n                    // è¾¹ç•Œé™åˆ¶\n                    if (charIndex < 0) charIndex = 0;\n                    if (charIndex >= len) charIndex = len - 1;\n\n                    const char = density.charAt(charIndex);\n\n                    // 5. åŠ¨æ€ç€è‰²\n                    // åŸºç¡€æ˜¯ç»¿è‰²ï¼Œä½†é«˜äº®éƒ¨åˆ†å˜ç™½ï¼Œæš—éƒ¨å˜æ·±ç»¿\n                    if (charIndex < 5) {\n                        ctx.fillStyle = '#ffffff'; // æœ€äº®çš„éƒ¨åˆ†ç™½è‰²\n                    } else if (charIndex < 15) {\n                        ctx.fillStyle = '#00ff41'; // ç»å…¸é»‘å®¢ç»¿\n                    } else {\n                        ctx.fillStyle = '#003b00'; // æš—éƒ¨æ·±ç»¿\n                    }\n\n                    // ç»˜åˆ¶å­—ç¬¦\n                    // åªæœ‰éç©ºæ ¼æ‰ç»˜åˆ¶ï¼Œæå‡æ€§èƒ½\n                    if (char !== ' ') {\n                        ctx.fillText(char, posX, posY);\n                    }\n                }\n            }\n\n            requestAnimationFrame(draw);\n        }\n\n        // è¾…åŠ©å‡½æ•°ï¼šæ•°å€¼æ˜ å°„\n        function map(value, start1, stop1, start2, stop2) {\n            return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n        }\n\n        // å¯åŠ¨\n        init();\n        requestAnimationFrame(draw);\n\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 37,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Recursive Metropolis | p5.js</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #111;\n        }\n        canvas {\n            display: block;\n        }\n        #ui {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            color: rgba(255, 255, 255, 0.7);\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            font-size: 12px;\n            pointer-events: none;\n            background: rgba(0, 0, 0, 0.6);\n            padding: 10px 15px;\n            border-left: 3px solid #00ffcc;\n        }\n        .instruction {\n            margin-top: 5px;\n            color: #00ffcc;\n            font-weight: bold;\n        }\n    </style>\n</head>\n<body>\n\n    <div id=\"ui\">\n        <p>ALGO: RECURSIVE_SUBDIVISION</p>\n        <p>BLOCKS: <span id=\"block-count\">0</span></p>\n        <p class=\"instruction\">CLICK TO REGENERATE</p>\n    </div>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js\"></script>\n\n    <script>\n        /**\n         * åˆ›æ„ç¼–ç¨‹ä¸“å®¶æ¨¡å¼: ON\n         * æ ¸å¿ƒé€»è¾‘: é€’å½’çŸ©å½¢åˆ†å‰² + æ¦‚ç‡æ€§ç»†èŠ‚å¡«å……\n         */\n\n        let blocks = [];\n        let maxBlocks = 800; // æœ€å¤§åˆ†å‰²æ•°é‡\n        let palette = [];\n\n        function setup() {\n            createCanvas(windowWidth, windowHeight);\n            \n            // å®šä¹‰èµ›åšæœ‹å…‹è‰²æ¿\n            palette = [\n                color(10, 10, 10),    // æ·±é»‘\n                color(20, 20, 30),    // æ·±è“ç°\n                color(0, 255, 204),   // éœ“è™¹é’\n                color(255, 0, 85),    // æ•…éšœçº¢\n                color(255, 255, 255)  // çº¯ç™½é«˜å…‰\n            ];\n\n            generateCity();\n        }\n\n        function draw() {\n            // åŠ¨ç”»è¿‡ç¨‹ï¼šå¦‚æœå½“å‰å—æ•°å°‘äºç›®æ ‡ï¼Œç»§ç»­åˆ†å‰²\n            // è¿™åˆ›é€ äº†â€œç”Ÿé•¿â€çš„åŠ¨ç”»æ•ˆæœ\n            if (blocks.length < maxBlocks) {\n                splitRandomBlock();\n            }\n\n            background(10);\n            \n            // ç»˜åˆ¶æ‰€æœ‰å—\n            for (let b of blocks) {\n                b.display();\n            }\n\n            document.getElementById('block-count').innerText = blocks.length;\n        }\n\n        function generateCity() {\n            blocks = [];\n            // åˆå§‹ï¼šä¸€ä¸ªè¦†ç›–å…¨å±çš„å¤§å—\n            blocks.push(new Block(10, 10, width - 20, height - 20));\n        }\n\n        function splitRandomBlock() {\n            // éšæœºé€‰å–ä¸€ä¸ªé¢ç§¯è¶³å¤Ÿå¤§çš„å—è¿›è¡Œåˆ†å‰²\n            // è¿‡æ»¤æ‰å¤ªå°çš„å—ï¼Œé˜²æ­¢æ— é™ç»†åˆ†\n            let candidates = blocks.filter(b => b.w > 20 && b.h > 20);\n            \n            if (candidates.length === 0) return;\n\n            // éšæœºé€‰ä¸€ä¸ª\n            let index = floor(random(candidates.length));\n            let target = candidates[index];\n            \n            // ä»æ•°ç»„ä¸­ç§»é™¤å®ƒ\n            // æ³¨æ„ï¼šå› ä¸º candidates æ˜¯è¿‡æ»¤åçš„å‰¯æœ¬ï¼Œæˆ‘ä»¬éœ€è¦åœ¨åŸæ•°ç»„ä¸­æ‰¾åˆ°å®ƒ\n            let originalIndex = blocks.indexOf(target);\n            blocks.splice(originalIndex, 1);\n\n            // åˆ†å‰²å®ƒï¼Œå¾—åˆ°ä¸¤ä¸ªæ–°å—\n            let newBlocks = target.split();\n            blocks.push(newBlocks[0]);\n            blocks.push(newBlocks[1]);\n        }\n\n        function mousePressed() {\n            generateCity();\n        }\n\n        function windowResized() {\n            resizeCanvas(windowWidth, windowHeight);\n            generateCity();\n        }\n\n        // --- çŸ©å½¢å—ç±» ---\n        class Block {\n            constructor(x, y, w, h) {\n                this.x = x;\n                this.y = y;\n                this.w = w;\n                this.h = h;\n                \n                // éšæœºå±æ€§\n                this.color = random(palette);\n                this.type = random() > 0.8 ? 'detail' : 'solid'; // 20% æ¦‚ç‡æ˜¯ç»†èŠ‚å—\n                this.hasBorder = random() > 0.5;\n            }\n\n            display() {\n                stroke(0);\n                strokeWeight(2);\n\n                if (this.type === 'solid') {\n                    // æ™®é€šå®å¿ƒå—ï¼Œå¸¦ä¸€ç‚¹é€æ˜åº¦\n                    fill(red(this.color), green(this.color), blue(this.color), 200);\n                    rect(this.x, this.y, this.w, this.h);\n                    \n                    // å¶å°”åŠ ä¸ªå†…éƒ¨é«˜äº®æ¡†\n                    if (this.w > 50 && this.h > 50 && random() > 0.9) {\n                        noFill();\n                        stroke(255, 100);\n                        rect(this.x + 5, this.y + 5, this.w - 10, this.h - 10);\n                    }\n\n                } else {\n                    // ç»†èŠ‚å—ï¼šç”»æˆç”µè·¯æ¿æˆ–ç™¾å¶çª—æ ·å¼\n                    fill(20);\n                    rect(this.x, this.y, this.w, this.h);\n                    \n                    stroke(this.color);\n                    strokeWeight(1);\n                    \n                    if (this.w > this.h) {\n                        // æ¨ªå‘çº¹ç†\n                        for(let i = 0; i < this.h; i += 5) {\n                            line(this.x, this.y + i, this.x + this.w, this.y + i);\n                        }\n                    } else {\n                        // çºµå‘çº¹ç†\n                        for(let i = 0; i < this.w; i += 5) {\n                            line(this.x + i, this.y, this.x + i, this.y + this.h);\n                        }\n                    }\n                }\n                \n                // è£…é¥°ï¼šåœ¨è§’è½ç”»å°ç‚¹ (æ¨¡æ‹Ÿé“†é’‰)\n                if (this.w > 40 && this.h > 40) {\n                    noStroke();\n                    fill(255);\n                    rect(this.x + 2, this.y + 2, 2, 2);\n                    rect(this.x + this.w - 4, this.y + this.h - 4, 2, 2);\n                }\n            }\n\n            split() {\n                // å†³å®šåˆ†å‰²æ–¹å‘ï¼š\n                // å¦‚æœå¾ˆå®½ï¼Œå€¾å‘äºå‚ç›´åˆ†å‰²ï¼›å¦‚æœå¾ˆé«˜ï¼Œå€¾å‘äºæ°´å¹³åˆ†å‰²\n                let splitHorizontal = random() > 0.5;\n                if (this.w > this.h * 1.5) splitHorizontal = false;\n                if (this.h > this.w * 1.5) splitHorizontal = true;\n\n                let b1, b2;\n                \n                if (splitHorizontal) {\n                    // æ°´å¹³åˆ†å‰² (ä¸Šä¸‹ä¸¤å—)\n                    // åˆ†å‰²ç‚¹åœ¨ 30% åˆ° 70% ä¹‹é—´\n                    let splitY = random(this.h * 0.3, this.h * 0.7);\n                    b1 = new Block(this.x, this.y, this.w, splitY);\n                    b2 = new Block(this.x, this.y + splitY, this.w, this.h - splitY);\n                } else {\n                    // å‚ç›´åˆ†å‰² (å·¦å³ä¸¤å—)\n                    let splitX = random(this.w * 0.3, this.w * 0.7);\n                    b1 = new Block(this.x, this.y, splitX, this.h);\n                    b2 = new Block(this.x + splitX, this.y, this.w - splitX, this.h);\n                }\n                \n                return [b1, b2];\n            }\n        }\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 38,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Flow Field | Digital Oil Painting</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #000;\n        }\n        canvas {\n            display: block;\n        }\n        #ui {\n            position: absolute;\n            bottom: 20px;\n            left: 20px;\n            color: rgba(255, 255, 255, 0.8);\n            font-family: sans-serif;\n            font-size: 12px;\n            pointer-events: none;\n            background: rgba(0, 0, 0, 0.5);\n            padding: 10px;\n            border-radius: 4px;\n        }\n    </style>\n</head>\n<body>\n\n    <div id=\"ui\">\n        <p>ALGO: PERLIN_FLOW_FIELD</p>\n        <p>PARTICLES: 2000</p>\n        <p>CLICK TO RE-GENERATE</p>\n    </div>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js\"></script>\n\n    <script>\n        /**\n         * åˆ›æ„ç¼–ç¨‹ä¸“å®¶æ¨¡å¼: ON\n         * æ ¸å¿ƒé€»è¾‘: ç²’å­ç³»ç»Ÿ + å‘é‡åœº (Vector Field) + è½¨è¿¹ä¿ç•™\n         */\n\n        let particles = [];\n        const numParticles = 2000; // ç²’å­æ•°é‡ï¼Œè¶Šå¤šè¶Šç»†è…»ä½†è¶Šå¡\n        const noiseScale = 0.01; // å™ªå£°ç¼©æ”¾ï¼Œè¶Šå°çº¿æ¡è¶Šå¹³æ»‘\n        let baseHue;\n\n        function setup() {\n            createCanvas(windowWidth, windowHeight);\n            colorMode(HSB, 360, 100, 100, 100);\n            \n            resetSketch();\n        }\n\n        function draw() {\n            // æ³¨æ„ï¼šæˆ‘ä»¬ä¸ä½¿ç”¨ background() æ¸…é™¤å±å¹•\n            // è¿™æ ·ç²’å­çš„è½¨è¿¹å°±ä¼šä¿ç•™ä¸‹æ¥ï¼Œå½¢æˆç»˜ç”»æ•ˆæœ\n            \n            for (let i = 0; i < particles.length; i++) {\n                particles[i].follow();\n                particles[i].update();\n                particles[i].show();\n                particles[i].edges();\n            }\n        }\n\n        function resetSketch() {\n            background(0); // é‡ç½®æ—¶æ¶‚é»‘èƒŒæ™¯\n            noiseSeed(millis()); // éšæœºåŒ–å™ªå£°ç§å­\n            baseHue = random(360); // éšæœºä¸»è‰²è°ƒ\n\n            particles = [];\n            for (let i = 0; i < numParticles; i++) {\n                particles.push(new Particle());\n            }\n        }\n\n        function mousePressed() {\n            resetSketch();\n        }\n\n        function windowResized() {\n            resizeCanvas(windowWidth, windowHeight);\n            resetSketch();\n        }\n\n        // --- ç²’å­ç±» ---\n        class Particle {\n            constructor() {\n                this.pos = createVector(random(width), random(height));\n                this.vel = createVector(0, 0);\n                this.acc = createVector(0, 0);\n                this.maxSpeed = 2; // ç§»åŠ¨é€Ÿåº¦\n                \n                // æ¯ä¸ªç²’å­æœ‰è½»å¾®çš„é¢œè‰²å·®å¼‚\n                this.h = baseHue + random(-30, 30); \n                if (this.h > 360) this.h -= 360;\n                if (this.h < 0) this.h += 360;\n                \n                this.prevPos = this.pos.copy();\n            }\n\n            follow() {\n                // æ ¸å¿ƒç®—æ³•ï¼šæ ¹æ®å½“å‰ä½ç½®è®¡ç®—å™ªå£°è§’åº¦\n                // noise() è¿”å› 0-1ï¼Œæˆ‘ä»¬æ˜ å°„åˆ° 0-4PI (ä¸¤åœˆï¼Œå¢åŠ å¤æ‚æ€§)\n                let angle = noise(this.pos.x * noiseScale, this.pos.y * noiseScale) * TWO_PI * 2;\n                \n                // å°†è§’åº¦è½¬æ¢ä¸ºå‘é‡\n                let force = p5.Vector.fromAngle(angle);\n                force.setMag(0.5); // åŠ›çš„å¤§å°\n                this.applyForce(force);\n            }\n\n            applyForce(force) {\n                this.acc.add(force);\n            }\n\n            update() {\n                this.vel.add(this.acc);\n                this.vel.limit(this.maxSpeed);\n                this.pos.add(this.vel);\n                this.acc.mult(0); // é‡ç½®åŠ é€Ÿåº¦\n            }\n\n            show() {\n                // ç»˜åˆ¶çº¿æ¡ï¼šä»ä¸Šä¸€å¸§ä½ç½®ç”»åˆ°å½“å‰ä½ç½®\n                // ä½¿ç”¨æä½çš„é€æ˜åº¦ (5/100)ï¼Œè®©é¢œè‰²æ…¢æ…¢å åŠ \n                stroke(this.h, 80, 100, 5); \n                strokeWeight(1);\n                line(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y);\n                \n                this.updatePrev();\n            }\n\n            updatePrev() {\n                this.prevPos.x = this.pos.x;\n                this.prevPos.y = this.pos.y;\n            }\n\n            edges() {\n                // å¦‚æœç²’å­è·‘å‡ºå±å¹•ï¼Œéšæœºé‡ç½®åˆ°å±å¹•å†…ä»»æ„ä½ç½®\n                // è¿™æ ·å¯ä»¥ä¿è¯å±å¹•ä¸Šä¸€ç›´æœ‰ç²’å­åœ¨ç”»\n                if (this.pos.x > width || this.pos.x < 0 || this.pos.y > height || this.pos.y < 0) {\n                    this.pos = createVector(random(width), random(height));\n                    this.updatePrev();\n                }\n            }\n        }\n\n    </script>\n</body>\n</html>"
    },
    {
        "åºå·": 39,
        "ä»£ç ": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>SYSTEM_CORE_DUMP | p5.js WebGL</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #000;\n            cursor: crosshair; /* åå­—å‡†æ˜Ÿå…‰æ ‡ï¼Œå¢åŠ ç§‘æŠ€æ„Ÿ */\n        }\n        canvas {\n            display: block;\n        }\n        #ui {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            font-family: 'Courier New', Courier, monospace;\n            color: #0f0; /* é»‘å®¢ç»¿ */\n            font-size: 14px;\n            pointer-events: none;\n            z-index: 10;\n            text-shadow: 2px 2px 0px rgba(255, 0, 255, 0.5);\n            background: rgba(0, 0, 0, 0.7);\n            padding: 10px;\n            border: 1px solid #0f0;\n        }\n        .blink {\n            animation: blinker 1s linear infinite;\n        }\n        @keyframes blinker {\n            50% { opacity: 0; }\n        }\n    </style>\n</head>\n<body>\n\n    <div id=\"ui\">\n        <div>// ERROR: SEGMENTATION_FAULT</div>\n        <div>// CORE_TEMP: <span class=\"blink\">CRITICAL</span></div>\n        <div style=\"margin-top: 10px; color: #fff;\">[CLICK] TO RECOMPILE</div>\n    </div>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js\"></script>\n\n    <script>\n        /**\n         * åˆ›æ„ç¼–ç¨‹ä¸“å®¶æ¨¡å¼: ON\n         * æ ¸å¿ƒæŠ€æœ¯: p5.js WEBGL + æ‰‹åŠ¨ RGB é€šé“åˆ†ç¦» (Manual RGB Split)\n         * æˆ‘ä»¬ä¸ä½¿ç”¨ç€è‰²å™¨ï¼Œè€Œæ˜¯é€šè¿‡å¤šæ¬¡ç»˜åˆ¶åœºæ™¯å¹¶è°ƒæ•´é¢œè‰²é€šé“æ··åˆæ¨¡å¼æ¥æ¨¡æ‹Ÿæ•…éšœè‰²å·®ã€‚\n         */\n\n        let geometryType = 0; // 0: Box, 1: Torus, 2: Sphere\n        let glitchIntensity = 0;\n        let font;\n\n        function setup() {\n            createCanvas(windowWidth, windowHeight, WEBGL);\n            setAttributes('antialias', true);\n            \n            // ä½¿ç”¨ additive blending æ¨¡å¼ï¼Œè¿™æ · R+G+B = ç™½\n            // è¿™æ˜¯å®ç° RGB åˆ†ç¦»æ•ˆæœçš„å…³é”®\n            blendMode(ADD); \n        }\n\n        function draw() {\n            // WebGL æ¨¡å¼ä¸‹èƒŒæ™¯æ¸…é™¤éœ€è¦é‡ç½® blendMode\n            blendMode(BLEND);\n            background(10, 5, 15); // æ·±ç´«è‰²èƒŒæ™¯\n            \n            // è®¡ç®—æ•…éšœå¼ºåº¦ (éšæ—¶é—´æ³¢åŠ¨ï¼Œå¶å°”å‰§çƒˆ)\n            let chaos = noise(frameCount * 0.1);\n            glitchIntensity = (chaos > 0.7) ? map(chaos, 0.7, 1.0, 2, 20) : 1;\n\n            // æ‘„åƒæœºæ—‹è½¬é€»è¾‘\n            let rotX = mouseY * 0.01;\n            let rotY = mouseX * 0.01;\n\n            // --- æ ¸å¿ƒæ¸²æŸ“é€»è¾‘ï¼šç»˜åˆ¶ä¸‰æ¬¡ä»¥å®ç° RGB åˆ†ç¦» ---\n            blendMode(ADD);\n\n            // 1. çº¢è‰²é€šé“ (Red Channel)\n            push();\n            translate(random(-glitchIntensity, glitchIntensity), random(-glitchIntensity, glitchIntensity), 0);\n            stroke(255, 0, 0); \n            drawScene(rotX, rotY, 1.0);\n            pop();\n\n            // 2. ç»¿è‰²é€šé“ (Green Channel) - ç¨å¾®æ»åä¸€ç‚¹æˆ–ç¼©æ”¾ä¸€ç‚¹\n            push();\n            stroke(0, 255, 0);\n            drawScene(rotX, rotY, 1.01); \n            pop();\n\n            // 3. è“è‰²é€šé“ (Blue Channel)\n            push();\n            translate(random(-glitchIntensity, glitchIntensity), random(-glitchIntensity, glitchIntensity), 0);\n            stroke(0, 0, 255);\n            drawScene(rotX, rotY, 0.99);\n            pop();\n\n            // --- ç»˜åˆ¶æ‰«æçº¿ (Scanlines) ---\n            // åœ¨ 3D ç©ºé—´å‰é¢ç”»ä¸€äº›æ¨ªçº¿\n            blendMode(BLEND);\n            stroke(0, 0, 0, 100);\n            strokeWeight(2);\n            for(let i = -height/2; i < height/2; i+=4) {\n                // ç®€å•çš„è§†è§‰æ¬ºéª—ï¼Œä¸å®Œå…¨è¦†ç›–\n                if (i % 8 === 0) {\n                    line(-width/2, i, 0, width/2, i, 0);\n                }\n            }\n        }\n\n        // å°è£…åœºæ™¯ç»˜åˆ¶å‡½æ•°ï¼Œä»¥ä¾¿é‡å¤è°ƒç”¨\n        function drawScene(rx, ry, scaleFactor) {\n            push();\n            \n            // å…¨å±€æ—‹è½¬\n            rotateX(rx);\n            rotateY(ry);\n            rotateZ(frameCount * 0.005);\n            \n            scale(scaleFactor);\n            noFill();\n            strokeWeight(1.5);\n\n            // å¶å°”å‡ºç°çš„å‰§çƒˆæŠ–åŠ¨\n            if (random() < 0.05) {\n                scale(random(0.8, 1.2));\n                rotateZ(random(PI));\n            }\n\n            // --- ç»˜åˆ¶ä¸­å¿ƒå‡ ä½•ä½“ ---\n            push();\n            // å†…éƒ¨æ ¸å¿ƒ\n            if (geometryType === 0) {\n                // åµŒå¥—ç«‹æ–¹ä½“\n                box(200);\n                rotateX(frameCount * 0.02);\n                rotateY(frameCount * 0.02);\n                box(100);\n            } else if (geometryType === 1) {\n                // ç¯é¢ç»“\n                torus(120, 40, 24, 16);\n                rotateX(PI/2);\n                torus(80, 20, 12, 12);\n            } else {\n                // ç»çº¬çƒä½“\n                sphere(150, 12, 12);\n                rotateY(frameCount * 0.05);\n                sphere(80, 8, 8);\n            }\n            pop();\n\n            // --- ç»˜åˆ¶å¤–éƒ¨è½¨é“ç¯ (Orbit Rings) ---\n            strokeWeight(1);\n            push();\n            rotateX(PI / 2);\n            rotateZ(frameCount * 0.01);\n            torus(300, 2, 50, 3); // ç»†ç¯\n            pop();\n\n            push();\n            rotateY(PI / 2);\n            rotateZ(-frameCount * 0.02);\n            torus(350, 2, 50, 3);\n            pop();\n\n            // --- ç»˜åˆ¶æ¼‚æµ®çš„æ•°æ®ç¢ç‰‡ (Particles) ---\n            // ä½¿ç”¨éšæœºç§å­ç¡®ä¿æ¯ä¸€å¸§ç²’å­ä½ç½®ç›¸å¯¹å›ºå®šï¼Œåªéšæ•´ä½“æ—‹è½¬\n            randomSeed(100); \n            for (let i = 0; i < 30; i++) {\n                push();\n                let r = 400;\n                let theta = random(TWO_PI) + frameCount * 0.01 * random(-1, 1);\n                let phi = random(PI);\n                let x = r * sin(phi) * cos(theta);\n                let y = r * sin(phi) * sin(theta);\n                let z = r * cos(phi);\n                \n                translate(x, y, z);\n                // ç²’å­ä¹Ÿæ˜¯å°å‡ ä½•ä½“\n                box(random(5, 20)); \n                pop();\n            }\n\n            pop();\n        }\n\n        function mousePressed() {\n            // åˆ‡æ¢å‡ ä½•å½¢æ€\n            geometryType = (geometryType + 1) % 3;\n            // ç‚¹å‡»æ—¶äº§ç”Ÿå¼ºçƒˆçš„æ•…éšœé—ªçƒèƒŒæ™¯\n            background(255);\n        }\n\n        function windowResized() {\n            resizeCanvas(windowWidth, windowHeight);\n        }\n\n    </script>\n</body>\n</html>"
    }
]